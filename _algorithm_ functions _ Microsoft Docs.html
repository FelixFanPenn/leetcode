<!DOCTYPE html>
<!-- saved from url=(0094)https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#find_if -->
<html class="hasSidebar hasPageActions hasBreadcrumb conceptual js" lang="en-us" dir="ltr" data-css-variable-support="true" data-authenticated="false" data-auth-status-determined="true" data-target="docs" x-ms-format-detection="none"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
	<link rel="stylesheet" href="./_algorithm_ functions _ Microsoft Docs_files/51-6d3a1e"><link rel="stylesheet" href="./_algorithm_ functions _ Microsoft Docs_files/override.css">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<meta property="og:title" content="&lt;algorithm&gt; functions">
	<meta property="og:type" content="website">
	<meta property="og:url" content="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions">

	<meta name="twitter:card" content="summary">
	<meta name="twitter:site" content="@docsmsft">

		<meta name="ROBOTS" content="INDEX,FOLLOW">
<meta name="ms.tgt_pltfrm" content="">
<meta name="author" content="corob-msft">
<meta name="ms.author" content="corob">
<meta name="audience" content="developer">
<meta name="manager" content="wpickett">
<meta name="breadcrumb_path" content="../_breadcrumb/toc.json?view=vs-2019">
<meta name="ms.topic" content="reference">
<meta name="ms.date" content="11/04/2016">
<meta name="ms.technology" content="cpp-standard-libraries">
<meta name="ms.workload" content="cplusplus">
<meta name="ms.prod" content="visual-cpp">
<meta name="ms.assetid" content="c10b0c65-410c-4c83-abf8-8b7f61bba8d0">
<meta name="search.ms_sitename" content="Docs">
<meta name="search.ms_docsetname" content="vcppdocs">
<meta name="version" content="0">
<meta name="locale" content="en-us">
<meta name="site_name" content="Docs">
<meta name="search.ms_product" content="VS">
<meta name="depot_name" content="VS.vcppdocs">
<meta name="updated_at" content="2019-01-16 06:44 PM">
<meta name="gitcommit" content="https://github.com/MicrosoftDocs/cpp-docs-pr/blob/8cb67dbbf19d8bb79d064c48dcf5ff412e918728/docs/standard-library/algorithm-functions.md">
<meta name="original_content_git_url" content="https://github.com/MicrosoftDocs/cpp-docs-pr/blob/live/docs/standard-library/algorithm-functions.md">
<meta name="document_id" content="ab2345d5-8891-8d5d-5a8c-b7b4382d4541">
<meta name="document_version_independent_id" content="03684e91-dbcd-5acc-b86d-7099dac5b473">
<meta name="monikers" content="vs-2015">
<meta name="monikers" content="vs-2017">
<meta name="monikers" content="vs-2019">
<meta name="page_type" content="conceptual">
<meta name="toc_rel" content="TOC.json?view=vs-2019">
<meta name="pdf_url_template" content="https://docs.microsoft.com/pdfstore/en-us/VS.vcppdocs/{branchName}{pdfName}">
<meta name="search.mshattr.devlang" content="c++">
<meta name="word_count" content="41206">

	<meta name="scope" content="C++">
<link href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions" rel="canonical">
	<title>&lt;algorithm&gt; functions | Microsoft Docs</title>

		<link rel="stylesheet" href="./_algorithm_ functions _ Microsoft Docs_files/cbb402e7.site-ltr.css">

	<link rel="stylesheet" href="./_algorithm_ functions _ Microsoft Docs_files/f1e7d9d9.conceptual.css">


	<script async="" src="./_algorithm_ functions _ Microsoft Docs_files/analytics.js"></script><script>
	var msDocs = {
		data: {
			timeOrigin: Date.now(),
			azureHeaderLocale: 'en-us',
			contentLocale: 'en-us',
			contentDir: 'ltr',
			userLocale: 'en-us',
			userDir: 'ltr',
			pageTemplate: 'Conceptual',
			brand: '',
			context: {

			},
			hasComments: true,
			feedbackSystem: 'GitHub',
			feedbackGitHubRepo: 'MicrosoftDocs/cpp-docs',
			feedbackProductUrl: 'https://developercommunity.visualstudio.com/spaces/62/index.html',
			contentGitUrl: 'https://github.com/Microsoft/cpp-docs/blob/master/docs/standard-library/algorithm-functions.md',
		},
		functions:{},
		settings:{
			extendBreadcrumb: true,
			enableUHFPPE: false
		}
	};
	if (!('Promise' in window && 'resolve' in window.Promise && 'reject' in window.Promise && 'all' in window.Promise && 'race' in window.Promise)) {
		document.write('<script src="https://static.docs.com/ui/third-party/bluebird/3.5.0/bluebird.min.js" integrity="sha384-aD4BDeDGeLXLpPK4yKeqtZQa9dv4a/7mQ+4L5vwshIYH1Mc2BrXvHd32iHzYCQy5" crossorigin="anonymous"><\/script>');
	}
	if (typeof fetch !== 'function') {
		document.write('<script src="https://static.docs.com/ui/third-party/fetch/2.0.3/fetch.min.js" integrity="sha384-H3LQq82b6Mm80GYRHtRSlTwO9DoXctmYCVEYk9M8mp97lRzs6DuSrHVUg3SBP9w0" crossorigin="anonymous"><\/script>');
	}
	if (typeof HTMLTemplateElement === 'undefined') {
		document.write('<script src="https://static.docs.com/ui/third-party/template/1.4.0/template.min.js" integrity="sha384-1zKzI6ldTVHMU7n0W2HpE/lhHI+UG4D9IIaxbj3kT2UhCWicdTuJkTtnKuu0CQzN" crossorigin="anonymous"><\/script>');
	}
	if (typeof URL !== 'function') {
		document.write('<script src="https://static.docs.com/ui/third-party/url/0.5.7/url.min.js" integrity="sha384-vn7xBMtpSTfzaTRWxj0kVq0UcsbBrTOgZ/M1ISHqe1V358elYva+lfiEC+T8jLPc" crossorigin="anonymous"><\/script>');
	}
	</script>

	<script src="./_algorithm_ functions _ Microsoft Docs_files/jquery-3.3.1.min.js" integrity="sha384-tsQFqpEReu7ZLhBV2VZlAu7zcOV+rXbYlF2cqB8txI/8aZajjp4Bqd+V6D5IgvKT" crossorigin="anonymous"></script>
		<script src="./_algorithm_ functions _ Microsoft Docs_files/a511a00b.index-docs.js"></script><style>
		[data-moniker]:not([data-moniker~='vs-2019']) {
			display: none !important;
		}
	</style><script src="./_algorithm_ functions _ Microsoft Docs_files/jsll-4.js" async="" defer=""></script>

<script src="./_algorithm_ functions _ Microsoft Docs_files/18-d72213" defer=""></script><style>
			.c-uhfh input[type="search"],
			.c-uhfh.c-sgl-stck .c-uhfh-actions .c-search input[type="search"] {
				padding-left: 69px !important;
			}</style><script async="" src="./_algorithm_ functions _ Microsoft Docs_files/t.js"></script><script async="" src="./_algorithm_ functions _ Microsoft Docs_files/t(1).js"></script><script async="" src="./_algorithm_ functions _ Microsoft Docs_files/t(2).js"></script><script async="" src="./_algorithm_ functions _ Microsoft Docs_files/t(3).js"></script><script async="" src="./_algorithm_ functions _ Microsoft Docs_files/t(4).js"></script><script async="" src="./_algorithm_ functions _ Microsoft Docs_files/t(5).js"></script><script async="" src="./_algorithm_ functions _ Microsoft Docs_files/t(6).js"></script><script async="" src="./_algorithm_ functions _ Microsoft Docs_files/t(7).js"></script><script async="" src="./_algorithm_ functions _ Microsoft Docs_files/t(8).js"></script><script async="" src="./_algorithm_ functions _ Microsoft Docs_files/t(9).js"></script><script async="" src="./_algorithm_ functions _ Microsoft Docs_files/t(10).js"></script><script async="" src="./_algorithm_ functions _ Microsoft Docs_files/t(11).js"></script><script async="" src="./_algorithm_ functions _ Microsoft Docs_files/t(12).js"></script><script async="" src="./_algorithm_ functions _ Microsoft Docs_files/t(13).js"></script><script async="" src="./_algorithm_ functions _ Microsoft Docs_files/t(14).js"></script><script async="" src="./_algorithm_ functions _ Microsoft Docs_files/t(15).js"></script><script async="" src="./_algorithm_ functions _ Microsoft Docs_files/t(16).js"></script><script async="" src="./_algorithm_ functions _ Microsoft Docs_files/t(17).js"></script><script async="" src="./_algorithm_ functions _ Microsoft Docs_files/t(18).js"></script><script async="" src="./_algorithm_ functions _ Microsoft Docs_files/t(19).js"></script><script async="" src="./_algorithm_ functions _ Microsoft Docs_files/t(20).js"></script><script async="" src="./_algorithm_ functions _ Microsoft Docs_files/t(21).js"></script><script async="" src="./_algorithm_ functions _ Microsoft Docs_files/t(22).js"></script><script async="" src="./_algorithm_ functions _ Microsoft Docs_files/t(23).js"></script><script async="" src="./_algorithm_ functions _ Microsoft Docs_files/t(24).js"></script><script async="" src="./_algorithm_ functions _ Microsoft Docs_files/t(25).js"></script><script async="" src="./_algorithm_ functions _ Microsoft Docs_files/t(26).js"></script><script async="" src="./_algorithm_ functions _ Microsoft Docs_files/t(27).js"></script><script async="" src="./_algorithm_ functions _ Microsoft Docs_files/t(28).js"></script><script async="" src="./_algorithm_ functions _ Microsoft Docs_files/t(29).js"></script><script async="" src="./_algorithm_ functions _ Microsoft Docs_files/t(30).js"></script><script async="" src="./_algorithm_ functions _ Microsoft Docs_files/t(31).js"></script><script async="" src="./_algorithm_ functions _ Microsoft Docs_files/t(32).js"></script><script async="" src="./_algorithm_ functions _ Microsoft Docs_files/t(33).js"></script><script async="" src="./_algorithm_ functions _ Microsoft Docs_files/t(34).js"></script><script async="" src="./_algorithm_ functions _ Microsoft Docs_files/t(35).js"></script><script async="" src="./_algorithm_ functions _ Microsoft Docs_files/t(36).js"></script><script async="" src="./_algorithm_ functions _ Microsoft Docs_files/t(37).js"></script><script async="" src="./_algorithm_ functions _ Microsoft Docs_files/t(38).js"></script><script async="" src="./_algorithm_ functions _ Microsoft Docs_files/t(39).js"></script><script async="" src="./_algorithm_ functions _ Microsoft Docs_files/t(40).js"></script><script async="" src="./_algorithm_ functions _ Microsoft Docs_files/t(41).js"></script><script async="" src="./_algorithm_ functions _ Microsoft Docs_files/t(42).js"></script><script async="" src="./_algorithm_ functions _ Microsoft Docs_files/t(43).js"></script><script async="" src="./_algorithm_ functions _ Microsoft Docs_files/t(44).js"></script><script async="" src="./_algorithm_ functions _ Microsoft Docs_files/t(45).js"></script><script async="" src="./_algorithm_ functions _ Microsoft Docs_files/t(46).js"></script><script async="" src="./_algorithm_ functions _ Microsoft Docs_files/t(47).js"></script><script async="" src="./_algorithm_ functions _ Microsoft Docs_files/t(48).js"></script><script async="" src="./_algorithm_ functions _ Microsoft Docs_files/t(49).js"></script><script async="" src="https://web.vortex.data.microsoft.com/collect/v1/t.js?ver=%272.1%27&amp;name=%27Ms.Webi.PageAction%27&amp;time=%272019-05-06T14%3A10%3A45.667Z%27&amp;os=%27MacOS%27&amp;appId=%27JS%3ADocs%27&amp;-ver=%271.0%27&amp;-impressionGuid=%278f17cbe1-ea29-4fad-9ec8-64a71a309130%27&amp;-pageName=%27ab2345d5-8891-8d5d-5a8c-b7b4382d4541%27&amp;-uri=%27https%3A%2F%2Fdocs.microsoft.com%2Fen-us%2Fcpp%2Fstandard-library%2Falgorithm-functions%23find_if%3Fview%3Dvs-2019%27&amp;-pageTags=%27%7B%22pgtrgtplf%22%3A%22%22%2C%22author%22%3A%22corob-msft%22%2C%22pgauth%22%3A%22corob%22%2C%22aud%22%3A%22developer%22%2C%22manager%22%3A%22wpickett%22%2C%22pgtop%22%3A%22reference%22%2C%22date%22%3A%2211%2F04%2F2016%22%2C%22technology%22%3A%22cpp-standard-libraries%22%2C%22workload%22%3A%22cplusplus%22%2C%22product%22%3A%22visual-cpp%22%2C%22asst%22%3A%22c10b0c65-410c-4c83-abf8-8b7f61bba8d0%22%2C%22depotname%22%3A%22VS.vcppdocs%22%2C%22publishtime%22%3A%222019-01-16%2006%3A44%20PM%22%2C%22gitcommit%22%3A%22https%3A%2F%2Fgithub.com%2FMicrosoftDocs%2Fcpp-docs-pr%2Fblob%2F8cb67dbbf19d8bb79d064c48dcf5ff412e918728%2Fdocs%2Fstandard-library%2Falgorithm-functions.md%22%2C%22giturl%22%3A%22https%3A%2F%2Fgithub.com%2FMicrosoftDocs%2Fcpp-docs-pr%2Fblob%2Flive%2Fdocs%2Fstandard-library%2Falgorithm-functions.md%22%2C%22document_version_independent_id%22%3A%2203684e91-dbcd-5acc-b86d-7099dac5b473%22%2C%22contentlocale%22%3A%22en-us%22%2C%22highContrast%22%3A%22false%22%2C%22metaTags%22%3A%7B%7D%7D%27&amp;-contentVer=%272.0%27&amp;-market=%27en-us%27&amp;-pageType=%27conceptual%27&amp;-actionType=%27O%27&amp;-behavior=300&amp;-content=%27%5B%7B%22event%22%3A%22page-focus-changed%22%2C%22value%22%3A%22focus%22%7D%5D%27&amp;*baseType=%27Ms.Content.PageAction%27&amp;*timeToAction=1592554&amp;*cookieEnabled=true&amp;*isJs=true&amp;*title=%27%3Calgorithm%3E%20functions%20%7C%20Microsoft%20Docs%27&amp;*isLoggedIn=false&amp;*isManual=true&amp;*referrerUri=%27https%3A%2F%2Fdocs.microsoft.com%2Fen-us%2Fcpp%2Fcpp%2Flambda-expression-syntax%3Fview%3Dvs-2019%27&amp;ext-javascript-ver=%271.1%27&amp;ext-javascript-libVer=%274.2.14%27&amp;ext-javascript-domain=%27docs.microsoft.com%27&amp;ext-javascript-msfpc=%27GUID%3Dfd683bbdc80946a59c8b5d21d168be76%26HASH%3Dfd68%26LV%3D201904%26V%3D4%26LU%3D1555267192230%27&amp;ext-javascript-userConsent=true&amp;ext-user-localId=%27t%3A29EDF7B04CBA6A671A40FCFB48BA69B6%27&amp;$mscomCookies=false"></script></head>

<body lang="en-us" dir="ltr" class="js-focus-visible">
<div class="header-holder">
		<div id="headerAreaHolder" data-bi-name="header">    <div id="headerArea" class="uhf" data-m="{&quot;cN&quot;:&quot;headerArea&quot;,&quot;cT&quot;:&quot;Area_coreuiArea&quot;,&quot;id&quot;:&quot;a1Body&quot;,&quot;sN&quot;:1,&quot;aN&quot;:&quot;Body&quot;}">
                <div id="headerRegion" data-region-key="headerregion" data-m="{&quot;cN&quot;:&quot;headerRegion&quot;,&quot;cT&quot;:&quot;Region_coreui-region&quot;,&quot;id&quot;:&quot;r1a1&quot;,&quot;sN&quot;:1,&quot;aN&quot;:&quot;a1&quot;}">

    <div id="headerUniversalHeader" data-m="{&quot;cN&quot;:&quot;headerUniversalHeader&quot;,&quot;cT&quot;:&quot;Module_coreui-universalheader&quot;,&quot;id&quot;:&quot;m1r1a1&quot;,&quot;sN&quot;:1,&quot;aN&quot;:&quot;r1a1&quot;}" data-module-id="Category|headerRegion|coreui-region|headerUniversalHeader|coreui-universalheader">
        





		<a id="uhfSkipToMain" class="m-skip-to-main" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#main" tabindex="0" style="z-index:3000002" data-m="{&quot;cN&quot;:&quot;Skip to content_nonnav&quot;,&quot;id&quot;:&quot;nn1m1r1a1&quot;,&quot;sN&quot;:1,&quot;aN&quot;:&quot;m1r1a1&quot;}">Skip to main content</a>


<header role="banner" class="c-uhfh context-uhf c-sgl-stck c-category-header f-transparent" itemscope="itemscope" data-header-footprint="/MSDocs/MSDocsHeader-DocsL1, fromService: True" data-magict="true" itemtype="http://schema.org/Organization">
	<div class="js-global-head f-closed global-head-cont theme-light" data-m="{&quot;cN&quot;:&quot;Universal Header_cont&quot;,&quot;cT&quot;:&quot;Container&quot;,&quot;id&quot;:&quot;c2m1r1a1&quot;,&quot;sN&quot;:2,&quot;aN&quot;:&quot;m1r1a1&quot;}">
		<div class="c-uhfh-gcontainer-st">
			<button type="button" class="c-action-trigger c-glyph glyph-global-nav-button" aria-label="All Microsoft expand to see list of Microsoft products and services" aria-expanded="false" data-m="{&quot;cN&quot;:&quot;Mobile menu button_nonnav&quot;,&quot;id&quot;:&quot;nn1c2m1r1a1&quot;,&quot;sN&quot;:1,&quot;aN&quot;:&quot;c2m1r1a1&quot;}"></button>
			<button type="button" class="c-action-trigger c-glyph glyph-arrow-htmllegacy" aria-label="Close search" aria-expanded="false" data-m="{&quot;cN&quot;:&quot;Close Search_nonnav&quot;,&quot;id&quot;:&quot;nn2c2m1r1a1&quot;,&quot;sN&quot;:2,&quot;aN&quot;:&quot;c2m1r1a1&quot;}"></button>
					<a id="uhfLogo" class="c-logo c-sgl-stk-uhfLogo" itemprop="url" href="https://www.microsoft.com/" aria-label="Microsoft" data-m="{&quot;cN&quot;:&quot;GlobalNav_Logo_cont&quot;,&quot;cT&quot;:&quot;Container&quot;,&quot;id&quot;:&quot;c3c2m1r1a1&quot;,&quot;sN&quot;:3,&quot;aN&quot;:&quot;c2m1r1a1&quot;}">
						<img alt="" itemprop="logo" itemscope="itemscope" class="c-image" src="./_algorithm_ functions _ Microsoft Docs_files/RE1Mu3b" role="presentation" aria-hidden="true">
						<span role="presentation" aria-hidden="true">Microsoft</span>
					</a>
			<div class="f-mobile-title">
				<button type="button" class="c-action-trigger c-glyph glyph-chevron-left" aria-label="See more menu options" data-m="{&quot;cN&quot;:&quot;Mobile back button_nonnav&quot;,&quot;id&quot;:&quot;nn4c2m1r1a1&quot;,&quot;sN&quot;:4,&quot;aN&quot;:&quot;c2m1r1a1&quot;}"></button>
				<span data-global-title="Microsoft home" class="js-mobile-title">Docs</span>
				<button type="button" class="c-action-trigger c-glyph glyph-chevron-right" aria-label="See more menu options" data-m="{&quot;cN&quot;:&quot;Mobile forward button_nonnav&quot;,&quot;id&quot;:&quot;nn5c2m1r1a1&quot;,&quot;sN&quot;:5,&quot;aN&quot;:&quot;c2m1r1a1&quot;}"></button>
			</div>
					<div class="c-show-pipe x-hidden-vp-mobile-st">
						<a id="uhfCatLogo" class="c-logo c-cat-logo" href="https://docs.microsoft.com/" aria-label="Docs" itemprop="url" data-m="{&quot;cN&quot;:&quot;CatNav_Docs_nav&quot;,&quot;id&quot;:&quot;n6c2m1r1a1&quot;,&quot;sN&quot;:6,&quot;aN&quot;:&quot;c2m1r1a1&quot;}">
								<span>Docs</span>
						</a>
					</div>
				<div class="cat-logo-button-cont x-hidden">
						<button type="button" id="uhfCatLogoButton" class="c-cat-logo-button x-hidden" aria-expanded="false" aria-label="Docs" data-m="{&quot;cN&quot;:&quot;Docs_nonnav&quot;,&quot;id&quot;:&quot;nn7c2m1r1a1&quot;,&quot;sN&quot;:7,&quot;aN&quot;:&quot;c2m1r1a1&quot;}">
							Docs
						</button>
				</div>



			        <nav id="uhf-g-nav" aria-label="Contextual menu" class="c-uhfh-gnav" data-m="{&quot;cN&quot;:&quot;Category nav_cont&quot;,&quot;cT&quot;:&quot;Container&quot;,&quot;id&quot;:&quot;c8c2m1r1a1&quot;,&quot;sN&quot;:8,&quot;aN&quot;:&quot;c2m1r1a1&quot;}">
            <ul class="js-paddle-items">
                    <li class="single-link js-nav-menu x-hidden-none-mobile-vp uhf-menu-item">
                        <a class="c-uhf-nav-link" href="https://docs.microsoft.com/" data-m="{&quot;cN&quot;:&quot;CatNav_Home_nav&quot;,&quot;id&quot;:&quot;n1c8c2m1r1a1&quot;,&quot;sN&quot;:1,&quot;aN&quot;:&quot;c8c2m1r1a1&quot;}"> Home </a>
                    </li>
                                        <li class="single-link js-nav-menu uhf-menu-item">
                            <a id="c-shellmenu_0" class="c-uhf-nav-link" href="https://docs.microsoft.com/windows" data-m="{&quot;cN&quot;:&quot;CatNav_docsWindows_nav&quot;,&quot;id&quot;:&quot;n2c8c2m1r1a1&quot;,&quot;sN&quot;:2,&quot;aN&quot;:&quot;c8c2m1r1a1&quot;}">Windows</a>
                        </li>
                        <li class="single-link js-nav-menu uhf-menu-item">
                            <a id="c-shellmenu_1" class="c-uhf-nav-link" href="https://docs.microsoft.com/azure/" data-m="{&quot;cN&quot;:&quot;CatNav_docsAzure_nav&quot;,&quot;id&quot;:&quot;n3c8c2m1r1a1&quot;,&quot;sN&quot;:3,&quot;aN&quot;:&quot;c8c2m1r1a1&quot;}">Microsoft Azure</a>
                        </li>
                        <li class="single-link js-nav-menu uhf-menu-item">
                            <a id="c-shellmenu_2" class="c-uhf-nav-link" href="https://docs.microsoft.com/visualstudio/products" data-m="{&quot;cN&quot;:&quot;CatNav_docsVisualStudio_nav&quot;,&quot;id&quot;:&quot;n4c8c2m1r1a1&quot;,&quot;sN&quot;:4,&quot;aN&quot;:&quot;c8c2m1r1a1&quot;}">Visual Studio</a>
                        </li>
                        <li class="single-link js-nav-menu uhf-menu-item">
                            <a id="c-shellmenu_3" class="c-uhf-nav-link" href="https://docs.microsoft.com/office/" data-m="{&quot;cN&quot;:&quot;CatNav_docsOffice_nav&quot;,&quot;id&quot;:&quot;n5c8c2m1r1a1&quot;,&quot;sN&quot;:5,&quot;aN&quot;:&quot;c8c2m1r1a1&quot;}">Office</a>
                        </li>
                        <li class="nested-menu uhf-menu-item">
                            <div class="c-uhf-menu js-nav-menu">
                                <button type="button" id="c-shellmenu_4" aria-expanded="false" data-m="{&quot;cN&quot;:&quot;CatNav_docsMore_nonnav&quot;,&quot;id&quot;:&quot;nn6c8c2m1r1a1&quot;,&quot;sN&quot;:6,&quot;aN&quot;:&quot;c8c2m1r1a1&quot;}" style="white-space:nowrap">More</button>

                                <ul class="" data-class-idn="" aria-hidden="true" data-m="{&quot;cN&quot;:&quot;docsMore_cont&quot;,&quot;cT&quot;:&quot;Container&quot;,&quot;id&quot;:&quot;c7c8c2m1r1a1&quot;,&quot;sN&quot;:7,&quot;aN&quot;:&quot;c8c2m1r1a1&quot;}">
        <li class="js-nav-menu single-link" data-m="{&quot;cN&quot;:&quot;docsNET_cont&quot;,&quot;cT&quot;:&quot;Container&quot;,&quot;id&quot;:&quot;c1c7c8c2m1r1a1&quot;,&quot;sN&quot;:1,&quot;aN&quot;:&quot;c7c8c2m1r1a1&quot;}">
            <a id="c-shellmenu_5" class="js-subm-uhf-nav-link" href="https://docs.microsoft.com/dotnet/" data-m="{&quot;cN&quot;:&quot;CatNav_docsNET_nav&quot;,&quot;id&quot;:&quot;n1c1c7c8c2m1r1a1&quot;,&quot;sN&quot;:1,&quot;aN&quot;:&quot;c1c7c8c2m1r1a1&quot;}">.NET</a>
            
        </li>
        <li class="js-nav-menu single-link" data-m="{&quot;cN&quot;:&quot;docsASPNET_cont&quot;,&quot;cT&quot;:&quot;Container&quot;,&quot;id&quot;:&quot;c2c7c8c2m1r1a1&quot;,&quot;sN&quot;:2,&quot;aN&quot;:&quot;c7c8c2m1r1a1&quot;}">
            <a id="c-shellmenu_6" class="js-subm-uhf-nav-link" href="https://docs.microsoft.com/aspnet/" data-m="{&quot;cN&quot;:&quot;CatNav_docsASPNET_nav&quot;,&quot;id&quot;:&quot;n1c2c7c8c2m1r1a1&quot;,&quot;sN&quot;:1,&quot;aN&quot;:&quot;c2c7c8c2m1r1a1&quot;}">ASP.NET</a>
            
        </li>
        <li class="js-nav-menu single-link" data-m="{&quot;cN&quot;:&quot;docsCpp_cont&quot;,&quot;cT&quot;:&quot;Container&quot;,&quot;id&quot;:&quot;c3c7c8c2m1r1a1&quot;,&quot;sN&quot;:3,&quot;aN&quot;:&quot;c7c8c2m1r1a1&quot;}">
            <a id="c-shellmenu_7" class="js-subm-uhf-nav-link" href="https://docs.microsoft.com/cpp/" data-m="{&quot;cN&quot;:&quot;CatNav_docsCpp_nav&quot;,&quot;id&quot;:&quot;n1c3c7c8c2m1r1a1&quot;,&quot;sN&quot;:1,&quot;aN&quot;:&quot;c3c7c8c2m1r1a1&quot;}">C++</a>
            
        </li>
        <li class="js-nav-menu single-link" data-m="{&quot;cN&quot;:&quot;docsDynamics_cont&quot;,&quot;cT&quot;:&quot;Container&quot;,&quot;id&quot;:&quot;c4c7c8c2m1r1a1&quot;,&quot;sN&quot;:4,&quot;aN&quot;:&quot;c7c8c2m1r1a1&quot;}">
            <a id="c-shellmenu_8" class="js-subm-uhf-nav-link" href="https://docs.microsoft.com/dynamics365/" data-m="{&quot;cN&quot;:&quot;CatNav_docsDynamics_nav&quot;,&quot;id&quot;:&quot;n1c4c7c8c2m1r1a1&quot;,&quot;sN&quot;:1,&quot;aN&quot;:&quot;c4c7c8c2m1r1a1&quot;}">Dynamics 365</a>
            
        </li>
        <li class="js-nav-menu single-link" data-m="{&quot;cN&quot;:&quot;docsEducation_cont&quot;,&quot;cT&quot;:&quot;Container&quot;,&quot;id&quot;:&quot;c5c7c8c2m1r1a1&quot;,&quot;sN&quot;:5,&quot;aN&quot;:&quot;c7c8c2m1r1a1&quot;}">
            <a id="c-shellmenu_9" class="js-subm-uhf-nav-link" href="https://docs.microsoft.com/education/" data-m="{&quot;cN&quot;:&quot;CatNav_docsEducation_nav&quot;,&quot;id&quot;:&quot;n1c5c7c8c2m1r1a1&quot;,&quot;sN&quot;:1,&quot;aN&quot;:&quot;c5c7c8c2m1r1a1&quot;}">Education</a>
            
        </li>
        <li class="js-nav-menu single-link" data-m="{&quot;cN&quot;:&quot;docsEM_cont&quot;,&quot;cT&quot;:&quot;Container&quot;,&quot;id&quot;:&quot;c6c7c8c2m1r1a1&quot;,&quot;sN&quot;:6,&quot;aN&quot;:&quot;c7c8c2m1r1a1&quot;}">
            <a id="c-shellmenu_10" class="js-subm-uhf-nav-link" href="https://docs.microsoft.com/enterprise-mobility-security/" data-m="{&quot;cN&quot;:&quot;CatNav_docsEM_nav&quot;,&quot;id&quot;:&quot;n1c6c7c8c2m1r1a1&quot;,&quot;sN&quot;:1,&quot;aN&quot;:&quot;c6c7c8c2m1r1a1&quot;}">Enterprise Mobility + Security</a>
            
        </li>
        <li class="js-nav-menu single-link" data-m="{&quot;cN&quot;:&quot;docsHealthVault_cont&quot;,&quot;cT&quot;:&quot;Container&quot;,&quot;id&quot;:&quot;c7c7c8c2m1r1a1&quot;,&quot;sN&quot;:7,&quot;aN&quot;:&quot;c7c8c2m1r1a1&quot;}">
            <a id="c-shellmenu_11" class="js-subm-uhf-nav-link" href="https://docs.microsoft.com/healthvault/" data-m="{&quot;cN&quot;:&quot;CatNav_docsHealthVault_nav&quot;,&quot;id&quot;:&quot;n1c7c7c8c2m1r1a1&quot;,&quot;sN&quot;:1,&quot;aN&quot;:&quot;c7c7c8c2m1r1a1&quot;}">HealthVault</a>
            
        </li>
        <li class="js-nav-menu single-link" data-m="{&quot;cN&quot;:&quot;docsIntune_cont&quot;,&quot;cT&quot;:&quot;Container&quot;,&quot;id&quot;:&quot;c8c7c8c2m1r1a1&quot;,&quot;sN&quot;:8,&quot;aN&quot;:&quot;c7c8c2m1r1a1&quot;}">
            <a id="c-shellmenu_12" class="js-subm-uhf-nav-link" href="https://docs.microsoft.com/intune/" data-m="{&quot;cN&quot;:&quot;CatNav_docsIntune_nav&quot;,&quot;id&quot;:&quot;n1c8c7c8c2m1r1a1&quot;,&quot;sN&quot;:1,&quot;aN&quot;:&quot;c8c7c8c2m1r1a1&quot;}">Intune</a>
            
        </li>
        <li class="js-nav-menu single-link" data-m="{&quot;cN&quot;:&quot;docsNuget_cont&quot;,&quot;cT&quot;:&quot;Container&quot;,&quot;id&quot;:&quot;c9c7c8c2m1r1a1&quot;,&quot;sN&quot;:9,&quot;aN&quot;:&quot;c7c8c2m1r1a1&quot;}">
            <a id="c-shellmenu_13" class="js-subm-uhf-nav-link" href="https://docs.microsoft.com/nuget/" data-m="{&quot;cN&quot;:&quot;CatNav_docsNuget_nav&quot;,&quot;id&quot;:&quot;n1c9c7c8c2m1r1a1&quot;,&quot;sN&quot;:1,&quot;aN&quot;:&quot;c9c7c8c2m1r1a1&quot;}">NuGet</a>
            
        </li>
        <li class="js-nav-menu single-link" data-m="{&quot;cN&quot;:&quot;docsPowerShell_cont&quot;,&quot;cT&quot;:&quot;Container&quot;,&quot;id&quot;:&quot;c10c7c8c2m1r1a1&quot;,&quot;sN&quot;:10,&quot;aN&quot;:&quot;c7c8c2m1r1a1&quot;}">
            <a id="c-shellmenu_14" class="js-subm-uhf-nav-link" href="https://docs.microsoft.com/powershell/" data-m="{&quot;cN&quot;:&quot;CatNav_docsPowerShell_nav&quot;,&quot;id&quot;:&quot;n1c10c7c8c2m1r1a1&quot;,&quot;sN&quot;:1,&quot;aN&quot;:&quot;c10c7c8c2m1r1a1&quot;}">PowerShell</a>
            
        </li>
        <li class="js-nav-menu single-link" data-m="{&quot;cN&quot;:&quot;docsSCCM_cont&quot;,&quot;cT&quot;:&quot;Container&quot;,&quot;id&quot;:&quot;c11c7c8c2m1r1a1&quot;,&quot;sN&quot;:11,&quot;aN&quot;:&quot;c7c8c2m1r1a1&quot;}">
            <a id="c-shellmenu_15" class="js-subm-uhf-nav-link" href="https://docs.microsoft.com/sccm/" data-m="{&quot;cN&quot;:&quot;CatNav_docsSCCM_nav&quot;,&quot;id&quot;:&quot;n1c11c7c8c2m1r1a1&quot;,&quot;sN&quot;:1,&quot;aN&quot;:&quot;c11c7c8c2m1r1a1&quot;}">System Center Configuration Manager</a>
            
        </li>
        <li class="js-nav-menu single-link" data-m="{&quot;cN&quot;:&quot;docsSql_cont&quot;,&quot;cT&quot;:&quot;Container&quot;,&quot;id&quot;:&quot;c12c7c8c2m1r1a1&quot;,&quot;sN&quot;:12,&quot;aN&quot;:&quot;c7c8c2m1r1a1&quot;}">
            <a id="c-shellmenu_16" class="js-subm-uhf-nav-link" href="https://docs.microsoft.com/sql/" data-m="{&quot;cN&quot;:&quot;CatNav_docsSql_nav&quot;,&quot;id&quot;:&quot;n1c12c7c8c2m1r1a1&quot;,&quot;sN&quot;:1,&quot;aN&quot;:&quot;c12c7c8c2m1r1a1&quot;}">SQL Server</a>
            
        </li>
        <li class="js-nav-menu single-link" data-m="{&quot;cN&quot;:&quot;docsSystemCenter_cont&quot;,&quot;cT&quot;:&quot;Container&quot;,&quot;id&quot;:&quot;c13c7c8c2m1r1a1&quot;,&quot;sN&quot;:13,&quot;aN&quot;:&quot;c7c8c2m1r1a1&quot;}">
            <a id="c-shellmenu_17" class="js-subm-uhf-nav-link" href="https://docs.microsoft.com/system-center/" data-m="{&quot;cN&quot;:&quot;CatNav_docsSystemCenter_nav&quot;,&quot;id&quot;:&quot;n1c13c7c8c2m1r1a1&quot;,&quot;sN&quot;:1,&quot;aN&quot;:&quot;c13c7c8c2m1r1a1&quot;}">System Center</a>
            
        </li>
        <li class="js-nav-menu single-link" data-m="{&quot;cN&quot;:&quot;docsXamarin_cont&quot;,&quot;cT&quot;:&quot;Container&quot;,&quot;id&quot;:&quot;c14c7c8c2m1r1a1&quot;,&quot;sN&quot;:14,&quot;aN&quot;:&quot;c7c8c2m1r1a1&quot;}">
            <a id="c-shellmenu_18" class="js-subm-uhf-nav-link" href="https://developer.xamarin.com/" data-m="{&quot;cN&quot;:&quot;CatNav_docsXamarin_nav&quot;,&quot;id&quot;:&quot;n1c14c7c8c2m1r1a1&quot;,&quot;sN&quot;:1,&quot;aN&quot;:&quot;c14c7c8c2m1r1a1&quot;}">Xamarin</a>
            
        </li>
                                                    
                                </ul>
                            </div>
                        </li>

                <li id="overflow-menu" class="overflow-menu x-hidden uhf-menu-item">
                        <div class="c-uhf-menu js-nav-menu">
        <button data-m="{&quot;pid&quot;:&quot;More&quot;,&quot;id&quot;:&quot;nn8c8c2m1r1a1&quot;,&quot;sN&quot;:8,&quot;aN&quot;:&quot;c8c2m1r1a1&quot;}" type="button" aria-label="More" aria-expanded="false" style="white-space:nowrap">More</button>
        <ul id="overflow-menu-list" aria-hidden="true" class="overflow-menu-list">
        </ul>
    </div>

                </li>
                            </ul>
            
        </nav>


			<div class="c-uhfh-actions" data-m="{&quot;cN&quot;:&quot;Header actions_cont&quot;,&quot;cT&quot;:&quot;Container&quot;,&quot;id&quot;:&quot;c9c2m1r1a1&quot;,&quot;sN&quot;:9,&quot;aN&quot;:&quot;c2m1r1a1&quot;}">
				<div class="wf-menu">        <nav id="uhf-c-nav" aria-label="All microsoft menu" data-m="{&quot;cN&quot;:&quot;GlobalNav_cont&quot;,&quot;cT&quot;:&quot;Container&quot;,&quot;id&quot;:&quot;c1c9c2m1r1a1&quot;,&quot;sN&quot;:1,&quot;aN&quot;:&quot;c9c2m1r1a1&quot;}">
            <ul class="js-paddle-items">
                <li>
                    <div class="c-uhf-menu js-nav-menu">
                        <button type="button" class="c-button-logo all-ms-nav" aria-label="All Microsoft expand to see list of Microsoft products and services" aria-expanded="false" data-m="{&quot;cN&quot;:&quot;GlobalNav_More_nonnav&quot;,&quot;id&quot;:&quot;nn1c1c9c2m1r1a1&quot;,&quot;sN&quot;:1,&quot;aN&quot;:&quot;c1c9c2m1r1a1&quot;}" style="white-space: nowrap"> <span>All Microsoft</span></button>
                        <ul class="f-multi-column f-multi-column-6" aria-hidden="true" data-m="{&quot;cN&quot;:&quot;More_cont&quot;,&quot;cT&quot;:&quot;Container&quot;,&quot;id&quot;:&quot;c2c1c9c2m1r1a1&quot;,&quot;sN&quot;:2,&quot;aN&quot;:&quot;c1c9c2m1r1a1&quot;}">
                                    <li class="c-w0-contr">
            <ul class="c-w0">
        <li class="js-nav-menu single-link" data-m="{&quot;cN&quot;:&quot;Office_cont&quot;,&quot;cT&quot;:&quot;Container&quot;,&quot;id&quot;:&quot;c1c2c1c9c2m1r1a1&quot;,&quot;sN&quot;:1,&quot;aN&quot;:&quot;c2c1c9c2m1r1a1&quot;}">
            <a id="shellmenu_19" class="js-subm-uhf-nav-link" href="https://products.office.com/en-us/home" data-m="{&quot;cN&quot;:&quot;W0Nav_Office_nav&quot;,&quot;id&quot;:&quot;n1c1c2c1c9c2m1r1a1&quot;,&quot;sN&quot;:1,&quot;aN&quot;:&quot;c1c2c1c9c2m1r1a1&quot;}">Office</a>
            
        </li>
        <li class="js-nav-menu single-link" data-m="{&quot;cN&quot;:&quot;Windows_cont&quot;,&quot;cT&quot;:&quot;Container&quot;,&quot;id&quot;:&quot;c2c2c1c9c2m1r1a1&quot;,&quot;sN&quot;:2,&quot;aN&quot;:&quot;c2c1c9c2m1r1a1&quot;}">
            <a id="shellmenu_20" class="js-subm-uhf-nav-link" href="https://www.microsoft.com/en-us/windows/" data-m="{&quot;cN&quot;:&quot;W0Nav_Windows_nav&quot;,&quot;id&quot;:&quot;n1c2c2c1c9c2m1r1a1&quot;,&quot;sN&quot;:1,&quot;aN&quot;:&quot;c2c2c1c9c2m1r1a1&quot;}">Windows</a>
            
        </li>
        <li class="js-nav-menu single-link" data-m="{&quot;cN&quot;:&quot;Surface_cont&quot;,&quot;cT&quot;:&quot;Container&quot;,&quot;id&quot;:&quot;c3c2c1c9c2m1r1a1&quot;,&quot;sN&quot;:3,&quot;aN&quot;:&quot;c2c1c9c2m1r1a1&quot;}">
            <a id="shellmenu_21" class="js-subm-uhf-nav-link" href="https://www.microsoft.com/en-us/surface" data-m="{&quot;cN&quot;:&quot;W0Nav_Surface_nav&quot;,&quot;id&quot;:&quot;n1c3c2c1c9c2m1r1a1&quot;,&quot;sN&quot;:1,&quot;aN&quot;:&quot;c3c2c1c9c2m1r1a1&quot;}">Surface</a>
            
        </li>
        <li class="js-nav-menu single-link" data-m="{&quot;cN&quot;:&quot;Xbox_cont&quot;,&quot;cT&quot;:&quot;Container&quot;,&quot;id&quot;:&quot;c4c2c1c9c2m1r1a1&quot;,&quot;sN&quot;:4,&quot;aN&quot;:&quot;c2c1c9c2m1r1a1&quot;}">
            <a id="shellmenu_22" class="js-subm-uhf-nav-link" href="https://www.xbox.com/" data-m="{&quot;cN&quot;:&quot;W0Nav_Xbox_nav&quot;,&quot;id&quot;:&quot;n1c4c2c1c9c2m1r1a1&quot;,&quot;sN&quot;:1,&quot;aN&quot;:&quot;c4c2c1c9c2m1r1a1&quot;}">Xbox</a>
            
        </li>
        <li class="js-nav-menu single-link" data-m="{&quot;cN&quot;:&quot;Deals_cont&quot;,&quot;cT&quot;:&quot;Container&quot;,&quot;id&quot;:&quot;c5c2c1c9c2m1r1a1&quot;,&quot;sN&quot;:5,&quot;aN&quot;:&quot;c2c1c9c2m1r1a1&quot;}">
            <a id="shellmenu_23" class="js-subm-uhf-nav-link" href="https://www.microsoft.com/en-us/store/b/sale?icid=gm_nav_L0_salepage" data-m="{&quot;cN&quot;:&quot;W0Nav_Deals_nav&quot;,&quot;id&quot;:&quot;n1c5c2c1c9c2m1r1a1&quot;,&quot;sN&quot;:1,&quot;aN&quot;:&quot;c5c2c1c9c2m1r1a1&quot;}">Deals</a>
            
        </li>
        <li class="js-nav-menu single-link" data-m="{&quot;cN&quot;:&quot;Support_cont&quot;,&quot;cT&quot;:&quot;Container&quot;,&quot;id&quot;:&quot;c6c2c1c9c2m1r1a1&quot;,&quot;sN&quot;:6,&quot;aN&quot;:&quot;c2c1c9c2m1r1a1&quot;}">
            <a id="l1_support" class="js-subm-uhf-nav-link" href="https://support.microsoft.com/en-us" data-m="{&quot;cN&quot;:&quot;W0Nav_Support_nav&quot;,&quot;id&quot;:&quot;n1c6c2c1c9c2m1r1a1&quot;,&quot;sN&quot;:1,&quot;aN&quot;:&quot;c6c2c1c9c2m1r1a1&quot;}">Support</a>
            
        </li>
            </ul>
        </li>

        <li class="f-sub-menu js-nav-menu nested-menu" data-m="{&quot;cT&quot;:&quot;Container&quot;,&quot;id&quot;:&quot;c7c2c1c9c2m1r1a1&quot;,&quot;sN&quot;:7,&quot;aN&quot;:&quot;c2c1c9c2m1r1a1&quot;}">

            <button type="button" role="presentation" f-multi-parent="true" aria-expanded="false" data-m="{&quot;id&quot;:&quot;nn1c7c2c1c9c2m1r1a1&quot;,&quot;sN&quot;:1,&quot;aN&quot;:&quot;c7c2c1c9c2m1r1a1&quot;}">Software</button>
            <ul aria-hidden="true" role="presentation">
        <li class="js-nav-menu single-link" data-m="{&quot;cN&quot;:&quot;More_Software_WindowsApps_cont&quot;,&quot;cT&quot;:&quot;Container&quot;,&quot;id&quot;:&quot;c2c7c2c1c9c2m1r1a1&quot;,&quot;sN&quot;:2,&quot;aN&quot;:&quot;c7c2c1c9c2m1r1a1&quot;}">
            <a id="shellmenu_27" class="js-subm-uhf-nav-link" href="https://www.microsoft.com/en-us/windows/windows-10-apps" data-m="{&quot;cN&quot;:&quot;GlobalNav_More_Software_WindowsApps_nav&quot;,&quot;id&quot;:&quot;n1c2c7c2c1c9c2m1r1a1&quot;,&quot;sN&quot;:1,&quot;aN&quot;:&quot;c2c7c2c1c9c2m1r1a1&quot;}">Windows apps</a>
            
        </li>
        <li class="js-nav-menu single-link" data-m="{&quot;cN&quot;:&quot;More_Software_OneDrive_cont&quot;,&quot;cT&quot;:&quot;Container&quot;,&quot;id&quot;:&quot;c3c7c2c1c9c2m1r1a1&quot;,&quot;sN&quot;:3,&quot;aN&quot;:&quot;c7c2c1c9c2m1r1a1&quot;}">
            <a id="shellmenu_28" class="js-subm-uhf-nav-link" href="https://onedrive.live.com/about/en-us/" data-m="{&quot;cN&quot;:&quot;GlobalNav_More_Software_OneDrive_nav&quot;,&quot;id&quot;:&quot;n1c3c7c2c1c9c2m1r1a1&quot;,&quot;sN&quot;:1,&quot;aN&quot;:&quot;c3c7c2c1c9c2m1r1a1&quot;}">OneDrive</a>
            
        </li>
        <li class="js-nav-menu single-link" data-m="{&quot;cN&quot;:&quot;More_Software_Outlook_cont&quot;,&quot;cT&quot;:&quot;Container&quot;,&quot;id&quot;:&quot;c4c7c2c1c9c2m1r1a1&quot;,&quot;sN&quot;:4,&quot;aN&quot;:&quot;c7c2c1c9c2m1r1a1&quot;}">
            <a id="shellmenu_29" class="js-subm-uhf-nav-link" href="https://outlook.live.com/owa/" data-m="{&quot;cN&quot;:&quot;GlobalNav_More_Software_Outlook_nav&quot;,&quot;id&quot;:&quot;n1c4c7c2c1c9c2m1r1a1&quot;,&quot;sN&quot;:1,&quot;aN&quot;:&quot;c4c7c2c1c9c2m1r1a1&quot;}">Outlook</a>
            
        </li>
        <li class="js-nav-menu single-link" data-m="{&quot;cN&quot;:&quot;More_Software_Skype_cont&quot;,&quot;cT&quot;:&quot;Container&quot;,&quot;id&quot;:&quot;c5c7c2c1c9c2m1r1a1&quot;,&quot;sN&quot;:5,&quot;aN&quot;:&quot;c7c2c1c9c2m1r1a1&quot;}">
            <a id="shellmenu_30" class="js-subm-uhf-nav-link" href="https://www.skype.com/en/" data-m="{&quot;cN&quot;:&quot;GlobalNav_More_Software_Skype_nav&quot;,&quot;id&quot;:&quot;n1c5c7c2c1c9c2m1r1a1&quot;,&quot;sN&quot;:1,&quot;aN&quot;:&quot;c5c7c2c1c9c2m1r1a1&quot;}">Skype</a>
            
        </li>
        <li class="js-nav-menu single-link" data-m="{&quot;cN&quot;:&quot;More_Software_OneNote_cont&quot;,&quot;cT&quot;:&quot;Container&quot;,&quot;id&quot;:&quot;c6c7c2c1c9c2m1r1a1&quot;,&quot;sN&quot;:6,&quot;aN&quot;:&quot;c7c2c1c9c2m1r1a1&quot;}">
            <a id="shellmenu_31" class="js-subm-uhf-nav-link" href="https://www.onenote.com/" data-m="{&quot;cN&quot;:&quot;GlobalNav_More_Software_OneNote_nav&quot;,&quot;id&quot;:&quot;n1c6c7c2c1c9c2m1r1a1&quot;,&quot;sN&quot;:1,&quot;aN&quot;:&quot;c6c7c2c1c9c2m1r1a1&quot;}">OneNote</a>
            
        </li>
            </ul>
            
        </li>
        <li class="f-sub-menu js-nav-menu nested-menu" data-m="{&quot;cN&quot;:&quot;PCsAndDevices_cont&quot;,&quot;cT&quot;:&quot;Container&quot;,&quot;id&quot;:&quot;c8c2c1c9c2m1r1a1&quot;,&quot;sN&quot;:8,&quot;aN&quot;:&quot;c2c1c9c2m1r1a1&quot;}">

            <button type="button" role="presentation" f-multi-parent="true" aria-expanded="false" data-m="{&quot;cN&quot;:&quot;GlobalNav_PCsAndDevices_nonnav&quot;,&quot;id&quot;:&quot;nn1c8c2c1c9c2m1r1a1&quot;,&quot;sN&quot;:1,&quot;aN&quot;:&quot;c8c2c1c9c2m1r1a1&quot;}">PCs &amp; Devices  </button>
            <ul aria-hidden="true" role="presentation">
        <li class="js-nav-menu single-link" data-m="{&quot;cN&quot;:&quot;More_PCsAndDevices_PCsAndTablets_cont&quot;,&quot;cT&quot;:&quot;Container&quot;,&quot;id&quot;:&quot;c2c8c2c1c9c2m1r1a1&quot;,&quot;sN&quot;:2,&quot;aN&quot;:&quot;c8c2c1c9c2m1r1a1&quot;}">
            <a id="shellmenu_33" class="js-subm-uhf-nav-link" href="https://www.microsoft.com/en-us/windows/devices" data-m="{&quot;cN&quot;:&quot;GlobalNav_More_PCsAndDevices_PCsAndTablets_nav&quot;,&quot;id&quot;:&quot;n1c2c8c2c1c9c2m1r1a1&quot;,&quot;sN&quot;:1,&quot;aN&quot;:&quot;c2c8c2c1c9c2m1r1a1&quot;}">PCs &amp; tablets</a>
            
        </li>
        <li class="js-nav-menu single-link" data-m="{&quot;cN&quot;:&quot;More_PCAndDevices_Accessories_cont&quot;,&quot;cT&quot;:&quot;Container&quot;,&quot;id&quot;:&quot;c3c8c2c1c9c2m1r1a1&quot;,&quot;sN&quot;:3,&quot;aN&quot;:&quot;c8c2c1c9c2m1r1a1&quot;}">
            <a id="shellmenu_34" class="js-subm-uhf-nav-link" href="https://www.microsoft.com/accessories/en-us" data-m="{&quot;cN&quot;:&quot;GlobalNav_More_PCAndDevices_Accessories_nav&quot;,&quot;id&quot;:&quot;n1c3c8c2c1c9c2m1r1a1&quot;,&quot;sN&quot;:1,&quot;aN&quot;:&quot;c3c8c2c1c9c2m1r1a1&quot;}">Accessories</a>
            
        </li>
            </ul>
            
        </li>
        <li class="f-sub-menu js-nav-menu nested-menu" data-m="{&quot;cT&quot;:&quot;Container&quot;,&quot;id&quot;:&quot;c9c2c1c9c2m1r1a1&quot;,&quot;sN&quot;:9,&quot;aN&quot;:&quot;c2c1c9c2m1r1a1&quot;}">

            <button type="button" role="presentation" f-multi-parent="true" aria-expanded="false" data-m="{&quot;id&quot;:&quot;nn1c9c2c1c9c2m1r1a1&quot;,&quot;sN&quot;:1,&quot;aN&quot;:&quot;c9c2c1c9c2m1r1a1&quot;}">Entertainment</button>
            <ul aria-hidden="true" role="presentation">
        <li class="js-nav-menu single-link" data-m="{&quot;cN&quot;:&quot;Products_DevicesAndXbox_XboxAndGames_cont&quot;,&quot;cT&quot;:&quot;Container&quot;,&quot;id&quot;:&quot;c2c9c2c1c9c2m1r1a1&quot;,&quot;sN&quot;:2,&quot;aN&quot;:&quot;c9c2c1c9c2m1r1a1&quot;}">
            <a id="shellmenu_36" class="js-subm-uhf-nav-link" href="https://www.xbox.com/en-us/games/xbox-one?xr=shellnav" data-m="{&quot;cN&quot;:&quot;GlobalNav_Products_DevicesAndXbox_XboxAndGames_nav&quot;,&quot;id&quot;:&quot;n1c2c9c2c1c9c2m1r1a1&quot;,&quot;sN&quot;:1,&quot;aN&quot;:&quot;c2c9c2c1c9c2m1r1a1&quot;}">Xbox games</a>
            
        </li>
        <li class="js-nav-menu single-link" data-m="{&quot;cN&quot;:&quot;Entertainment_PCGames_cont&quot;,&quot;cT&quot;:&quot;Container&quot;,&quot;id&quot;:&quot;c3c9c2c1c9c2m1r1a1&quot;,&quot;sN&quot;:3,&quot;aN&quot;:&quot;c9c2c1c9c2m1r1a1&quot;}">
            <a id="shellmenu_37" class="js-subm-uhf-nav-link" href="https://www.microsoft.com/en-us/windows/windows-10-games" data-m="{&quot;cN&quot;:&quot;GlobalNav_Entertainment_PCGames_nav&quot;,&quot;id&quot;:&quot;n1c3c9c2c1c9c2m1r1a1&quot;,&quot;sN&quot;:1,&quot;aN&quot;:&quot;c3c9c2c1c9c2m1r1a1&quot;}">PC games</a>
            
        </li>
        <li class="js-nav-menu single-link" data-m="{&quot;cN&quot;:&quot;More_Entertainment_WindowsDigitalGames_cont&quot;,&quot;cT&quot;:&quot;Container&quot;,&quot;id&quot;:&quot;c4c9c2c1c9c2m1r1a1&quot;,&quot;sN&quot;:4,&quot;aN&quot;:&quot;c9c2c1c9c2m1r1a1&quot;}">
            <a id="shellmenu_38" class="js-subm-uhf-nav-link" href="https://www.microsoft.com/en-us/store/games/windows?icid=TopNavWindowsGames" data-m="{&quot;cN&quot;:&quot;GlobalNav_More_Entertainment_WindowsDigitalGames_nav&quot;,&quot;id&quot;:&quot;n1c4c9c2c1c9c2m1r1a1&quot;,&quot;sN&quot;:1,&quot;aN&quot;:&quot;c4c9c2c1c9c2m1r1a1&quot;}">Windows digital games</a>
            
        </li>
        <li class="js-nav-menu single-link" data-m="{&quot;cN&quot;:&quot;More_Entertainment_MoviesAndTV_cont&quot;,&quot;cT&quot;:&quot;Container&quot;,&quot;id&quot;:&quot;c5c9c2c1c9c2m1r1a1&quot;,&quot;sN&quot;:5,&quot;aN&quot;:&quot;c9c2c1c9c2m1r1a1&quot;}">
            <a id="shellmenu_39" class="js-subm-uhf-nav-link" href="https://www.microsoft.com/en-us/store/movies-and-tv?icid=TopNavMoviesAndTv" data-m="{&quot;cN&quot;:&quot;GlobalNav_More_Entertainment_MoviesAndTV_nav&quot;,&quot;id&quot;:&quot;n1c5c9c2c1c9c2m1r1a1&quot;,&quot;sN&quot;:1,&quot;aN&quot;:&quot;c5c9c2c1c9c2m1r1a1&quot;}">Movies &amp; TV</a>
            
        </li>
        <li class="js-nav-menu single-link" data-m="{&quot;cN&quot;:&quot;More_Entertainment_Books_cont&quot;,&quot;cT&quot;:&quot;Container&quot;,&quot;id&quot;:&quot;c6c9c2c1c9c2m1r1a1&quot;,&quot;sN&quot;:6,&quot;aN&quot;:&quot;c9c2c1c9c2m1r1a1&quot;}">
            <a id="shellmenu_40" class="js-subm-uhf-nav-link" href="https://www.microsoft.com/en-us/store/books" data-m="{&quot;cN&quot;:&quot;GlobalNav_More_Entertainment_Books_nav&quot;,&quot;id&quot;:&quot;n1c6c9c2c1c9c2m1r1a1&quot;,&quot;sN&quot;:1,&quot;aN&quot;:&quot;c6c9c2c1c9c2m1r1a1&quot;}">Books</a>
            
        </li>
            </ul>
            
        </li>
        <li class="f-sub-menu js-nav-menu nested-menu" data-m="{&quot;cT&quot;:&quot;Container&quot;,&quot;id&quot;:&quot;c10c2c1c9c2m1r1a1&quot;,&quot;sN&quot;:10,&quot;aN&quot;:&quot;c2c1c9c2m1r1a1&quot;}">

            <button type="button" role="presentation" f-multi-parent="true" aria-expanded="false" data-m="{&quot;id&quot;:&quot;nn1c10c2c1c9c2m1r1a1&quot;,&quot;sN&quot;:1,&quot;aN&quot;:&quot;c10c2c1c9c2m1r1a1&quot;}">Business</button>
            <ul aria-hidden="true" role="presentation">
        <li class="js-nav-menu single-link" data-m="{&quot;cN&quot;:&quot;More_Business_MicrosoftAzure_cont&quot;,&quot;cT&quot;:&quot;Container&quot;,&quot;id&quot;:&quot;c2c10c2c1c9c2m1r1a1&quot;,&quot;sN&quot;:2,&quot;aN&quot;:&quot;c10c2c1c9c2m1r1a1&quot;}">
            <a id="shellmenu_42" class="js-subm-uhf-nav-link" href="https://azure.microsoft.com/en-us/" data-m="{&quot;cN&quot;:&quot;GlobalNav_More_Business_MicrosoftAzure_nav&quot;,&quot;id&quot;:&quot;n1c2c10c2c1c9c2m1r1a1&quot;,&quot;sN&quot;:1,&quot;aN&quot;:&quot;c2c10c2c1c9c2m1r1a1&quot;}">Microsoft Azure</a>
            
        </li>
        <li class="js-nav-menu single-link" data-m="{&quot;cN&quot;:&quot;More_Business_MicrosoftDynamics365_cont&quot;,&quot;cT&quot;:&quot;Container&quot;,&quot;id&quot;:&quot;c3c10c2c1c9c2m1r1a1&quot;,&quot;sN&quot;:3,&quot;aN&quot;:&quot;c10c2c1c9c2m1r1a1&quot;}">
            <a id="shellmenu_43" class="js-subm-uhf-nav-link" href="https://www.microsoft.com/en-us/dynamics365/home" data-m="{&quot;cN&quot;:&quot;GlobalNav_More_Business_MicrosoftDynamics365_nav&quot;,&quot;id&quot;:&quot;n1c3c10c2c1c9c2m1r1a1&quot;,&quot;sN&quot;:1,&quot;aN&quot;:&quot;c3c10c2c1c9c2m1r1a1&quot;}">Microsoft Dynamics 365</a>
            
        </li>
        <li class="js-nav-menu single-link" data-m="{&quot;cN&quot;:&quot;Business_Microsoft365_cont&quot;,&quot;cT&quot;:&quot;Container&quot;,&quot;id&quot;:&quot;c4c10c2c1c9c2m1r1a1&quot;,&quot;sN&quot;:4,&quot;aN&quot;:&quot;c10c2c1c9c2m1r1a1&quot;}">
            <a id="shellmenu_44" class="js-subm-uhf-nav-link" href="https://www.microsoft.com/microsoft-365/?omkt=en-US" data-m="{&quot;cN&quot;:&quot;GlobalNav_Business_Microsoft365_nav&quot;,&quot;id&quot;:&quot;n1c4c10c2c1c9c2m1r1a1&quot;,&quot;sN&quot;:1,&quot;aN&quot;:&quot;c4c10c2c1c9c2m1r1a1&quot;}">Microsoft 365</a>
            
        </li>
        <li class="js-nav-menu single-link" data-m="{&quot;cN&quot;:&quot;More_Business_Enterprise_cont&quot;,&quot;cT&quot;:&quot;Container&quot;,&quot;id&quot;:&quot;c5c10c2c1c9c2m1r1a1&quot;,&quot;sN&quot;:5,&quot;aN&quot;:&quot;c10c2c1c9c2m1r1a1&quot;}">
            <a id="shellmenu_45" class="js-subm-uhf-nav-link" href="https://www.microsoft.com/en-us/enterprise" data-m="{&quot;cN&quot;:&quot;GlobalNav_More_Business_Enterprise_nav&quot;,&quot;id&quot;:&quot;n1c5c10c2c1c9c2m1r1a1&quot;,&quot;sN&quot;:1,&quot;aN&quot;:&quot;c5c10c2c1c9c2m1r1a1&quot;}">Microsoft Industry</a>
            
        </li>
        <li class="js-nav-menu single-link" data-m="{&quot;cN&quot;:&quot;More_Business_DataPlatform_cont&quot;,&quot;cT&quot;:&quot;Container&quot;,&quot;id&quot;:&quot;c6c10c2c1c9c2m1r1a1&quot;,&quot;sN&quot;:6,&quot;aN&quot;:&quot;c10c2c1c9c2m1r1a1&quot;}">
            <a id="shellmenu_46" class="js-subm-uhf-nav-link" href="https://www.microsoft.com/en-us/sql-server/" data-m="{&quot;cN&quot;:&quot;GlobalNav_More_Business_DataPlatform_nav&quot;,&quot;id&quot;:&quot;n1c6c10c2c1c9c2m1r1a1&quot;,&quot;sN&quot;:1,&quot;aN&quot;:&quot;c6c10c2c1c9c2m1r1a1&quot;}">Data platform</a>
            
        </li>
        <li class="js-nav-menu single-link" data-m="{&quot;cN&quot;:&quot;More_MicrosoftAdvertising_cont&quot;,&quot;cT&quot;:&quot;Container&quot;,&quot;id&quot;:&quot;c7c10c2c1c9c2m1r1a1&quot;,&quot;sN&quot;:7,&quot;aN&quot;:&quot;c10c2c1c9c2m1r1a1&quot;}">
            <a id="shellmenu_47" class="js-subm-uhf-nav-link" href="https://go.microsoft.com/fwlink/?linkid=2026638" data-m="{&quot;cN&quot;:&quot;GlobalNav_More_MicrosoftAdvertising_nav&quot;,&quot;id&quot;:&quot;n1c7c10c2c1c9c2m1r1a1&quot;,&quot;sN&quot;:1,&quot;aN&quot;:&quot;c7c10c2c1c9c2m1r1a1&quot;}">Microsoft Advertising</a>
            
        </li>
            </ul>
            
        </li>
        <li class="f-sub-menu js-nav-menu nested-menu" data-m="{&quot;cT&quot;:&quot;Container&quot;,&quot;id&quot;:&quot;c11c2c1c9c2m1r1a1&quot;,&quot;sN&quot;:11,&quot;aN&quot;:&quot;c2c1c9c2m1r1a1&quot;}">

            <button type="button" role="presentation" f-multi-parent="true" aria-expanded="false" data-m="{&quot;id&quot;:&quot;nn1c11c2c1c9c2m1r1a1&quot;,&quot;sN&quot;:1,&quot;aN&quot;:&quot;c11c2c1c9c2m1r1a1&quot;}">Developer &amp; IT  </button>
            <ul aria-hidden="true" role="presentation">
        <li class="js-nav-menu single-link" data-m="{&quot;cN&quot;:&quot;More_DeveloperAndIT_.Net_cont&quot;,&quot;cT&quot;:&quot;Container&quot;,&quot;id&quot;:&quot;c2c11c2c1c9c2m1r1a1&quot;,&quot;sN&quot;:2,&quot;aN&quot;:&quot;c11c2c1c9c2m1r1a1&quot;}">
            <a id="shellmenu_49" class="js-subm-uhf-nav-link" href="https://www.microsoft.com/net/" data-m="{&quot;cN&quot;:&quot;GlobalNav_More_DeveloperAndIT_.Net_nav&quot;,&quot;id&quot;:&quot;n1c2c11c2c1c9c2m1r1a1&quot;,&quot;sN&quot;:1,&quot;aN&quot;:&quot;c2c11c2c1c9c2m1r1a1&quot;}">.NET</a>
            
        </li>
        <li class="js-nav-menu single-link" data-m="{&quot;cN&quot;:&quot;More_DevelopersAndIT_VisualStudio_cont&quot;,&quot;cT&quot;:&quot;Container&quot;,&quot;id&quot;:&quot;c3c11c2c1c9c2m1r1a1&quot;,&quot;sN&quot;:3,&quot;aN&quot;:&quot;c11c2c1c9c2m1r1a1&quot;}">
            <a id="shellmenu_50" class="js-subm-uhf-nav-link" href="https://visualstudio.microsoft.com/" data-m="{&quot;cN&quot;:&quot;GlobalNav_More_DevelopersAndIT_VisualStudio_nav&quot;,&quot;id&quot;:&quot;n1c3c11c2c1c9c2m1r1a1&quot;,&quot;sN&quot;:1,&quot;aN&quot;:&quot;c3c11c2c1c9c2m1r1a1&quot;}">Visual Studio</a>
            
        </li>
        <li class="js-nav-menu single-link" data-m="{&quot;cN&quot;:&quot;More_ProductsandServices_WindowsServer_cont&quot;,&quot;cT&quot;:&quot;Container&quot;,&quot;id&quot;:&quot;c4c11c2c1c9c2m1r1a1&quot;,&quot;sN&quot;:4,&quot;aN&quot;:&quot;c11c2c1c9c2m1r1a1&quot;}">
            <a id="shellmenu_51" class="js-subm-uhf-nav-link" href="https://www.microsoft.com/cloud-platform/windows-server" data-m="{&quot;cN&quot;:&quot;GlobalNav_More_ProductsandServices_WindowsServer_nav&quot;,&quot;id&quot;:&quot;n1c4c11c2c1c9c2m1r1a1&quot;,&quot;sN&quot;:1,&quot;aN&quot;:&quot;c4c11c2c1c9c2m1r1a1&quot;}">Windows Server</a>
            
        </li>
        <li class="js-nav-menu single-link" data-m="{&quot;cN&quot;:&quot;More_DeveloperAndIT_WindowsDevCenter_cont&quot;,&quot;cT&quot;:&quot;Container&quot;,&quot;id&quot;:&quot;c5c11c2c1c9c2m1r1a1&quot;,&quot;sN&quot;:5,&quot;aN&quot;:&quot;c11c2c1c9c2m1r1a1&quot;}">
            <a id="shellmenu_52" class="js-subm-uhf-nav-link" href="https://developer.microsoft.com/en-us/windows" data-m="{&quot;cN&quot;:&quot;GlobalNav_More_DeveloperAndIT_WindowsDevCenter_nav&quot;,&quot;id&quot;:&quot;n1c5c11c2c1c9c2m1r1a1&quot;,&quot;sN&quot;:1,&quot;aN&quot;:&quot;c5c11c2c1c9c2m1r1a1&quot;}">Windows Dev Center</a>
            
        </li>
        <li class="js-nav-menu single-link" data-m="{&quot;cN&quot;:&quot;More_DeveloperAndIT_Docs.microsoft.com_cont&quot;,&quot;cT&quot;:&quot;Container&quot;,&quot;id&quot;:&quot;c6c11c2c1c9c2m1r1a1&quot;,&quot;sN&quot;:6,&quot;aN&quot;:&quot;c11c2c1c9c2m1r1a1&quot;}">
            <a id="shellmenu_53" class="js-subm-uhf-nav-link" href="https://docs.microsoft.com/en-us/" data-m="{&quot;cN&quot;:&quot;GlobalNav_More_DeveloperAndIT_Docs.microsoft.com_nav&quot;,&quot;id&quot;:&quot;n1c6c11c2c1c9c2m1r1a1&quot;,&quot;sN&quot;:1,&quot;aN&quot;:&quot;c6c11c2c1c9c2m1r1a1&quot;}">Docs</a>
            
        </li>
            </ul>
            
        </li>
        <li class="f-sub-menu js-nav-menu nested-menu" data-m="{&quot;cT&quot;:&quot;Container&quot;,&quot;id&quot;:&quot;c12c2c1c9c2m1r1a1&quot;,&quot;sN&quot;:12,&quot;aN&quot;:&quot;c2c1c9c2m1r1a1&quot;}">

            <button type="button" role="presentation" f-multi-parent="true" aria-expanded="false" data-m="{&quot;id&quot;:&quot;nn1c12c2c1c9c2m1r1a1&quot;,&quot;sN&quot;:1,&quot;aN&quot;:&quot;c12c2c1c9c2m1r1a1&quot;}">Other</button>
            <ul aria-hidden="true" role="presentation">
        <li class="js-nav-menu single-link" data-m="{&quot;cN&quot;:&quot;Other_MicrosoftStore_cont&quot;,&quot;cT&quot;:&quot;Container&quot;,&quot;id&quot;:&quot;c2c12c2c1c9c2m1r1a1&quot;,&quot;sN&quot;:2,&quot;aN&quot;:&quot;c12c2c1c9c2m1r1a1&quot;}">
            <a id="shellmenu_55" class="js-subm-uhf-nav-link" href="https://www.microsoft.com/en-us/store/b/home" data-m="{&quot;cN&quot;:&quot;GlobalNav_Other_MicrosoftStore_nav&quot;,&quot;id&quot;:&quot;n1c2c12c2c1c9c2m1r1a1&quot;,&quot;sN&quot;:1,&quot;aN&quot;:&quot;c2c12c2c1c9c2m1r1a1&quot;}">Microsoft Store</a>
            
        </li>
        <li class="js-nav-menu single-link" data-m="{&quot;cN&quot;:&quot;More_Other_Microsoft Rewards_cont&quot;,&quot;cT&quot;:&quot;Container&quot;,&quot;id&quot;:&quot;c3c12c2c1c9c2m1r1a1&quot;,&quot;sN&quot;:3,&quot;aN&quot;:&quot;c12c2c1c9c2m1r1a1&quot;}">
            <a id="shellmenu_56" class="js-subm-uhf-nav-link" href="https://www.microsoft.com/rewards" data-m="{&quot;cN&quot;:&quot;GlobalNav_More_Other_Microsoft Rewards_nav&quot;,&quot;id&quot;:&quot;n1c3c12c2c1c9c2m1r1a1&quot;,&quot;sN&quot;:1,&quot;aN&quot;:&quot;c3c12c2c1c9c2m1r1a1&quot;}">Microsoft Rewards </a>
            
        </li>
        <li class="js-nav-menu single-link" data-m="{&quot;cN&quot;:&quot;Products_SoftwareAndServices_FreeDownloadsAndSecurity_cont&quot;,&quot;cT&quot;:&quot;Container&quot;,&quot;id&quot;:&quot;c4c12c2c1c9c2m1r1a1&quot;,&quot;sN&quot;:4,&quot;aN&quot;:&quot;c12c2c1c9c2m1r1a1&quot;}">
            <a id="shellmenu_57" class="js-subm-uhf-nav-link" href="https://www.microsoft.com/en-us/download/default.aspx" data-m="{&quot;cN&quot;:&quot;GlobalNav_Products_SoftwareAndServices_FreeDownloadsAndSecurity_nav&quot;,&quot;id&quot;:&quot;n1c4c12c2c1c9c2m1r1a1&quot;,&quot;sN&quot;:1,&quot;aN&quot;:&quot;c4c12c2c1c9c2m1r1a1&quot;}">Free downloads &amp; security</a>
            
        </li>
        <li class="js-nav-menu single-link" data-m="{&quot;cN&quot;:&quot;Products_ForStudentsAndEducators_Education_cont&quot;,&quot;cT&quot;:&quot;Container&quot;,&quot;id&quot;:&quot;c5c12c2c1c9c2m1r1a1&quot;,&quot;sN&quot;:5,&quot;aN&quot;:&quot;c12c2c1c9c2m1r1a1&quot;}">
            <a id="shellmenu_58" class="js-subm-uhf-nav-link" href="https://www.microsoft.com/en-us/education?icid=CNavMSCOML0_Studentsandeducation" data-m="{&quot;cN&quot;:&quot;GlobalNav_Products_ForStudentsAndEducators_Education_nav&quot;,&quot;id&quot;:&quot;n1c5c12c2c1c9c2m1r1a1&quot;,&quot;sN&quot;:1,&quot;aN&quot;:&quot;c5c12c2c1c9c2m1r1a1&quot;}">Education</a>
            
        </li>
        <li class="js-nav-menu single-link" data-m="{&quot;cN&quot;:&quot;More_Other_Store_Locations_cont&quot;,&quot;cT&quot;:&quot;Container&quot;,&quot;id&quot;:&quot;c6c12c2c1c9c2m1r1a1&quot;,&quot;sN&quot;:6,&quot;aN&quot;:&quot;c12c2c1c9c2m1r1a1&quot;}">
            <a id="shellmenu_59" class="js-subm-uhf-nav-link" href="https://www.microsoft.com/en-us/store/locations/find-a-store?icid=TopNavStoreLocations" data-m="{&quot;cN&quot;:&quot;GlobalNav_More_Other_Store_Locations_nav&quot;,&quot;id&quot;:&quot;n1c6c12c2c1c9c2m1r1a1&quot;,&quot;sN&quot;:1,&quot;aN&quot;:&quot;c6c12c2c1c9c2m1r1a1&quot;}">Store locations</a>
            
        </li>
        <li class="js-nav-menu single-link" data-m="{&quot;cN&quot;:&quot;Store_More_GiftCards_cont&quot;,&quot;cT&quot;:&quot;Container&quot;,&quot;id&quot;:&quot;c7c12c2c1c9c2m1r1a1&quot;,&quot;sN&quot;:7,&quot;aN&quot;:&quot;c12c2c1c9c2m1r1a1&quot;}">
            <a id="shellmenu_60" class="js-subm-uhf-nav-link" href="https://www.microsoft.com/en-us/store/b/gift-cards" data-m="{&quot;cN&quot;:&quot;GlobalNav_Store_More_GiftCards_nav&quot;,&quot;id&quot;:&quot;n1c7c12c2c1c9c2m1r1a1&quot;,&quot;sN&quot;:1,&quot;aN&quot;:&quot;c7c12c2c1c9c2m1r1a1&quot;}">Gift cards</a>
            
        </li>
            </ul>
            
        </li>
                                                            <li class="f-multi-column-info">
                                    <a data-m="{&quot;id&quot;:&quot;n13c2c1c9c2m1r1a1&quot;,&quot;sN&quot;:13,&quot;aN&quot;:&quot;c2c1c9c2m1r1a1&quot;}" href="https://www.microsoft.com/en-us/sitemap.aspx" aria-label="" class="c-glyph">View Sitemap</a>
                                </li>
                            
                        </ul>
                    </div>
                </li>
            </ul>
        </nav>
</div>
		<form class="c-search" autocomplete="off" id="searchForm" name="searchForm" role="search" action="https://docs.microsoft.com/en-us/search/index" method="GET" title="Search" data-seautosuggest="{&quot;queryParams&quot;:{&quot;market&quot;:&quot;en-us&quot;,&quot;clientId&quot;:&quot;7F27B536-CF6B-4C65-8638-A0F8CBDFCA65&quot;,&quot;sources&quot;:&quot;Microsoft-Terms,Iris-Products,DCatAll-Products&quot;,&quot;filter&quot;:&quot;+ClientType:StoreWeb&quot;,&quot;counts&quot;:&quot;5,1,5&quot;},&quot;familyNames&quot;:{&quot;Apps&quot;:&quot;App&quot;,&quot;Books&quot;:&quot;Book&quot;,&quot;Bundles&quot;:&quot;Bundle&quot;,&quot;Devices&quot;:&quot;Device&quot;,&quot;Fees&quot;:&quot;Fee&quot;,&quot;Games&quot;:&quot;Game&quot;,&quot;MusicAlbums&quot;:&quot;Album&quot;,&quot;MusicTracks&quot;:&quot;Song&quot;,&quot;MusicVideos&quot;:&quot;Video&quot;,&quot;MusicArtists&quot;:&quot;Artist&quot;,&quot;OperatingSystem&quot;:&quot;Operating System&quot;,&quot;Software&quot;:&quot;Software&quot;,&quot;Movies&quot;:&quot;Movie&quot;,&quot;TV&quot;:&quot;TV&quot;,&quot;CSV&quot;:&quot;Gift Card&quot;,&quot;VideoActor&quot;:&quot;Actor&quot;}}" data-seautosuggestapi="https://www.microsoft.com/services/api/v3/suggest" data-m="{&quot;cN&quot;:&quot;GlobalNav_Search_cont&quot;,&quot;cT&quot;:&quot;Container&quot;,&quot;id&quot;:&quot;c3c1c9c2m1r1a1&quot;,&quot;sN&quot;:3,&quot;aN&quot;:&quot;c1c9c2m1r1a1&quot;}" aria-expanded="false">
			<input id="cli_shellHeaderSearchInput" aria-label="search expanded" aria-autocomplete="list" aria-controls="universal-header-search-auto-suggest-transparent" aria-owns="universal-header-search-auto-suggest-ul" type="search" name="search" placeholder="Search" data-m="{&quot;cN&quot;:&quot;SearchBox_nav&quot;,&quot;id&quot;:&quot;n1c3c1c9c2m1r1a1&quot;,&quot;sN&quot;:1,&quot;aN&quot;:&quot;c3c1c9c2m1r1a1&quot;}"><div class="x-screen-reader" aria-live="assertive"></div>
			<button id="search" aria-label="Search" class="c-glyph" data-m="{&quot;cN&quot;:&quot;Search_nav&quot;,&quot;id&quot;:&quot;n2c3c1c9c2m1r1a1&quot;,&quot;sN&quot;:2,&quot;aN&quot;:&quot;c3c1c9c2m1r1a1&quot;}" data-bi-dnt="true" data-bi-mto="true" aria-expanded="false">
				<span role="presentation">Search</span>
			</button>
			<div class="m-auto-suggest" id="universal-header-search-auto-suggest-transparent" role="group">
				<ul class="c-menu" id="universal-header-search-auto-suggest-ul" aria-hidden="true" data-bi-dnt="true" data-bi-mto="true" data-js-auto-suggest-position="default" role="listbox" data-tel="jsll" data-m="{&quot;cN&quot;:&quot;search suggestions_cont&quot;,&quot;cT&quot;:&quot;Container&quot;,&quot;id&quot;:&quot;c3c3c1c9c2m1r1a1&quot;,&quot;sN&quot;:3,&quot;aN&quot;:&quot;c3c1c9c2m1r1a1&quot;}"></ul>
			</div>
			
		<input name="scope" hidden=""><a class="search-scope" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#" role="button" title="Search filter is &quot;C++&quot;. Tap to remove." style=""><span class="search-scope-text">C++</span> <span class="docon docon-navigate-close"></span></a></form>
		<button data-m="{&quot;cN&quot;:&quot;cancel-search&quot;,&quot;pid&quot;:&quot;Cancel Search&quot;,&quot;id&quot;:&quot;nn4c1c9c2m1r1a1&quot;,&quot;sN&quot;:4,&quot;aN&quot;:&quot;c1c9c2m1r1a1&quot;}" id="cancel-search" class="cancel-search" aria-label="Cancel Search">
			<span>Cancel</span>
		</button>
				
			</div>
		</div>
		
		
	</div>
	
</header>




    </div>
        </div>

    </div>
</div>
	<div class="content-header uhf-container has-padding has-default-focus" data-bi-name="content-header">
		<nav class="has-padding-none-mobile" data-bi-name="breadcrumb" itemscope="" itemtype="http://schema.org/BreadcrumbList" role="navigation" aria-label="Breadcrumb">
		<ul id="page-breadcrumbs" class="breadcrumbs"><li itemprop="itemListElement" itemscope="" itemtype="http://schema.org/ListItem"><a itemprop="item" href="https://docs.microsoft.com/en-us/?view=vs-2019">Docs</a></li><li itemprop="itemListElement" itemscope="" itemtype="http://schema.org/ListItem"><a itemprop="item" href="https://docs.microsoft.com/en-us/cpp?view=vs-2019">Visual C++</a></li><li itemprop="itemListElement" itemscope="" itemtype="http://schema.org/ListItem"><a itemprop="item" href="https://docs.microsoft.com/en-us/cpp/overview/visual-cpp-in-visual-studio?view=vs-2019">Documentation</a></li><li itemprop="itemListElement" itemscope="" itemtype="http://schema.org/ListItem"><a itemprop="item" href="https://docs.microsoft.com/en-us/cpp/standard-library/cpp-standard-library-reference?view=vs-2019">C++ Standard Library</a></li><li><a href="https://docs.microsoft.com/en-us/cpp/standard-library/cpp-standard-library-reference?view=vs-2019">C++ Standard Library Reference</a></li><li><a href="https://docs.microsoft.com/en-us/cpp/standard-library/cpp-standard-library-header-files?view=vs-2019">C++ Standard Library Header Files</a></li><li class="mobile-breadcrumb"><a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm?view=vs-2019">&lt;algorithm&gt;</a></li><li>&lt;algorithm&gt; functions</li></ul>
		</nav>
		<div class="content-header-controls exit-focus">
			<button type="button" class="ap-collapse-behavior ap-expanded button" data-bi-name="ap-collapse" aria-controls="action-panel">
				<span class="icon"><span class="docon docon-exit-mode" aria-hidden="true"></span></span>
				<span>Exit focus mode</span>
			</button>
			
		</div>
		<div class="content-header-controls">
			<button type="button" class="contents-button button" data-bi-name="contents-expand" aria-controls="sidebar" aria-haspopup="true">
				<span class="icon"><span class="docon docon-menu" aria-hidden="true"></span></span>
				<span>Contents</span>
			</button>
		</div>
		<div class="action-bar">
			<ul class="action-list">
						<li>
							<a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#feedback" class="button is-text is-small is-icon-only-touch" data-bi-name="comments">
								<span class="icon">
									<span class="docon docon-comment-lines" aria-hidden="true"></span>
								</span>
								<span class="action-item-text">Feedback</span>
							</a>
						</li>
							<li id="contenteditbtn">
									<a href="https://github.com/Microsoft/cpp-docs/blob/master/docs/standard-library/algorithm-functions.md" class="button is-text is-icon-only-touch is-small" title="Edit This Document" data-bi-name="edit" data-original_content_git_url="https://github.com/MicrosoftDocs/cpp-docs-pr/blob/live/docs/standard-library/algorithm-functions.md" data-original_content_git_url_template="" data-pr_repo="" data-pr_branch="">
									<span class="icon">
										<span class="docon docon-edit-outline" aria-hidden="true"></span>
									</span>
									<span class="action-item-text">Edit</span>
								</a>
							</li>
				<li>
					<div class="sharing dropdown has-caret" auto-align="">
						<a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#" class="dropdown-trigger button is-text is-small is-icon-only-touch" aria-haspopup="true" aria-controls="sharing-menu" aria-expanded="false" title="Share This Document" data-bi-name="share">
							<span class="icon">
								<span class="docon docon-sharing" aria-hidden="true"></span>
							</span>
							<span class="action-item-text">Share</span>
						</a>
						<div class="dropdown-menu" id="sharing-menu" role="menu">
							<ul data-bi-name="share-links">
								<li>
									<a class="share-twitter" data-bi-name="twitter" href="https://twitter.com/intent/tweet?original_referer=https%3A%2F%2Fdocs.microsoft.com%2Fen-us%2Fcpp%2Fstandard-library%2Falgorithm-functions%3Fview%3Dvs-2019%26WT.mc_id%3Dtwitter&amp;text=%3Calgorithm%3E%20functions%20%7C%20Microsoft%20Docs&amp;tw_p=tweetbutton&amp;url=https%3A%2F%2Fdocs.microsoft.com%2Fen-us%2Fcpp%2Fstandard-library%2Falgorithm-functions%3Fview%3Dvs-2019%26WT.mc_id%3Dtwitter">
										<span class="icon">
											<span class="docon docon-brand-twitter" aria-hidden="true"></span>
										</span>
										<span>Twitter</span>
									</a>
								</li>
								<li>
									<a class="share-linkedin" data-bi-name="linkedin" href="https://www.linkedin.com/cws/share?url=https%3A%2F%2Fdocs.microsoft.com%2Fen-us%2Fcpp%2Fstandard-library%2Falgorithm-functions%3Fview%3Dvs-2019%26WT.mc_id%3Dlinkedin">
										<span class="icon">
											<span class="docon docon-brand-linkedin" aria-hidden="true"></span>
										</span>
										<span>LinkedIn</span>
									</a>
								</li>
								<li>
									<a class="share-facebook" data-bi-name="facebook" href="https://www.facebook.com/sharer/sharer.php?u=https%3A%2F%2Fdocs.microsoft.com%2Fen-us%2Fcpp%2Fstandard-library%2Falgorithm-functions%3Fview%3Dvs-2019%26WT.mc_id%3Dfacebook">
										<span class="icon">
											<span class="docon docon-brand-facebook" aria-hidden="true"></span>
										</span>
										<span>Facebook</span>
									</a>
								</li>
								<li>
									<a class="share-email" data-bi-name="email" href="mailto:?subject=%5BShared%20Article%5D%20%3Calgorithm%3E%20functions%20%7C%20Microsoft%20Docs&amp;body=%3Calgorithm%3E%20functions%20%7C%20Microsoft%20Docs%0A%0Ahttps%3A%2F%2Fdocs.microsoft.com%2Fen-us%2Fcpp%2Fstandard-library%2Falgorithm-functions%3Fview%3Dvs-2019%26WT.mc_id%3Demail">
										<span class="icon">
											<span class="docon docon-mail-message-fill" aria-hidden="true"></span>
										</span>
										<span>Email</span>
									</a>
								</li>
							</ul>
						</div>
					</div>
				</li>
				<li class="is-unstyle-action-list-item">
<div class="dropdown has-caret" auto-align="">
	<button class="dropdown-trigger button is-text is-small is-icon-only-touch" aria-controls="theme-menu" aria-expanded="false" title="Theme" data-bi-name="theme">
		<span class="icon">
			<span class="docon docon-sun" aria-hidden="true"></span>
		</span>
		<span class="action-item-text">Theme</span>
	</button>
	<div class="dropdown-menu" id="theme-menu" role="menu">
		<div class="theme-selector has-padding-small">
			<div class="theme is-block">
				<button class="button is-text is-small theme-control is-fullwidth has-flex-justify-content-start is-selected" data-theme-to="light" role="menuitem" aria-selected="true">
					<span class="theme-light">
						<span class="theme-selector-icon css-variable-support has-border is-inline-block has-margin-right-small has-body-background" aria-hidden="true">
							<svg class="svg" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 22 14">
								<rect width="22" height="14" class="has-fill-body-background"></rect>
								<rect x="5" y="5" width="12" height="4" class="has-fill-secondary"></rect>
								<rect x="5" y="2" width="2" height="1" class="has-fill-secondary"></rect>
								<rect x="8" y="2" width="2" height="1" class="has-fill-secondary"></rect>
								<rect x="11" y="2" width="3" height="1" class="has-fill-secondary"></rect>
								<rect x="1" y="1" width="2" height="2" class="has-fill-secondary"></rect>
								<rect x="5" y="10" width="7" height="2" rx="0.3" class="has-fill-primary"></rect>
								<rect x="19" y="1" width="2" height="2" rx="1" class="has-fill-secondary"></rect>
							</svg>
						</span>
					</span>
					<span>
Light					</span>
				</button>
			</div>
			<div class="theme is-block">
				<button class="button is-text is-small theme-control is-fullwidth has-flex-justify-content-start" data-theme-to="dark" role="menuitem" aria-selected="false">
					<span class="theme-dark">
						<span class="has-border theme-selector-icon css-variable-support is-inline-block has-margin-right-small has-body-background" aria-hidden="true">
							<svg class="svg" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 22 14">
								<rect width="22" height="14" class="has-fill-body-background"></rect>
								<rect x="5" y="5" width="12" height="4" class="has-fill-secondary"></rect>
								<rect x="5" y="2" width="2" height="1" class="has-fill-secondary"></rect>
								<rect x="8" y="2" width="2" height="1" class="has-fill-secondary"></rect>
								<rect x="11" y="2" width="3" height="1" class="has-fill-secondary"></rect>
								<rect x="1" y="1" width="2" height="2" class="has-fill-secondary"></rect>
								<rect x="5" y="10" width="7" height="2" rx="0.3" class="has-fill-primary"></rect>
								<rect x="19" y="1" width="2" height="2" rx="1" class="has-fill-secondary"></rect>
							</svg>
						</span>
					</span>
					<span>
Dark					</span>
				</button>
			</div>
			<div class="theme is-block">
				<button class="button is-text is-small theme-control is-fullwidth has-flex-justify-content-start" data-theme-to="high-contrast" role="menuitem" aria-selected="false">
					<span class="theme-high-contrast">
						<span class="has-border theme-selector-icon css-variable-support is-inline-block has-margin-right-small has-body-background" aria-hidden="true">
							<svg class="svg" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 22 14">
								<rect width="22" height="14" class="has-fill-body-background"></rect>
								<rect x="5" y="5" width="12" height="4" class="has-fill-secondary"></rect>
								<rect x="5" y="2" width="2" height="1" class="has-fill-secondary"></rect>
								<rect x="8" y="2" width="2" height="1" class="has-fill-secondary"></rect>
								<rect x="11" y="2" width="3" height="1" class="has-fill-secondary"></rect>
								<rect x="1" y="1" width="2" height="2" class="has-fill-secondary"></rect>
								<rect x="5" y="10" width="7" height="2" rx="0.3" class="has-fill-primary"></rect>
								<rect x="19" y="1" width="2" height="2" rx="1" class="has-fill-secondary"></rect>
							</svg>
						</span>
					</span>
					<span>
High contrast					</span>
				</button>
			</div>
		</div>
	</div>
</div>				</li>
				<li class="is-unstyled-action-list-item">
					<a class="docs-sign-in auth-status-determined not-authenticated button is-text has-text-primary is-small" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#">Sign in</a>
					<div class="dropdown has-caret auth-status-determined authenticated" auto-align="">
						<button class="dropdown-trigger button is-text is-small is-icon-only-touch has-inner-focus" aria-label="Your Account" aria-haspopup="true" aria-controls="user-menu" aria-expanded="false">
							<span class="icon" aria-hidden="true">
								<span class="image">
									<img class="has-body-background-medium is-rounded" data-profile-property="avatarUrl">
								</span>
							</span>
							<span class="is-truncated" data-profile-property="userName"></span>
						</button>
						<div class="dropdown-menu box" id="user-menu" role="menu">
							<div class="media is-user-dir">
								<div class="media-left">
									<span class="image is-64x64" aria-hidden="true">
										<img class="has-body-background-medium is-rounded" data-profile-property="avatarUrl">
									</span>
								</div>
								<div class="media-content">
									<p class="title has-margin-top-small has-margin-bottom-small">
										<span class="is-truncated" style="max-width: 200px" data-profile-property="userName"></span>
									</p>
									<p class="subtitle">
										<span class="is-truncated" style="max-width: 200px" data-profile-property="upn"></span>
									</p>
								</div>
							</div>
							<ul class="is-unstyled has-margin-none">
								<li><a href="https://docs.microsoft.com/profile" data-profile-property="profileUrl">Profile</a></li>
								<li><a class="docs-sign-out" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#">Sign out</a></li>
							</ul>
						</div>
					</div>
				</li>
			</ul>
			<button type="button" class="contents-button" aria-label="Contents" data-bi-name="contents-expand-">
				<span class="docon docon-editor-list-bullet"></span><span>Contents</span>
			</button>
		</div>
	</div>

		<div id="banner-holder" class="has-default-focus has-overflow-hidden">
		</div>

	<div id="disclaimer-holder" class="has-overflow-hidden"></div>
	</div>

	<div class="mainContainer uhf-container  has-top-padding  has-default-focus" data-bi-name="body">

		<div class="columns has-large-gaps ">

			<section class="primary-holder column is-two-thirds-tablet is-three-quarters-desktop">
				<div class="columns has-large-gaps ">


					<div id="page-actions" class="right-container column is-one-quarter is-one-fifth-desktop is-hidden-mobile is-hidden-tablet-only" data-bi-name="pageactions" role="complementary" aria-label="Page Actions">
							<nav id="side-doc-outline" class="doc-outline" data-bi-name="intopic toc" role="navigation" aria-label="On page navigation" style="width: 146.031px; top: 24px; bottom: 24px;">
								<h3>In this article</h3>
							<ol><li><a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#adjacent_find">adjacent_find</a></li><li><a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#all_of">all_of</a></li><li><a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#any_of">any_of</a></li><li><a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#binary_search">binary_search</a></li><li><a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#copy">copy</a></li><li><a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#copy_backward">copy_backward</a></li><li><a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#copy_if">copy_if</a></li><li><a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#copy_n">copy_n</a></li><li><a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#count">count</a></li><li><a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#count_if">count_if</a></li><li><a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#equal">equal</a></li><li class=""><a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#equal_range">equal_range</a></li><li class=""><a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#fill">fill</a></li><li class=""><a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#fill_n">fill_n</a></li><li class=""><a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#find">find</a></li><li class=""><a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#find_end">find_end</a></li><li class="selected"><a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#find_first_of">find_first_of</a></li><li class=""><a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#find_if">find_if</a></li><li class=""><a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#find_if_not">find_if_not</a></li><li class=""><a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#for_each">for_each</a></li><li><a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#generate">generate</a></li><li><a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#generate_n">generate_n</a></li><li><a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#includes">includes</a></li><li><a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#inplace_merge">inplace_merge</a></li><li><a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#is_heap">is_heap</a></li><li><a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#is_heap_until">is_heap_until</a></li><li><a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#is_partitioned">is_partitioned</a></li><li><a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#is_permutation">is_permutation</a></li><li><a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#is_sorted">is_sorted</a></li><li><a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#is_sorted_until">is_sorted_until</a></li><li><a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#iter_swap">iter_swap</a></li><li><a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#lexicographical_compare">lexicographical_compare</a></li><li><a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#lower_bound">lower_bound</a></li><li><a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#make_heap">make_heap</a></li><li><a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#max">max</a></li><li><a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#max_element">max_element</a></li><li><a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#merge">merge</a></li><li><a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#min">min</a></li><li><a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#min_element">min_element</a></li><li><a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#minmax_element">minmax_element</a></li><li><a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#minmax">minmax</a></li><li><a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#mismatch">mismatch</a></li><li><a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#alg_move">&lt;alg&gt; move</a></li><li><a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#move_backward">move_backward</a></li><li><a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#next_permutation">next_permutation</a></li><li><a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#nth_element">nth_element</a></li><li><a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#none_of">none_of</a></li><li><a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#partial_sort">partial_sort</a></li><li><a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#partial_sort_copy">partial_sort_copy</a></li><li><a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#partition">partition</a></li><li><a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#partition_copy">partition_copy</a></li><li><a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#partition_point">partition_point</a></li><li><a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#pop_heap">pop_heap</a></li><li><a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#prev_permutation">prev_permutation</a></li><li><a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#push_heap">push_heap</a></li><li><a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#random_shuffle">random_shuffle</a></li><li><a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#remove">remove</a></li><li><a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#remove_copy">remove_copy</a></li><li><a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#remove_copy_if">remove_copy_if</a></li><li><a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#remove_if">remove_if</a></li><li><a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#replace">replace</a></li><li><a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#replace_copy">replace_copy</a></li><li><a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#replace_copy_if">replace_copy_if</a></li><li><a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#replace_if">replace_if</a></li><li><a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#reverse">reverse</a></li><li><a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#reverse_copy">reverse_copy</a></li><li><a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#rotate">rotate</a></li><li><a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#rotate_copy">rotate_copy</a></li><li><a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#search">search</a></li><li><a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#search_n">search_n</a></li><li><a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#set_difference">set_difference</a></li><li><a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#set_intersection">set_intersection</a></li><li><a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#set_symmetric_difference">set_symmetric_difference</a></li><li><a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#set_union">set_union</a></li><li><a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#shuffle">shuffle</a></li><li><a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#sort">sort</a></li><li><a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#sort_heap">sort_heap</a></li><li><a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#stable_partition">stable_partition</a></li><li><a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#stable_sort">stable_sort</a></li><li><a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#swap">swap</a></li><li><a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#swap_ranges">swap_ranges</a></li><li><a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#transform">transform</a></li><li><a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#unique">unique</a></li><li><a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#unique_copy">unique_copy</a></li><li><a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#upper_bound">upper_bound</a></li><li><a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#see-also">See also</a></li></ol></nav>
					</div>


				<div id="main-column" class="column  is-full is-four-fifths-desktop ">

					<main id="main" role="main" class="content " data-bi-name="content" lang="en-us" dir="ltr">




						<div class="moniker-picker" data-bi-name="moniker-picker">
		<button class="products has-inner-focus" id="ax-2" aria-haspopup="true" aria-controls="ax-3" aria-expanded="false">
			<span class="visually-hidden">Selected Version</span>
			<span aria-hidden="true">Visual Studio 2019</span>
		</button>
		<div class="products" id="ax-3" role="menu" aria-labelledby="ax-2" style="z-index: 5000">
			<span aria-hidden="true">Version</span>
			<ul aria-label="Product"><li><a class="preserve-view has-inner-focus" role="menuitem" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019" aria-label="Visual Studio 2019" data-default="true" tabindex="-1">2019</a></li><li><a class="preserve-view has-inner-focus" role="menuitem" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2017" aria-label="Visual Studio 2017" data-default="false" tabindex="-1">2017</a></li><li><a class="preserve-view has-inner-focus" role="menuitem" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2015" aria-label="Visual Studio 2015" data-default="false" tabindex="-1">2015</a></li></ul>
		</div></div><h1 id="algorithm-functions" sourcefile="standard-library/algorithm-functions.md" sourcestartlinenumber="8">&lt;algorithm&gt; functions</h1>

						<ul class="metadata page-metadata" data-bi-name="page info" lang="en-us" dir="ltr">
							<li class="displayDate">
								<time role="presentation" datetime="2016-11-04T00:00:00.000Z" data-article-date-source="ms.date">11/03/2016</time>
							</li>
								<li class="readingTime">206 minutes to read</li>
							<li class="contributors-holder">
								<span class="contributors-text">Contributors</span>
								<ul class="contributors" data-bi-name="contributors">
											<li><a href="https://github.com/corob-msft" title="Colin Robertson" data-bi-name="contributorprofile"><img src="./_algorithm_ functions _ Microsoft Docs_files/corob-msft.png" data-src="https://github.com/corob-msft.png?size=32" alt="Colin Robertson"></a></li>
											<li><a href="https://github.com/openpublishbuild" title="Open Publishing Build Robots" data-bi-name="contributorprofile"><img src="./_algorithm_ functions _ Microsoft Docs_files/openpublishbuild.png" data-src="https://github.com/openpublishbuild.png?size=32" alt="Open Publishing Build Robots"></a></li>
											<li><a href="https://github.com/mikeblome" title="Mike B" data-bi-name="contributorprofile"><img src="./_algorithm_ functions _ Microsoft Docs_files/mikeblome.png" data-src="https://github.com/mikeblome.png?size=32" alt="Mike B"></a></li>
											<li><a href="https://github.com/v-aljenk" title="Alma Jenks" data-bi-name="contributorprofile"><img src="./_algorithm_ functions _ Microsoft Docs_files/contributor.svg" data-src="https://github.com/v-aljenk.png?size=32" alt="Alma Jenks"></a></li>
											<li><a href="https://github.com/msebolt" title="Matthew Sebolt" data-bi-name="contributorprofile"><img src="./_algorithm_ functions _ Microsoft Docs_files/msebolt.png" data-src="https://github.com/msebolt.png?size=32" alt="Matthew Sebolt"></a></li>
											<li><a href="https://github.com/Microsoft/cpp-docs/blob/master/docs/standard-library/algorithm-functions.md" title="all 8 contributors" data-bi-name="contributorshowall"><span aria-hidden="true">all</span></a></li>
								</ul>
							</li>

						</ul>



						<nav id="center-doc-outline" class="doc-outline is-hidden-desktop" data-bi-name="intopic toc" role="navigation" aria-label="On page navigation">
							<h3>In this article</h3>
						<ol><li><a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#adjacent_find">adjacent_find</a></li><li><a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#all_of">all_of</a></li><li><a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#any_of">any_of</a></li><li><a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#binary_search">binary_search</a></li><li><a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#copy">copy</a></li><li><a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#copy_backward">copy_backward</a></li><li><a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#copy_if">copy_if</a></li><li><a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#copy_n">copy_n</a></li><li><a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#count">count</a></li><li><a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#count_if">count_if</a></li><li><a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#equal">equal</a></li><li><a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#equal_range">equal_range</a></li><li><a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#fill">fill</a></li><li><a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#fill_n">fill_n</a></li><li><a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#find">find</a></li><li><a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#find_end">find_end</a></li><li><a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#find_first_of">find_first_of</a></li><li><a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#find_if">find_if</a></li><li><a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#find_if_not">find_if_not</a></li><li><a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#for_each">for_each</a></li><li><a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#generate">generate</a></li><li><a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#generate_n">generate_n</a></li><li><a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#includes">includes</a></li><li><a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#inplace_merge">inplace_merge</a></li><li><a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#is_heap">is_heap</a></li><li><a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#is_heap_until">is_heap_until</a></li><li><a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#is_partitioned">is_partitioned</a></li><li><a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#is_permutation">is_permutation</a></li><li><a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#is_sorted">is_sorted</a></li><li><a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#is_sorted_until">is_sorted_until</a></li><li><a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#iter_swap">iter_swap</a></li><li><a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#lexicographical_compare">lexicographical_compare</a></li><li><a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#lower_bound">lower_bound</a></li><li><a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#make_heap">make_heap</a></li><li><a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#max">max</a></li><li><a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#max_element">max_element</a></li><li><a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#merge">merge</a></li><li><a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#min">min</a></li><li><a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#min_element">min_element</a></li><li><a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#minmax_element">minmax_element</a></li><li><a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#minmax">minmax</a></li><li><a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#mismatch">mismatch</a></li><li><a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#alg_move">&lt;alg&gt; move</a></li><li><a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#move_backward">move_backward</a></li><li><a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#next_permutation">next_permutation</a></li><li><a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#nth_element">nth_element</a></li><li><a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#none_of">none_of</a></li><li><a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#partial_sort">partial_sort</a></li><li><a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#partial_sort_copy">partial_sort_copy</a></li><li><a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#partition">partition</a></li><li><a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#partition_copy">partition_copy</a></li><li><a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#partition_point">partition_point</a></li><li><a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#pop_heap">pop_heap</a></li><li><a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#prev_permutation">prev_permutation</a></li><li><a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#push_heap">push_heap</a></li><li><a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#random_shuffle">random_shuffle</a></li><li><a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#remove">remove</a></li><li><a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#remove_copy">remove_copy</a></li><li><a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#remove_copy_if">remove_copy_if</a></li><li><a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#remove_if">remove_if</a></li><li><a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#replace">replace</a></li><li><a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#replace_copy">replace_copy</a></li><li><a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#replace_copy_if">replace_copy_if</a></li><li><a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#replace_if">replace_if</a></li><li><a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#reverse">reverse</a></li><li><a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#reverse_copy">reverse_copy</a></li><li><a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#rotate">rotate</a></li><li><a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#rotate_copy">rotate_copy</a></li><li><a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#search">search</a></li><li><a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#search_n">search_n</a></li><li><a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#set_difference">set_difference</a></li><li><a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#set_intersection">set_intersection</a></li><li><a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#set_symmetric_difference">set_symmetric_difference</a></li><li><a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#set_union">set_union</a></li><li><a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#shuffle">shuffle</a></li><li><a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#sort">sort</a></li><li><a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#sort_heap">sort_heap</a></li><li><a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#stable_partition">stable_partition</a></li><li><a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#stable_sort">stable_sort</a></li><li><a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#swap">swap</a></li><li><a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#swap_ranges">swap_ranges</a></li><li><a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#transform">transform</a></li><li><a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#unique">unique</a></li><li><a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#unique_copy">unique_copy</a></li><li><a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#upper_bound">upper_bound</a></li><li><a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#see-also">See also</a></li></ol></nav>


						<!-- <content> -->
							
<div class="table-scroll-wrapper"><table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#alg_move" data-linktype="self-bookmark">move</a></td>
<td><a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#adjacent_find" data-linktype="self-bookmark">adjacent_find</a></td>
<td><a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#all_of" data-linktype="self-bookmark">all_of</a></td>
</tr>
<tr>
<td><a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#any_of" data-linktype="self-bookmark">any_of</a></td>
<td><a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#binary_search" data-linktype="self-bookmark">binary_search</a></td>
<td><a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#copy" data-linktype="self-bookmark">copy</a></td>
</tr>
<tr>
<td><a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#copy_backward" data-linktype="self-bookmark">copy_backward</a></td>
<td><a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#copy_if" data-linktype="self-bookmark">copy_if</a></td>
<td><a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#copy_n" data-linktype="self-bookmark">copy_n</a></td>
</tr>
<tr>
<td><a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#count" data-linktype="self-bookmark">count</a></td>
<td><a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#count_if" data-linktype="self-bookmark">count_if</a></td>
<td><a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#equal" data-linktype="self-bookmark">equal</a></td>
</tr>
<tr>
<td><a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#equal_range" data-linktype="self-bookmark">equal_range</a></td>
<td><a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#fill" data-linktype="self-bookmark">fill</a></td>
<td><a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#fill_n" data-linktype="self-bookmark">fill_n</a></td>
</tr>
<tr>
<td><a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#find" data-linktype="self-bookmark">find</a></td>
<td><a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#find_end" data-linktype="self-bookmark">find_end</a></td>
<td><a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#find_first_of" data-linktype="self-bookmark">find_first_of</a></td>
</tr>
<tr>
<td><a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#find_if" data-linktype="self-bookmark">find_if</a></td>
<td><a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#find_if_not" data-linktype="self-bookmark">find_if_not</a></td>
<td><a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#for_each" data-linktype="self-bookmark">for_each</a></td>
</tr>
<tr>
<td><a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#generate" data-linktype="self-bookmark">generate</a></td>
<td><a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#generate_n" data-linktype="self-bookmark">generate_n</a></td>
<td><a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#includes" data-linktype="self-bookmark">includes</a></td>
</tr>
<tr>
<td><a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#inplace_merge" data-linktype="self-bookmark">inplace_merge</a></td>
<td><a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#is_heap" data-linktype="self-bookmark">is_heap</a></td>
<td><a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#is_heap_until" data-linktype="self-bookmark">is_heap_until</a></td>
</tr>
<tr>
<td><a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#is_partitioned" data-linktype="self-bookmark">is_partitioned</a></td>
<td><a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#is_permutation" data-linktype="self-bookmark">is_permutation</a></td>
<td><a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#is_sorted" data-linktype="self-bookmark">is_sorted</a></td>
</tr>
<tr>
<td><a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#is_sorted_until" data-linktype="self-bookmark">is_sorted_until</a></td>
<td><a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#iter_swap" data-linktype="self-bookmark">iter_swap</a></td>
<td><a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#lexicographical_compare" data-linktype="self-bookmark">lexicographical_compare</a></td>
</tr>
<tr>
<td><a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#lower_bound" data-linktype="self-bookmark">lower_bound</a></td>
<td><a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#make_heap" data-linktype="self-bookmark">make_heap</a></td>
<td><a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#max" data-linktype="self-bookmark">max</a></td>
</tr>
<tr>
<td><a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#max_element" data-linktype="self-bookmark">max_element</a></td>
<td><a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#merge" data-linktype="self-bookmark">merge</a></td>
<td><a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#min" data-linktype="self-bookmark">min</a></td>
</tr>
<tr>
<td><a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#min_element" data-linktype="self-bookmark">min_element</a></td>
<td><a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#minmax" data-linktype="self-bookmark">minmax</a></td>
<td><a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#minmax_element" data-linktype="self-bookmark">minmax_element</a></td>
</tr>
<tr>
<td><a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#mismatch" data-linktype="self-bookmark">mismatch</a></td>
<td><a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#move_backward" data-linktype="self-bookmark">move_backward</a></td>
<td><a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#next_permutation" data-linktype="self-bookmark">next_permutation</a></td>
</tr>
<tr>
<td><a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#none_of" data-linktype="self-bookmark">none_of</a></td>
<td><a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#nth_element" data-linktype="self-bookmark">nth_element</a></td>
<td><a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#partial_sort" data-linktype="self-bookmark">partial_sort</a></td>
</tr>
<tr>
<td><a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#partial_sort_copy" data-linktype="self-bookmark">partial_sort_copy</a></td>
<td><a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#partition" data-linktype="self-bookmark">partition</a></td>
<td><a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#partition_copy" data-linktype="self-bookmark">partition_copy</a></td>
</tr>
<tr>
<td><a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#partition_point" data-linktype="self-bookmark">partition_point</a></td>
<td><a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#pop_heap" data-linktype="self-bookmark">pop_heap</a></td>
<td><a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#prev_permutation" data-linktype="self-bookmark">prev_permutation</a></td>
</tr>
<tr>
<td><a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#push_heap" data-linktype="self-bookmark">push_heap</a></td>
<td><a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#random_shuffle" data-linktype="self-bookmark">random_shuffle</a></td>
<td><a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#remove" data-linktype="self-bookmark">remove</a></td>
</tr>
<tr>
<td><a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#remove_copy" data-linktype="self-bookmark">remove_copy</a></td>
<td><a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#remove_copy_if" data-linktype="self-bookmark">remove_copy_if</a></td>
<td><a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#remove_if" data-linktype="self-bookmark">remove_if</a></td>
</tr>
<tr>
<td><a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#replace" data-linktype="self-bookmark">replace</a></td>
<td><a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#replace_copy" data-linktype="self-bookmark">replace_copy</a></td>
<td><a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#replace_copy_if" data-linktype="self-bookmark">replace_copy_if</a></td>
</tr>
<tr>
<td><a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#replace_if" data-linktype="self-bookmark">replace_if</a></td>
<td><a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#reverse" data-linktype="self-bookmark">reverse</a></td>
<td><a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#reverse_copy" data-linktype="self-bookmark">reverse_copy</a></td>
</tr>
<tr>
<td><a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#rotate" data-linktype="self-bookmark">rotate</a></td>
<td><a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#rotate_copy" data-linktype="self-bookmark">rotate_copy</a></td>
<td><a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#search" data-linktype="self-bookmark">search</a></td>
</tr>
<tr>
<td><a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#search_n" data-linktype="self-bookmark">search_n</a></td>
<td><a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#set_difference" data-linktype="self-bookmark">set_difference</a></td>
<td><a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#set_intersection" data-linktype="self-bookmark">set_intersection</a></td>
</tr>
<tr>
<td><a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#set_symmetric_difference" data-linktype="self-bookmark">set_symmetric_difference</a></td>
<td><a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#set_union" data-linktype="self-bookmark">set_union</a></td>
<td><a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#sort" data-linktype="self-bookmark">sort</a></td>
</tr>
<tr>
<td><a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#sort_heap" data-linktype="self-bookmark">sort_heap</a></td>
<td><a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#stable_partition" data-linktype="self-bookmark">stable_partition</a></td>
<td><a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#stable_sort" data-linktype="self-bookmark">stable_sort</a></td>
</tr>
<tr>
<td><a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#shuffle" data-linktype="self-bookmark">shuffle</a></td>
<td><a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#swap" data-linktype="self-bookmark">swap</a></td>
<td><a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#swap_ranges" data-linktype="self-bookmark">swap_ranges</a></td>
</tr>
<tr>
<td><a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#transform" data-linktype="self-bookmark">transform</a></td>
<td><a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#unique" data-linktype="self-bookmark">unique</a></td>
<td><a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#unique_copy" data-linktype="self-bookmark">unique_copy</a></td>
</tr>
<tr>
<td><a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#upper_bound" data-linktype="self-bookmark">upper_bound</a></td>
<td></td>
<td></td>
</tr>
</tbody>
</table></div>
<h2 id="adjacent_find" class="heading-with-anchor">  adjacent_find<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#adjacent_find"></a></h2>
<p>Searches for two adjacent elements that are either equal or satisfy a specified condition.</p>
<div class="codeHeader" id="code-try-0" data-bi-name="code-header"><span class="language">C++</span>
			<button class="action" data-bi-name="copy">
				<span class="docon docon-edit-copy" role="presentation"></span>
				<span>Copy</span>
			</button></div><pre><code class="lang-cpp" data-author-content="template&lt;class ForwardIterator&gt;
ForwardIterator adjacent_find(
    ForwardIterator first,
    ForwardIterator last);

template&lt;class ForwardIterator , class BinaryPredicate&gt;
ForwardIterator adjacent_find(
    ForwardIterator first,
    ForwardIterator last,
    BinaryPredicate comp);
"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ForwardIterator</span>&gt;
<span class="hljs-title">ForwardIterator</span> <span class="hljs-title">adjacent_find</span>(
    <span class="hljs-title">ForwardIterator</span> <span class="hljs-title">first</span>,
    <span class="hljs-title">ForwardIterator</span> <span class="hljs-title">last</span>);</span>

<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ForwardIterator</span> , <span class="hljs-title">class</span> <span class="hljs-title">BinaryPredicate</span>&gt;
<span class="hljs-title">ForwardIterator</span> <span class="hljs-title">adjacent_find</span>(
    <span class="hljs-title">ForwardIterator</span> <span class="hljs-title">first</span>,
    <span class="hljs-title">ForwardIterator</span> <span class="hljs-title">last</span>,
    <span class="hljs-title">BinaryPredicate</span> <span class="hljs-title">comp</span>);</span>
</code></pre>
<h3 id="parameters" class="heading-with-anchor">Parameters<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#parameters"></a></h3>
<p><em>first</em><br>
A forward iterator addressing the position of the first element in the range to be searched.</p>
<p><em>last</em><br>
A forward iterator addressing the position one past the final element in the range to be searched.</p>
<p><em>comp</em><br>
The binary predicate giving the condition to be satisfied by the values of the adjacent elements in the range being searched.</p>
<h3 id="return-value" class="heading-with-anchor">Return Value<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#return-value"></a></h3>
<p>A forward iterator to the first element of the adjacent pair that are either equal to each other (in the first version) or that satisfy the condition given by the binary predicate (in the second version), provided that such a pair of elements is found. Otherwise, an iterator pointing to <em>last</em> is returned.</p>
<h3 id="remarks" class="heading-with-anchor">Remarks<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#remarks"></a></h3>
<p>The <code>adjacent_find</code> algorithm is a nonmutating sequence algorithm. The range to be searched must be valid; all pointers must be dereferenceable and the last position is reachable from the first by incrementation. The time complexity of the algorithm is linear in the number of elements contained in the range.</p>
<p>The <code>operator==</code> used to determine the match between elements must impose an equivalence relation between its operands.</p>
<h3 id="example" class="heading-with-anchor">Example<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#example"></a></h3>
<div class="codeHeader" id="code-try-1" data-bi-name="code-header"><span class="language">C++</span>
			<button class="action" data-bi-name="copy">
				<span class="docon docon-edit-copy" role="presentation"></span>
				<span>Copy</span>
			</button></div><pre><code class="lang-cpp" data-author-content="// alg_adj_fnd.cpp
// compile with: /EHsc
#include &lt;list&gt;
#include &lt;algorithm&gt;
#include &lt;iostream&gt;

// Returns whether second element is twice the first
bool twice (int elem1, int elem2 )
{
   return elem1 * 2 == elem2;
}

int main()
{
   using namespace std;
   list &lt;int&gt; L;
   list &lt;int&gt;::iterator Iter;
   list &lt;int&gt;::iterator result1, result2;

   L.push_back( 50 );
   L.push_back( 40 );
   L.push_back( 10 );
   L.push_back( 20 );
   L.push_back( 20 );

   cout &lt;&lt; &quot;L = ( &quot; ;
   for ( Iter = L.begin( ) ; Iter != L.end( ) ; Iter++ )
      cout &lt;&lt; *Iter &lt;&lt; &quot; &quot;;
   cout &lt;&lt; &quot;)&quot; &lt;&lt; endl;

   result1 = adjacent_find( L.begin( ), L.end( ) );
   if ( result1 == L.end( ) )
      cout &lt;&lt; &quot;There are not two adjacent elements that are equal.&quot;
           &lt;&lt; endl;
   else
      cout &lt;&lt; &quot;There are two adjacent elements that are equal.&quot;
           &lt;&lt; &quot;\n They have a value of &quot;
           &lt;&lt;  *( result1 ) &lt;&lt; &quot;.&quot; &lt;&lt; endl;

   result2 = adjacent_find( L.begin( ), L.end( ), twice );
   if ( result2 == L.end( ) )
      cout &lt;&lt; &quot;There are not two adjacent elements where the &quot;
           &lt;&lt; &quot; second is twice the first.&quot; &lt;&lt; endl;
   else
      cout &lt;&lt; &quot;There are two adjacent elements where &quot;
           &lt;&lt; &quot;the second is twice the first.&quot;
           &lt;&lt; &quot;\n They have values of &quot; &lt;&lt; *(result2++);
      cout &lt;&lt; &quot; &amp; &quot; &lt;&lt; *result2 &lt;&lt; &quot;.&quot; &lt;&lt; endl;
}
"><span class="hljs-comment">// alg_adj_fnd.cpp</span>
<span class="hljs-comment">// compile with: /EHsc</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;list&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span>

<span class="hljs-comment">// Returns whether second element is twice the first</span>
<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">twice</span> <span class="hljs-params">(<span class="hljs-keyword">int</span> elem1, <span class="hljs-keyword">int</span> elem2 )</span>
</span>{
   <span class="hljs-keyword">return</span> elem1 * <span class="hljs-number">2</span> == elem2;
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
   <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;
   <span class="hljs-built_in">list</span> &lt;<span class="hljs-keyword">int</span>&gt; L;
   <span class="hljs-built_in">list</span> &lt;<span class="hljs-keyword">int</span>&gt;::iterator Iter;
   <span class="hljs-built_in">list</span> &lt;<span class="hljs-keyword">int</span>&gt;::iterator result1, result2;

   L.push_back( <span class="hljs-number">50</span> );
   L.push_back( <span class="hljs-number">40</span> );
   L.push_back( <span class="hljs-number">10</span> );
   L.push_back( <span class="hljs-number">20</span> );
   L.push_back( <span class="hljs-number">20</span> );

   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"L = ( "</span> ;
   <span class="hljs-keyword">for</span> ( Iter = L.begin( ) ; Iter != L.end( ) ; Iter++ )
      <span class="hljs-built_in">cout</span> &lt;&lt; *Iter &lt;&lt; <span class="hljs-string">" "</span>;
   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">")"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;

   result1 = adjacent_find( L.begin( ), L.end( ) );
   <span class="hljs-keyword">if</span> ( result1 == L.end( ) )
      <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"There are not two adjacent elements that are equal."</span>
           &lt;&lt; <span class="hljs-built_in">endl</span>;
   <span class="hljs-keyword">else</span>
      <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"There are two adjacent elements that are equal."</span>
           &lt;&lt; <span class="hljs-string">"\n They have a value of "</span>
           &lt;&lt;  *( result1 ) &lt;&lt; <span class="hljs-string">"."</span> &lt;&lt; <span class="hljs-built_in">endl</span>;

   result2 = adjacent_find( L.begin( ), L.end( ), twice );
   <span class="hljs-keyword">if</span> ( result2 == L.end( ) )
      <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"There are not two adjacent elements where the "</span>
           &lt;&lt; <span class="hljs-string">" second is twice the first."</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
   <span class="hljs-keyword">else</span>
      <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"There are two adjacent elements where "</span>
           &lt;&lt; <span class="hljs-string">"the second is twice the first."</span>
           &lt;&lt; <span class="hljs-string">"\n They have values of "</span> &lt;&lt; *(result2++);
      <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">" &amp; "</span> &lt;&lt; *result2 &lt;&lt; <span class="hljs-string">"."</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
}
</code></pre>
<div class="codeHeader" id="code-try-2" data-bi-name="code-header"><span class="language">Output</span>
			<button class="action" data-bi-name="copy">
				<span class="docon docon-edit-copy" role="presentation"></span>
				<span>Copy</span>
			</button></div><pre><code class="lang-Output" data-author-content="L = ( 50 40 10 20 20 )
There are two adjacent elements that are equal.
They have a value of 20.
There are two adjacent elements where the second is twice the first.
They have values of 10 &amp; 20.
">L = ( 50 40 10 20 20 )
There are two adjacent elements that are equal.
They have a value of 20.
There are two adjacent elements where the second is twice the first.
They have values of 10 &amp; 20.
</code></pre>
<h2 id="all_of" class="heading-with-anchor">  all_of<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#all_of"></a></h2>
<p>Returns <strong>true</strong> when a condition is present at each element in the given range.</p>
<div class="codeHeader" id="code-try-3" data-bi-name="code-header"><span class="language">C++</span>
			<button class="action" data-bi-name="copy">
				<span class="docon docon-edit-copy" role="presentation"></span>
				<span>Copy</span>
			</button></div><pre><code class="lang-cpp" data-author-content="template&lt;class InputIterator, class Predicate&gt;
bool all_of(
    InputIterator first,
    InputIterator last,
    BinaryPredicatecomp);
"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InputIterator</span>, <span class="hljs-title">class</span> <span class="hljs-title">Predicate</span>&gt;
<span class="hljs-title">bool</span> <span class="hljs-title">all_of</span>(
    <span class="hljs-title">InputIterator</span> <span class="hljs-title">first</span>,
    <span class="hljs-title">InputIterator</span> <span class="hljs-title">last</span>,
    <span class="hljs-title">BinaryPredicatecomp</span>);</span>
</code></pre>
<h3 id="parameters-1" class="heading-with-anchor">Parameters<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#parameters-1"></a></h3>
<p><em>first</em><br>
An input iterator that indicates where to start to check for a condition. The iterator marks where a range of elements starts.</p>
<p><em>last</em><br>
An input iterator that indicates the end of the range of elements to check for a condition.</p>
<p><em>comp</em><br>
A condition to test for. This is a user-defined predicate function object that defines the condition to be satisfied by an element being checked. A predicate takes a single argument and returns <strong>true</strong> or <strong>false</strong>.</p>
<h3 id="return-value-1" class="heading-with-anchor">Return Value<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#return-value-1"></a></h3>
<p>Returns <strong>true</strong> if the condition is detected at each element in the indicated range, and <strong>false</strong> if the condition is not detected at least one time.</p>
<h3 id="remarks-1" class="heading-with-anchor">Remarks<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#remarks-1"></a></h3>
<p>The template function returns <strong>true</strong> only if, for each <code>N</code> in the range <code>[0,Last - first)</code>, the predicate <code>comp(*(_First + N))</code> is <strong>true</strong>.</p>
<h2 id="any_of" class="heading-with-anchor">  any_of<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#any_of"></a></h2>
<p>Returns <strong>true</strong> when a condition is present at least once in the specified range of elements.</p>
<div class="codeHeader" id="code-try-4" data-bi-name="code-header"><span class="language">C++</span>
			<button class="action" data-bi-name="copy">
				<span class="docon docon-edit-copy" role="presentation"></span>
				<span>Copy</span>
			</button></div><pre><code class="lang-cpp" data-author-content="template&lt;class InputIterator, class UnaryPredicate&gt;
bool any_of(
    InputIterator first,
    InputIterator last,
    UnaryPredicate comp);
"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InputIterator</span>, <span class="hljs-title">class</span> <span class="hljs-title">UnaryPredicate</span>&gt;
<span class="hljs-title">bool</span> <span class="hljs-title">any_of</span>(
    <span class="hljs-title">InputIterator</span> <span class="hljs-title">first</span>,
    <span class="hljs-title">InputIterator</span> <span class="hljs-title">last</span>,
    <span class="hljs-title">UnaryPredicate</span> <span class="hljs-title">comp</span>);</span>
</code></pre>
<h3 id="parameters-2" class="heading-with-anchor">Parameters<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#parameters-2"></a></h3>
<p><em>first</em><br>
An input iterator that indicates where to start checking a range of elements for a condition.</p>
<p><em>last</em><br>
An input iterator that indicates the end of the range of elements to check for a condition.</p>
<p><em>comp</em><br>
A condition to test for. This is provided by a user-defined predicate function object. The predicate defines the condition to be satisfied by the element being tested. A predicate takes a single argument and returns <strong>true</strong> or <strong>false</strong>.</p>
<h3 id="return-value-2" class="heading-with-anchor">Return Value<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#return-value-2"></a></h3>
<p>Returns <strong>true</strong> if the condition is detected at least once in the indicated range, <strong>false</strong> if the condition is never detected.</p>
<h3 id="remarks-2" class="heading-with-anchor">Remarks<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#remarks-2"></a></h3>
<p>The template function returns <strong>true</strong> only if, for some <code>N</code> in the range</p>
<p><code>[0, last - first)</code>, the predicate <code>comp(*(first + N))</code> is true.</p>
<h2 id="binary_search" class="heading-with-anchor">  binary_search<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#binary_search"></a></h2>
<p>Tests whether there is an element in a sorted range that is equal to a specified value or that is equivalent to it in a sense specified by a binary predicate.</p>
<div class="codeHeader" id="code-try-5" data-bi-name="code-header"><span class="language">C++</span>
			<button class="action" data-bi-name="copy">
				<span class="docon docon-edit-copy" role="presentation"></span>
				<span>Copy</span>
			</button></div><pre><code class="lang-cpp" data-author-content="template&lt;class ForwardIterator, class Type&gt;
bool binary_search(
    ForwardIterator first,
    ForwardIterator last,
    const Type&amp; value);

template&lt;class ForwardIterator,  class Type,  class BinaryPredicate&gt;
bool binary_search(
    ForwardIterator first,
    ForwardIterator last,
    const Type&amp; value,
    BinaryPredicate comp);
"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ForwardIterator</span>, <span class="hljs-title">class</span> <span class="hljs-title">Type</span>&gt;
<span class="hljs-title">bool</span> <span class="hljs-title">binary_search</span>(
    <span class="hljs-title">ForwardIterator</span> <span class="hljs-title">first</span>,
    <span class="hljs-title">ForwardIterator</span> <span class="hljs-title">last</span>,
    <span class="hljs-title">const</span> <span class="hljs-title">Type</span>&amp; <span class="hljs-title">value</span>);</span>

<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ForwardIterator</span>,  <span class="hljs-title">class</span> <span class="hljs-title">Type</span>,  <span class="hljs-title">class</span> <span class="hljs-title">BinaryPredicate</span>&gt;
<span class="hljs-title">bool</span> <span class="hljs-title">binary_search</span>(
    <span class="hljs-title">ForwardIterator</span> <span class="hljs-title">first</span>,
    <span class="hljs-title">ForwardIterator</span> <span class="hljs-title">last</span>,
    <span class="hljs-title">const</span> <span class="hljs-title">Type</span>&amp; <span class="hljs-title">value</span>,
    <span class="hljs-title">BinaryPredicate</span> <span class="hljs-title">comp</span>);</span>
</code></pre>
<h3 id="parameters-3" class="heading-with-anchor">Parameters<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#parameters-3"></a></h3>
<p><em>first</em><br>
A forward iterator addressing the position of the first element in the range to be searched.</p>
<p><em>last</em><br>
A forward iterator addressing the position one past the final element in the range to be searched.</p>
<p><em>value</em><br>
The value required to be matched by the value of the element or that must satisfy the condition with the element value specified by the binary predicate.</p>
<p><em>comp</em><br>
User-defined predicate function object that defines sense in which one element is less than another. A binary predicate takes two arguments and returns <strong>true</strong> when satisfied and <strong>false</strong> when not satisfied.</p>
<h3 id="return-value-3" class="heading-with-anchor">Return Value<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#return-value-3"></a></h3>
<p><strong>true</strong> if an element is found in the range that is equal or equivalent to the specified value; otherwise, <strong>false</strong>.</p>
<h3 id="remarks-3" class="heading-with-anchor">Remarks<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#remarks-3"></a></h3>
<p>The sorted source range referenced must be valid; all pointers must be dereferenceable and, within the sequence, the last position must be reachable from the first by incrementation.</p>
<p>The sorted range must each be arranged as a precondition to the application of the <code>binary_search</code> algorithm in accordance with the same ordering as is to be used by the algorithm to sort the combined ranges.</p>
<p>The source ranges are not modified by <code>binary_search</code>.</p>
<p>The value types of the forward iterators need to be less-than comparable to be ordered, so that, given two elements, it may be determined either that they are equivalent (in the sense that neither is less than the other) or that one is less than the other. This results in an ordering between the nonequivalent elements</p>
<p>The complexity of the algorithm is logarithmic for random-access iterators and linear otherwise, with the number of steps proportional to (<code>last</code> - <code>first</code>).</p>
<h3 id="example-1" class="heading-with-anchor">Example<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#example-1"></a></h3>
<div class="codeHeader" id="code-try-6" data-bi-name="code-header"><span class="language">C++</span>
			<button class="action" data-bi-name="copy">
				<span class="docon docon-edit-copy" role="presentation"></span>
				<span>Copy</span>
			</button></div><pre><code class="lang-cpp" data-author-content="// alg_bin_srch.cpp
// compile with: /EHsc
#include &lt;list&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;functional&gt;      // greater&lt;int&gt;( )
#include &lt;iostream&gt;

// Return whether modulus of elem1 is less than modulus of elem2
bool mod_lesser( int elem1, int elem2 )
{
    if (elem1 &lt; 0)
        elem1 = - elem1;
    if (elem2 &lt; 0)
        elem2 = - elem2;
    return elem1 &lt; elem2;
}

int main()
{
    using namespace std;

    list &lt;int&gt; List1;

    List1.push_back( 50 );
    List1.push_back( 10 );
    List1.push_back( 30 );
    List1.push_back( 20 );
    List1.push_back( 25 );
    List1.push_back( 5 );

    List1.sort();

    cout &lt;&lt; &quot;List1 = ( &quot; ;
    for ( auto Iter : List1 )
        cout &lt;&lt; Iter &lt;&lt; &quot; &quot;;
    cout &lt;&lt; &quot;)&quot; &lt;&lt; endl;

    // default binary search for 10
    if ( binary_search(List1.begin(), List1.end(), 10) )
        cout &lt;&lt; &quot;There is an element in list List1 with a value equal to 10.&quot;
        &lt;&lt; endl;
    else
        cout &lt;&lt; &quot;There is no element in list List1 with a value equal to 10.&quot;
        &lt;&lt; endl;

    // a binary_search under the binary predicate greater
    List1.sort(greater&lt;int&gt;());
    if ( binary_search(List1.begin(), List1.end(), 10, greater&lt;int&gt;()) )
        cout &lt;&lt; &quot;There is an element in list List1 with a value greater than 10 &quot;
        &lt;&lt; &quot;under greater than.&quot; &lt;&lt; endl;
    else
        cout &lt;&lt; &quot;No element in list List1 with a value greater than 10 &quot;
        &lt;&lt; &quot;under greater than.&quot; &lt;&lt; endl;

    // a binary_search under the user-defined binary predicate mod_lesser
    vector&lt;int&gt; v1;

    for ( auto i = -2; i &lt;= 4; ++i )
    {
        v1.push_back(i);
    }

    sort(v1.begin(), v1.end(), mod_lesser);

    cout &lt;&lt; &quot;Ordered using mod_lesser, vector v1 = ( &quot; ;
    for ( auto Iter : v1 )
        cout &lt;&lt; Iter &lt;&lt; &quot; &quot;;
    cout &lt;&lt; &quot;)&quot; &lt;&lt; endl;

    if ( binary_search(v1.begin(), v1.end(), -3, mod_lesser) )
        cout &lt;&lt; &quot;There is an element with a value equivalent to -3 &quot;
        &lt;&lt; &quot;under mod_lesser.&quot; &lt;&lt; endl;
    else
        cout &lt;&lt; &quot;There is not an element with a value equivalent to -3 &quot;
        &lt;&lt; &quot;under mod_lesser.&quot; &lt;&lt; endl;
}
"><span class="hljs-comment">// alg_bin_srch.cpp</span>
<span class="hljs-comment">// compile with: /EHsc</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;list&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;functional&gt;      // greater&lt;int&gt;( )</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span>

<span class="hljs-comment">// Return whether modulus of elem1 is less than modulus of elem2</span>
<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">mod_lesser</span><span class="hljs-params">( <span class="hljs-keyword">int</span> elem1, <span class="hljs-keyword">int</span> elem2 )</span>
</span>{
    <span class="hljs-keyword">if</span> (elem1 &lt; <span class="hljs-number">0</span>)
        elem1 = - elem1;
    <span class="hljs-keyword">if</span> (elem2 &lt; <span class="hljs-number">0</span>)
        elem2 = - elem2;
    <span class="hljs-keyword">return</span> elem1 &lt; elem2;
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;

    <span class="hljs-built_in">list</span> &lt;<span class="hljs-keyword">int</span>&gt; List1;

    List1.push_back( <span class="hljs-number">50</span> );
    List1.push_back( <span class="hljs-number">10</span> );
    List1.push_back( <span class="hljs-number">30</span> );
    List1.push_back( <span class="hljs-number">20</span> );
    List1.push_back( <span class="hljs-number">25</span> );
    List1.push_back( <span class="hljs-number">5</span> );

    List1.sort();

    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"List1 = ( "</span> ;
    <span class="hljs-keyword">for</span> ( <span class="hljs-keyword">auto</span> Iter : List1 )
        <span class="hljs-built_in">cout</span> &lt;&lt; Iter &lt;&lt; <span class="hljs-string">" "</span>;
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">")"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;

    <span class="hljs-comment">// default binary search for 10</span>
    <span class="hljs-keyword">if</span> ( binary_search(List1.begin(), List1.end(), <span class="hljs-number">10</span>) )
        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"There is an element in list List1 with a value equal to 10."</span>
        &lt;&lt; <span class="hljs-built_in">endl</span>;
    <span class="hljs-keyword">else</span>
        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"There is no element in list List1 with a value equal to 10."</span>
        &lt;&lt; <span class="hljs-built_in">endl</span>;

    <span class="hljs-comment">// a binary_search under the binary predicate greater</span>
    List1.sort(greater&lt;<span class="hljs-keyword">int</span>&gt;());
    <span class="hljs-keyword">if</span> ( binary_search(List1.begin(), List1.end(), <span class="hljs-number">10</span>, greater&lt;<span class="hljs-keyword">int</span>&gt;()) )
        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"There is an element in list List1 with a value greater than 10 "</span>
        &lt;&lt; <span class="hljs-string">"under greater than."</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
    <span class="hljs-keyword">else</span>
        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"No element in list List1 with a value greater than 10 "</span>
        &lt;&lt; <span class="hljs-string">"under greater than."</span> &lt;&lt; <span class="hljs-built_in">endl</span>;

    <span class="hljs-comment">// a binary_search under the user-defined binary predicate mod_lesser</span>
    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; v1;

    <span class="hljs-keyword">for</span> ( <span class="hljs-keyword">auto</span> i = <span class="hljs-number">-2</span>; i &lt;= <span class="hljs-number">4</span>; ++i )
    {
        v1.push_back(i);
    }

    sort(v1.begin(), v1.end(), mod_lesser);

    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Ordered using mod_lesser, vector v1 = ( "</span> ;
    <span class="hljs-keyword">for</span> ( <span class="hljs-keyword">auto</span> Iter : v1 )
        <span class="hljs-built_in">cout</span> &lt;&lt; Iter &lt;&lt; <span class="hljs-string">" "</span>;
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">")"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;

    <span class="hljs-keyword">if</span> ( binary_search(v1.begin(), v1.end(), <span class="hljs-number">-3</span>, mod_lesser) )
        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"There is an element with a value equivalent to -3 "</span>
        &lt;&lt; <span class="hljs-string">"under mod_lesser."</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
    <span class="hljs-keyword">else</span>
        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"There is not an element with a value equivalent to -3 "</span>
        &lt;&lt; <span class="hljs-string">"under mod_lesser."</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
}
</code></pre>
<h2 id="copy" class="heading-with-anchor">  copy<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#copy"></a></h2>
<p>Assigns the values of elements from a source range to a destination range, iterating through the source sequence of elements and assigning them new positions in a forward direction.</p>
<div class="codeHeader" id="code-try-7" data-bi-name="code-header"><span class="language">C++</span>
			<button class="action" data-bi-name="copy">
				<span class="docon docon-edit-copy" role="presentation"></span>
				<span>Copy</span>
			</button></div><pre><code class="lang-cpp" data-author-content="template&lt;class InputIterator, class OutputIterator&gt;
OutputIterator copy(
    InputIterator first,
    InputIterator last,
    OutputIterator destBeg);
"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InputIterator</span>, <span class="hljs-title">class</span> <span class="hljs-title">OutputIterator</span>&gt;
<span class="hljs-title">OutputIterator</span> <span class="hljs-title">copy</span>(
    <span class="hljs-title">InputIterator</span> <span class="hljs-title">first</span>,
    <span class="hljs-title">InputIterator</span> <span class="hljs-title">last</span>,
    <span class="hljs-title">OutputIterator</span> <span class="hljs-title">destBeg</span>);</span>
</code></pre>
<h3 id="parameters-4" class="heading-with-anchor">Parameters<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#parameters-4"></a></h3>
<p><em>first</em><br>
An input iterator addressing the position of the first element in the source range.</p>
<p><em>last</em><br>
An input iterator addressing the position that is one past the final element in the source range.</p>
<p><em>destBeg</em><br>
An output iterator addressing the position of the first element in the destination range.</p>
<h3 id="return-value-4" class="heading-with-anchor">Return Value<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#return-value-4"></a></h3>
<p>An output iterator addressing the position that is one past the final element in the destination range, that is, the iterator addresses <code>result</code> + (<em>last</em> - <em>first</em>).</p>
<h3 id="remarks-4" class="heading-with-anchor">Remarks<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#remarks-4"></a></h3>
<p>The source range must be valid and there must be sufficient space at the destination to hold all the elements being copied.</p>
<p>Because the algorithm copies the source elements in order beginning with the first element, the destination range can overlap with the source range provided the <em>last</em> position of the source range is not contained in the destination range. <code>copy</code> can be used to shift elements to the left but not the right, unless there is no overlap between the source and destination ranges. To shift to the right any number of positions, use the <a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#copy_backward" data-linktype="relative-path">copy_backward</a> algorithm.</p>
<p>The <code>copy</code> algorithm only modifies values pointed to by the iterators, assigning new values to elements in the destination range. It cannot be used to create new elements and cannot insert elements into an empty container directly.</p>
<h3 id="example-2" class="heading-with-anchor">Example<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#example-2"></a></h3>
<div class="codeHeader" id="code-try-8" data-bi-name="code-header"><span class="language">C++</span>
			<button class="action" data-bi-name="copy">
				<span class="docon docon-edit-copy" role="presentation"></span>
				<span>Copy</span>
			</button></div><pre><code class="lang-cpp" data-author-content="// alg_copy.cpp
// compile with: /EHsc
#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;iostream&gt;

int main() {
   using namespace std;
   vector &lt;int&gt; v1, v2;
   vector &lt;int&gt;::iterator Iter1, Iter2;

   int i;
   for ( i = 0 ; i &lt;= 5 ; i++ )
      v1.push_back( 10 * i );

   int ii;
   for ( ii = 0 ; ii &lt;= 10 ; ii++ )
      v2.push_back( 3 * ii );

   cout &lt;&lt; &quot;v1 = ( &quot; ;
   for ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ; Iter1++ )
      cout &lt;&lt; *Iter1 &lt;&lt; &quot; &quot;;
   cout &lt;&lt; &quot;)&quot; &lt;&lt; endl;

   cout &lt;&lt; &quot;v2 = ( &quot; ;
   for ( Iter2 = v2.begin( ) ; Iter2 != v2.end( ) ; Iter2++ )
      cout &lt;&lt; *Iter2 &lt;&lt; &quot; &quot;;
   cout &lt;&lt; &quot;)&quot; &lt;&lt; endl;

   // To copy the first 3 elements of v1 into the middle of v2
   copy( v1.begin( ), v1.begin( ) + 3, v2.begin( ) + 4 );

   cout &lt;&lt; &quot;v2 with v1 insert = ( &quot; ;
   for ( Iter2 = v2.begin( ) ; Iter2 != v2.end( ) ; Iter2++ )
      cout &lt;&lt; *Iter2 &lt;&lt; &quot; &quot;;
   cout &lt;&lt; &quot;)&quot; &lt;&lt; endl;

   // To shift the elements inserted into v2 two positions
   // to the left
   copy( v2.begin( )+4, v2.begin( ) + 7, v2.begin( ) + 2 );

   cout &lt;&lt; &quot;v2 with shifted insert = ( &quot; ;
   for ( Iter2 = v2.begin( ) ; Iter2 != v2.end( ) ; Iter2++ )
      cout &lt;&lt; *Iter2 &lt;&lt; &quot; &quot;;
   cout &lt;&lt; &quot;)&quot; &lt;&lt; endl;
}
"><span class="hljs-comment">// alg_copy.cpp</span>
<span class="hljs-comment">// compile with: /EHsc</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span>

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
   <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;
   <span class="hljs-built_in">vector</span> &lt;<span class="hljs-keyword">int</span>&gt; v1, v2;
   <span class="hljs-built_in">vector</span> &lt;<span class="hljs-keyword">int</span>&gt;::iterator Iter1, Iter2;

   <span class="hljs-keyword">int</span> i;
   <span class="hljs-keyword">for</span> ( i = <span class="hljs-number">0</span> ; i &lt;= <span class="hljs-number">5</span> ; i++ )
      v1.push_back( <span class="hljs-number">10</span> * i );

   <span class="hljs-keyword">int</span> ii;
   <span class="hljs-keyword">for</span> ( ii = <span class="hljs-number">0</span> ; ii &lt;= <span class="hljs-number">10</span> ; ii++ )
      v2.push_back( <span class="hljs-number">3</span> * ii );

   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"v1 = ( "</span> ;
   <span class="hljs-keyword">for</span> ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ; Iter1++ )
      <span class="hljs-built_in">cout</span> &lt;&lt; *Iter1 &lt;&lt; <span class="hljs-string">" "</span>;
   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">")"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;

   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"v2 = ( "</span> ;
   <span class="hljs-keyword">for</span> ( Iter2 = v2.begin( ) ; Iter2 != v2.end( ) ; Iter2++ )
      <span class="hljs-built_in">cout</span> &lt;&lt; *Iter2 &lt;&lt; <span class="hljs-string">" "</span>;
   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">")"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;

   <span class="hljs-comment">// To copy the first 3 elements of v1 into the middle of v2</span>
   copy( v1.begin( ), v1.begin( ) + <span class="hljs-number">3</span>, v2.begin( ) + <span class="hljs-number">4</span> );

   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"v2 with v1 insert = ( "</span> ;
   <span class="hljs-keyword">for</span> ( Iter2 = v2.begin( ) ; Iter2 != v2.end( ) ; Iter2++ )
      <span class="hljs-built_in">cout</span> &lt;&lt; *Iter2 &lt;&lt; <span class="hljs-string">" "</span>;
   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">")"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;

   <span class="hljs-comment">// To shift the elements inserted into v2 two positions</span>
   <span class="hljs-comment">// to the left</span>
   copy( v2.begin( )+<span class="hljs-number">4</span>, v2.begin( ) + <span class="hljs-number">7</span>, v2.begin( ) + <span class="hljs-number">2</span> );

   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"v2 with shifted insert = ( "</span> ;
   <span class="hljs-keyword">for</span> ( Iter2 = v2.begin( ) ; Iter2 != v2.end( ) ; Iter2++ )
      <span class="hljs-built_in">cout</span> &lt;&lt; *Iter2 &lt;&lt; <span class="hljs-string">" "</span>;
   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">")"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
}
</code></pre>
<div class="codeHeader" id="code-try-9" data-bi-name="code-header"><span class="language">Output</span>
			<button class="action" data-bi-name="copy">
				<span class="docon docon-edit-copy" role="presentation"></span>
				<span>Copy</span>
			</button></div><pre><code class="lang-Output" data-author-content="v1 = ( 0 10 20 30 40 50 )
v2 = ( 0 3 6 9 12 15 18 21 24 27 30 )
v2 with v1 insert = ( 0 3 6 9 0 10 20 21 24 27 30 )
v2 with shifted insert = ( 0 3 0 10 20 10 20 21 24 27 30 )
">v1 = ( 0 10 20 30 40 50 )
v2 = ( 0 3 6 9 12 15 18 21 24 27 30 )
v2 with v1 insert = ( 0 3 6 9 0 10 20 21 24 27 30 )
v2 with shifted insert = ( 0 3 0 10 20 10 20 21 24 27 30 )
</code></pre>
<h2 id="copy_backward" class="heading-with-anchor">  copy_backward<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#copy_backward"></a></h2>
<p>Assigns the values of elements from a source range to a destination range, iterating through the source sequence of elements and assigning them new positions in a backward direction.</p>
<div class="codeHeader" id="code-try-10" data-bi-name="code-header"><span class="language">C++</span>
			<button class="action" data-bi-name="copy">
				<span class="docon docon-edit-copy" role="presentation"></span>
				<span>Copy</span>
			</button></div><pre><code class="lang-cpp" data-author-content="template&lt;class BidirectionalIterator1, class BidirectionalIterator2&gt;
BidirectionalIterator2 copy_backward(
    BidirectionalIterator1 first,
    BidirectionalIterator1 last,
    BidirectionalIterator2 destEnd);
"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BidirectionalIterator1</span>, <span class="hljs-title">class</span> <span class="hljs-title">BidirectionalIterator2</span>&gt;
<span class="hljs-title">BidirectionalIterator2</span> <span class="hljs-title">copy_backward</span>(
    <span class="hljs-title">BidirectionalIterator1</span> <span class="hljs-title">first</span>,
    <span class="hljs-title">BidirectionalIterator1</span> <span class="hljs-title">last</span>,
    <span class="hljs-title">BidirectionalIterator2</span> <span class="hljs-title">destEnd</span>);</span>
</code></pre>
<h3 id="parameters-5" class="heading-with-anchor">Parameters<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#parameters-5"></a></h3>
<p><em>first</em><br>
A bidirectional iterator addressing the position of the first element in the source range.</p>
<p><em>last</em><br>
A bidirectional iterator addressing the position that is one past the final element in the source range.</p>
<p><em>destEnd</em><br>
A bidirectional iterator addressing the position of one past the final element in the destination range.</p>
<h3 id="return-value-5" class="heading-with-anchor">Return Value<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#return-value-5"></a></h3>
<p>An output iterator addressing the position that is one past the final element in the destination range, that is, the iterator addresses <em>destEnd</em> - (<em>last</em> - <em>first</em>).</p>
<h3 id="remarks-5" class="heading-with-anchor">Remarks<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#remarks-5"></a></h3>
<p>The source range must be valid and there must be sufficient space at the destination to hold all the elements being copied.</p>
<p>The <code>copy_backward</code> algorithm imposes more stringent requirements than that the copy algorithm. Both its input and output iterators must be bidirectional.</p>
<p>The <code>copy_backward</code> and <a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#move_backward" data-linktype="relative-path">move_backward</a> algorithms are the only C++ Standard Library algorithms designating the output range with an iterator pointing to the end of the destination range.</p>
<p>Because the algorithm copies the source elements in order beginning with the last element, the destination range can overlap with the source range provided the  <em>first</em> position of the source range is not contained in the destination range. <code>copy_backward</code> can be used to shift elements to the right but not the left, unless there is no overlap between the source and destination ranges. To shift to the left any number of positions, use the <a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#copy" data-linktype="relative-path">copy</a> algorithm.</p>
<p>The <code>copy_backward</code> algorithm only modifies values pointed to by the iterators, assigning new values to elements in the destination range. It cannot be used to create new elements and cannot insert elements into an empty container directly.</p>
<h3 id="example-3" class="heading-with-anchor">Example<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#example-3"></a></h3>
<div class="codeHeader" id="code-try-11" data-bi-name="code-header"><span class="language">C++</span>
			<button class="action" data-bi-name="copy">
				<span class="docon docon-edit-copy" role="presentation"></span>
				<span>Copy</span>
			</button></div><pre><code class="lang-cpp" data-author-content="// alg_copy_bkwd.cpp
// compile with: /EHsc
#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;iostream&gt;

int main() {
   using namespace std;
   vector &lt;int&gt; v1, v2;
   vector &lt;int&gt;::iterator Iter1, Iter2;

   int i;
   for ( i = 0 ; i &lt;= 5 ; ++i )
      v1.push_back( 10 * i );

   int ii;
   for ( ii = 0 ; ii &lt;= 10 ; ++ii )
      v2.push_back( 3 * ii );

   cout &lt;&lt; &quot;v1 = ( &quot; ;
   for ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ; ++Iter1 )
      cout &lt;&lt; *Iter1 &lt;&lt; &quot; &quot;;
   cout &lt;&lt; &quot;)&quot; &lt;&lt; endl;

   cout &lt;&lt; &quot;v2 = ( &quot; ;
   for ( Iter2 = v2.begin( ) ; Iter2 != v2.end( ) ; ++Iter2 )
      cout &lt;&lt; *Iter2 &lt;&lt; &quot; &quot;;
   cout &lt;&lt; &quot;)&quot; &lt;&lt; endl;

   // To copy_backward the first 3 elements of v1 into the middle of v2
   copy_backward( v1.begin( ), v1.begin( ) + 3, v2.begin( ) + 7 );

   cout &lt;&lt; &quot;v2 with v1 insert = ( &quot; ;
   for ( Iter2 = v2.begin( ) ; Iter2 != v2.end( ) ; ++Iter2 )
      cout &lt;&lt; *Iter2 &lt;&lt; &quot; &quot;;
   cout &lt;&lt; &quot;)&quot; &lt;&lt; endl;

   // To shift the elements inserted into v2 two positions
   // to the right
   copy_backward( v2.begin( )+4, v2.begin( ) + 7, v2.begin( ) + 9 );

   cout &lt;&lt; &quot;v2 with shifted insert = ( &quot; ;
   for ( Iter2 = v2.begin( ) ; Iter2 != v2.end( ) ; ++Iter2 )
      cout &lt;&lt; *Iter2 &lt;&lt; &quot; &quot;;
   cout &lt;&lt; &quot;)&quot; &lt;&lt; endl;
}
"><span class="hljs-comment">// alg_copy_bkwd.cpp</span>
<span class="hljs-comment">// compile with: /EHsc</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span>

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
   <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;
   <span class="hljs-built_in">vector</span> &lt;<span class="hljs-keyword">int</span>&gt; v1, v2;
   <span class="hljs-built_in">vector</span> &lt;<span class="hljs-keyword">int</span>&gt;::iterator Iter1, Iter2;

   <span class="hljs-keyword">int</span> i;
   <span class="hljs-keyword">for</span> ( i = <span class="hljs-number">0</span> ; i &lt;= <span class="hljs-number">5</span> ; ++i )
      v1.push_back( <span class="hljs-number">10</span> * i );

   <span class="hljs-keyword">int</span> ii;
   <span class="hljs-keyword">for</span> ( ii = <span class="hljs-number">0</span> ; ii &lt;= <span class="hljs-number">10</span> ; ++ii )
      v2.push_back( <span class="hljs-number">3</span> * ii );

   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"v1 = ( "</span> ;
   <span class="hljs-keyword">for</span> ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ; ++Iter1 )
      <span class="hljs-built_in">cout</span> &lt;&lt; *Iter1 &lt;&lt; <span class="hljs-string">" "</span>;
   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">")"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;

   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"v2 = ( "</span> ;
   <span class="hljs-keyword">for</span> ( Iter2 = v2.begin( ) ; Iter2 != v2.end( ) ; ++Iter2 )
      <span class="hljs-built_in">cout</span> &lt;&lt; *Iter2 &lt;&lt; <span class="hljs-string">" "</span>;
   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">")"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;

   <span class="hljs-comment">// To copy_backward the first 3 elements of v1 into the middle of v2</span>
   copy_backward( v1.begin( ), v1.begin( ) + <span class="hljs-number">3</span>, v2.begin( ) + <span class="hljs-number">7</span> );

   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"v2 with v1 insert = ( "</span> ;
   <span class="hljs-keyword">for</span> ( Iter2 = v2.begin( ) ; Iter2 != v2.end( ) ; ++Iter2 )
      <span class="hljs-built_in">cout</span> &lt;&lt; *Iter2 &lt;&lt; <span class="hljs-string">" "</span>;
   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">")"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;

   <span class="hljs-comment">// To shift the elements inserted into v2 two positions</span>
   <span class="hljs-comment">// to the right</span>
   copy_backward( v2.begin( )+<span class="hljs-number">4</span>, v2.begin( ) + <span class="hljs-number">7</span>, v2.begin( ) + <span class="hljs-number">9</span> );

   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"v2 with shifted insert = ( "</span> ;
   <span class="hljs-keyword">for</span> ( Iter2 = v2.begin( ) ; Iter2 != v2.end( ) ; ++Iter2 )
      <span class="hljs-built_in">cout</span> &lt;&lt; *Iter2 &lt;&lt; <span class="hljs-string">" "</span>;
   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">")"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
}
</code></pre>
<h2 id="copy_if" class="heading-with-anchor">  copy_if<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#copy_if"></a></h2>
<p>In a range of elements, copies the elements that are <strong>true</strong> for the specified condition.</p>
<div class="codeHeader" id="code-try-12" data-bi-name="code-header"><span class="language">C++</span>
			<button class="action" data-bi-name="copy">
				<span class="docon docon-edit-copy" role="presentation"></span>
				<span>Copy</span>
			</button></div><pre><code class="lang-cpp" data-author-content="template&lt;class InputIterator, class OutputIterator, class BinaryPredicate&gt;
OutputIterator copy_if(
    InputIterator first,
    InputIterator last,
    OutputIterator dest,
    Predicate pred);
"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InputIterator</span>, <span class="hljs-title">class</span> <span class="hljs-title">OutputIterator</span>, <span class="hljs-title">class</span> <span class="hljs-title">BinaryPredicate</span>&gt;
<span class="hljs-title">OutputIterator</span> <span class="hljs-title">copy_if</span>(
    <span class="hljs-title">InputIterator</span> <span class="hljs-title">first</span>,
    <span class="hljs-title">InputIterator</span> <span class="hljs-title">last</span>,
    <span class="hljs-title">OutputIterator</span> <span class="hljs-title">dest</span>,
    <span class="hljs-title">Predicate</span> <span class="hljs-title">pred</span>);</span>
</code></pre>
<h3 id="parameters-6" class="heading-with-anchor">Parameters<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#parameters-6"></a></h3>
<p><em>first</em><br>
An input iterator that indicates the start of a range to check for the condition.</p>
<p><em>last</em><br>
An input iterator that indicates the end of the range.</p>
<p><em>dest</em><br>
The output iterator that indicates the destination for the copied elements.</p>
<p><em>_Pred</em><br>
The condition against which every element in the range is tested. This condition is provided by a user-defined predicate function object. A predicate takes one argument and returns <strong>true</strong> or <strong>false</strong>.</p>
<h3 id="return-value-6" class="heading-with-anchor">Return Value<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#return-value-6"></a></h3>
<p>An output iterator that equals <em>dest</em> incremented once for each element that fulfills the condition. In other words, the return value minus <em>dest</em> equals the number of copied elements.</p>
<h3 id="remarks-6" class="heading-with-anchor">Remarks<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#remarks-6"></a></h3>
<p>The template function evaluates</p>
<p><code>if (pred(*_First + N)) * dest++ = *(_First + N))</code></p>
<p>once for each <code>N</code> in the range <code>[0, last - first)</code>, for strictly increasing values of <code>N</code> starting with the lowest value. If <em>dest</em> and <em>first</em> designate regions of storage, <em>dest</em> must not be in the range <code>[ first, last )</code>.</p>
<h2 id="copy_n" class="heading-with-anchor">  copy_n<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#copy_n"></a></h2>
<p>Copies a specified number of elements.</p>
<div class="codeHeader" id="code-try-13" data-bi-name="code-header"><span class="language">C++</span>
			<button class="action" data-bi-name="copy">
				<span class="docon docon-edit-copy" role="presentation"></span>
				<span>Copy</span>
			</button></div><pre><code class="lang-cpp" data-author-content="template&lt;class InputIterator, class Size, class OutputIterator&gt;
OutputIterator copy_n(
    InputIterator first,
    Size count,
    OutputIterator dest);
"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InputIterator</span>, <span class="hljs-title">class</span> <span class="hljs-title">Size</span>, <span class="hljs-title">class</span> <span class="hljs-title">OutputIterator</span>&gt;
<span class="hljs-title">OutputIterator</span> <span class="hljs-title">copy_n</span>(
    <span class="hljs-title">InputIterator</span> <span class="hljs-title">first</span>,
    <span class="hljs-title">Size</span> <span class="hljs-title">count</span>,
    <span class="hljs-title">OutputIterator</span> <span class="hljs-title">dest</span>);</span>
</code></pre>
<h3 id="parameters-7" class="heading-with-anchor">Parameters<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#parameters-7"></a></h3>
<p><em>first</em><br>
An input iterator that indicates where to copy elements from.</p>
<p><em>count</em><br>
A signed or unsigned integer type specifying the number of elements to copy.</p>
<p><em>dest</em><br>
An output iterator that indicates where to copy elements to.</p>
<h3 id="return-value-7" class="heading-with-anchor">Return Value<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#return-value-7"></a></h3>
<p>Returns an output iterator where elements have been copied to. It is the same as the returned value of the third parameter, <em>dest</em>.</p>
<h3 id="remarks-7" class="heading-with-anchor">Remarks<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#remarks-7"></a></h3>
<p>The template function evaluates <code>*(dest + N) = *(first + N))</code> once for each <code>N</code> in the range <code>[0, count)</code>, for strictly increasing values of <code>N</code> starting with the lowest value. It then returns <code>dest + N</code>. If <em>dest</em> and <em>first</em> designate regions of storage, <em>dest</em> must not be in the range <code>[first, last)</code>.</p>
<h2 id="count" class="heading-with-anchor">  count<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#count"></a></h2>
<p>Returns the number of elements in a range whose values match a specified value.</p>
<div class="codeHeader" id="code-try-14" data-bi-name="code-header"><span class="language">C++</span>
			<button class="action" data-bi-name="copy">
				<span class="docon docon-edit-copy" role="presentation"></span>
				<span>Copy</span>
			</button></div><pre><code class="lang-cpp" data-author-content="template&lt;class InputIterator, class Type&gt;
typename iterator_traits&lt;InputIterator&gt;::difference_type count(
    InputIterator first,
    InputIterator last,
    const Type&amp; val);
"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InputIterator</span>, <span class="hljs-title">class</span> <span class="hljs-title">Type</span>&gt;
<span class="hljs-title">typename</span> <span class="hljs-title">iterator_traits</span>&lt;InputIterator&gt;:</span>:<span class="hljs-function">difference_type <span class="hljs-title">count</span><span class="hljs-params">(
    InputIterator first,
    InputIterator last,
    <span class="hljs-keyword">const</span> Type&amp; val)</span></span>;
</code></pre>
<h3 id="parameters-8" class="heading-with-anchor">Parameters<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#parameters-8"></a></h3>
<p><em>first</em><br>
An input iterator addressing the position of the first element in the range to be traversed.</p>
<p><em>last</em><br>
An input iterator addressing the position one past the final element in the range to be traversed.</p>
<p><em>val</em><br>
The value of the elements to be counted.</p>
<h3 id="return-value-8" class="heading-with-anchor">Return Value<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#return-value-8"></a></h3>
<p>The difference type of the <code>InputIterator</code> that counts the number of elements in the range [  <em>first</em>, <em>last</em> ) that have value <em>val</em>.</p>
<h3 id="remarks-8" class="heading-with-anchor">Remarks<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#remarks-8"></a></h3>
<p>The <code>operator==</code> used to determine the match between an element and the specified value must impose an equivalence relation between its operands.</p>
<p>This algorithm is generalized to count elements that satisfy any predicate with the template function <a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#count_if" data-linktype="relative-path">count_if</a>.</p>
<h3 id="example-4" class="heading-with-anchor">Example<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#example-4"></a></h3>
<div class="codeHeader" id="code-try-15" data-bi-name="code-header"><span class="language">C++</span>
			<button class="action" data-bi-name="copy">
				<span class="docon docon-edit-copy" role="presentation"></span>
				<span>Copy</span>
			</button></div><pre><code class="lang-cpp" data-author-content="// alg_count.cpp
// compile with: /EHsc
#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;iostream&gt;

int main()
{
    using namespace std;
    vector&lt;int&gt; v1;
    vector&lt;int&gt;::iterator Iter;

    v1.push_back(10);
    v1.push_back(20);
    v1.push_back(10);
    v1.push_back(40);
    v1.push_back(10);

    cout &lt;&lt; &quot;v1 = ( &quot; ;
    for (Iter = v1.begin(); Iter != v1.end(); Iter++)
        cout &lt;&lt; *Iter &lt;&lt; &quot; &quot;;
    cout &lt;&lt; &quot;)&quot; &lt;&lt; endl;

    vector&lt;int&gt;::iterator::difference_type result;
    result = count(v1.begin(), v1.end(), 10);
    cout &lt;&lt; &quot;The number of 10s in v2 is: &quot; &lt;&lt; result &lt;&lt; &quot;.&quot; &lt;&lt; endl;
}
"><span class="hljs-comment">// alg_count.cpp</span>
<span class="hljs-comment">// compile with: /EHsc</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span>

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;
    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; v1;
    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;::iterator Iter;

    v1.push_back(<span class="hljs-number">10</span>);
    v1.push_back(<span class="hljs-number">20</span>);
    v1.push_back(<span class="hljs-number">10</span>);
    v1.push_back(<span class="hljs-number">40</span>);
    v1.push_back(<span class="hljs-number">10</span>);

    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"v1 = ( "</span> ;
    <span class="hljs-keyword">for</span> (Iter = v1.begin(); Iter != v1.end(); Iter++)
        <span class="hljs-built_in">cout</span> &lt;&lt; *Iter &lt;&lt; <span class="hljs-string">" "</span>;
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">")"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;

    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;::iterator::difference_type result;
    result = count(v1.begin(), v1.end(), <span class="hljs-number">10</span>);
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"The number of 10s in v2 is: "</span> &lt;&lt; result &lt;&lt; <span class="hljs-string">"."</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
}
</code></pre>
<div class="codeHeader" id="code-try-16" data-bi-name="code-header"><span class="language">Output</span>
			<button class="action" data-bi-name="copy">
				<span class="docon docon-edit-copy" role="presentation"></span>
				<span>Copy</span>
			</button></div><pre><code class="lang-Output" data-author-content="v1 = ( 10 20 10 40 10 )
The number of 10s in v2 is: 3.
">v1 = ( 10 20 10 40 10 )
The number of 10s in v2 is: 3.
</code></pre>
<h2 id="count_if" class="heading-with-anchor">  count_if<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#count_if"></a></h2>
<p>Returns the number of elements in a range whose values satisfy a specified condition.</p>
<div class="codeHeader" id="code-try-17" data-bi-name="code-header"><span class="language">C++</span>
			<button class="action" data-bi-name="copy">
				<span class="docon docon-edit-copy" role="presentation"></span>
				<span>Copy</span>
			</button></div><pre><code class="lang-cpp" data-author-content="template&lt;class InputIterator, class Predicate&gt;
typename iterator_traits&lt;InputIterator&gt;::difference_type count_if(
    InputIterator first,
    InputIterator last,
    Predicate pred);
"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InputIterator</span>, <span class="hljs-title">class</span> <span class="hljs-title">Predicate</span>&gt;
<span class="hljs-title">typename</span> <span class="hljs-title">iterator_traits</span>&lt;InputIterator&gt;:</span>:<span class="hljs-function">difference_type <span class="hljs-title">count_if</span><span class="hljs-params">(
    InputIterator first,
    InputIterator last,
    Predicate pred)</span></span>;
</code></pre>
<h3 id="parameters-9" class="heading-with-anchor">Parameters<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#parameters-9"></a></h3>
<p><em>first</em><br>
An input iterator addressing the position of the first element in the range to be searched.</p>
<p><em>last</em><br>
An input iterator addressing the position one past the final element in the range to be searched.</p>
<p><em>_Pred</em><br>
User-defined predicate function object that defines the condition to be satisfied if an element is to be counted. A predicate takes single argument and returns <strong>true</strong> or <strong>false</strong>.</p>
<h3 id="return-value-9" class="heading-with-anchor">Return Value<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#return-value-9"></a></h3>
<p>The number of elements that satisfy the condition specified by the predicate.</p>
<h3 id="remarks-9" class="heading-with-anchor">Remarks<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#remarks-9"></a></h3>
<p>This template function is a generalization of the algorithm <a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#count" data-linktype="relative-path">count</a>, replacing the predicate "equals a specific value" with any predicate.</p>
<h3 id="example-5" class="heading-with-anchor">Example<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#example-5"></a></h3>
<div class="codeHeader" id="code-try-18" data-bi-name="code-header"><span class="language">C++</span>
			<button class="action" data-bi-name="copy">
				<span class="docon docon-edit-copy" role="presentation"></span>
				<span>Copy</span>
			</button></div><pre><code class="lang-cpp" data-author-content="// alg_count_if.cpp
// compile with: /EHsc
#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;iostream&gt;

bool greater10(int value)
{
    return value &gt; 10;
}

int main()
{
    using namespace std;
    vector&lt;int&gt; v1;
    vector&lt;int&gt;::iterator Iter;

    v1.push_back(10);
    v1.push_back(20);
    v1.push_back(10);
    v1.push_back(40);
    v1.push_back(10);

    cout &lt;&lt; &quot;v1 = ( &quot;;
    for (Iter = v1.begin(); Iter != v1.end(); Iter++)
        cout &lt;&lt; *Iter &lt;&lt; &quot; &quot;;
    cout &lt;&lt; &quot;)&quot; &lt;&lt; endl;

    vector&lt;int&gt;::iterator::difference_type result1;
    result1 = count_if(v1.begin(), v1.end(), greater10);
    cout &lt;&lt; &quot;The number of elements in v1 greater than 10 is: &quot;
         &lt;&lt; result1 &lt;&lt; &quot;.&quot; &lt;&lt; endl;
}
"><span class="hljs-comment">// alg_count_if.cpp</span>
<span class="hljs-comment">// compile with: /EHsc</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span>

<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">greater10</span><span class="hljs-params">(<span class="hljs-keyword">int</span> value)</span>
</span>{
    <span class="hljs-keyword">return</span> value &gt; <span class="hljs-number">10</span>;
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;
    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; v1;
    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;::iterator Iter;

    v1.push_back(<span class="hljs-number">10</span>);
    v1.push_back(<span class="hljs-number">20</span>);
    v1.push_back(<span class="hljs-number">10</span>);
    v1.push_back(<span class="hljs-number">40</span>);
    v1.push_back(<span class="hljs-number">10</span>);

    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"v1 = ( "</span>;
    <span class="hljs-keyword">for</span> (Iter = v1.begin(); Iter != v1.end(); Iter++)
        <span class="hljs-built_in">cout</span> &lt;&lt; *Iter &lt;&lt; <span class="hljs-string">" "</span>;
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">")"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;

    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;::iterator::difference_type result1;
    result1 = count_if(v1.begin(), v1.end(), greater10);
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"The number of elements in v1 greater than 10 is: "</span>
         &lt;&lt; result1 &lt;&lt; <span class="hljs-string">"."</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
}
</code></pre>
<div class="codeHeader" id="code-try-19" data-bi-name="code-header"><span class="language">Output</span>
			<button class="action" data-bi-name="copy">
				<span class="docon docon-edit-copy" role="presentation"></span>
				<span>Copy</span>
			</button></div><pre><code class="lang-Output" data-author-content="v1 = ( 10 20 10 40 10 )
The number of elements in v1 greater than 10 is: 2.
">v1 = ( 10 20 10 40 10 )
The number of elements in v1 greater than 10 is: 2.
</code></pre>
<h2 id="equal" class="heading-with-anchor">  equal<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#equal"></a></h2>
<p>Compares two ranges element by element for equality or equivalence in a sense specified by a binary predicate.</p>
<p>Use <code>std::equal</code> when comparing elements in different container types (for example <code>vector</code> and <code>list</code>) or when comparing different element types, or when you need to compare sub-ranges of containers. Otherwise, when comparing elements of the same type in the same container type, use the non-member <code>operator==</code> that is provided for each container.</p>
<p>Use the dual-range overloads in C++14 code because the overloads that only take a single iterator for the second range will not detect differences if the second range is longer than the first range, and will result in undefined behavior if the second range is shorter than the first range.</p>
<div class="codeHeader" id="code-try-20" data-bi-name="code-header"><span class="language">C++</span>
			<button class="action" data-bi-name="copy">
				<span class="docon docon-edit-copy" role="presentation"></span>
				<span>Copy</span>
			</button></div><pre><code class="lang-cpp" data-author-content="template&lt;class InputIterator1, class InputIterator2&gt;
bool equal(
    InputIterator1  First1,
    InputIterator1  Last1,
    InputIterator2  First2);

template&lt;class InputIterator1, class InputIterator2, class BinaryPredicate&gt;
bool equal(
    InputIterator1  First1,
    InputIterator1  Last1,
    InputIterator2  First2,
    BinaryPredicate Comp); // C++14

template&lt;class InputIterator1, class InputIterator2&gt;
bool equal(
    InputIterator1  First1,
    InputIterator1  Last1,
    InputIterator2  First2,
    InputIterator2  Last2);

template&lt;class InputIterator1, class InputIterator2, class BinaryPredicate&gt;
bool equal(
    InputIterator1  First1,
    InputIterator1  Last1,
    InputIterator2  First2,
    InputIterator2  Last2,
    BinaryPredicate Comp);
"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InputIterator1</span>, <span class="hljs-title">class</span> <span class="hljs-title">InputIterator2</span>&gt;
<span class="hljs-title">bool</span> <span class="hljs-title">equal</span>(
    <span class="hljs-title">InputIterator1</span>  <span class="hljs-title">First1</span>,
    <span class="hljs-title">InputIterator1</span>  <span class="hljs-title">Last1</span>,
    <span class="hljs-title">InputIterator2</span>  <span class="hljs-title">First2</span>);</span>

<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InputIterator1</span>, <span class="hljs-title">class</span> <span class="hljs-title">InputIterator2</span>, <span class="hljs-title">class</span> <span class="hljs-title">BinaryPredicate</span>&gt;
<span class="hljs-title">bool</span> <span class="hljs-title">equal</span>(
    <span class="hljs-title">InputIterator1</span>  <span class="hljs-title">First1</span>,
    <span class="hljs-title">InputIterator1</span>  <span class="hljs-title">Last1</span>,
    <span class="hljs-title">InputIterator2</span>  <span class="hljs-title">First2</span>,
    <span class="hljs-title">BinaryPredicate</span> <span class="hljs-title">Comp</span>);</span> <span class="hljs-comment">// C++14</span>

<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InputIterator1</span>, <span class="hljs-title">class</span> <span class="hljs-title">InputIterator2</span>&gt;
<span class="hljs-title">bool</span> <span class="hljs-title">equal</span>(
    <span class="hljs-title">InputIterator1</span>  <span class="hljs-title">First1</span>,
    <span class="hljs-title">InputIterator1</span>  <span class="hljs-title">Last1</span>,
    <span class="hljs-title">InputIterator2</span>  <span class="hljs-title">First2</span>,
    <span class="hljs-title">InputIterator2</span>  <span class="hljs-title">Last2</span>);</span>

<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InputIterator1</span>, <span class="hljs-title">class</span> <span class="hljs-title">InputIterator2</span>, <span class="hljs-title">class</span> <span class="hljs-title">BinaryPredicate</span>&gt;
<span class="hljs-title">bool</span> <span class="hljs-title">equal</span>(
    <span class="hljs-title">InputIterator1</span>  <span class="hljs-title">First1</span>,
    <span class="hljs-title">InputIterator1</span>  <span class="hljs-title">Last1</span>,
    <span class="hljs-title">InputIterator2</span>  <span class="hljs-title">First2</span>,
    <span class="hljs-title">InputIterator2</span>  <span class="hljs-title">Last2</span>,
    <span class="hljs-title">BinaryPredicate</span> <span class="hljs-title">Comp</span>);</span>
</code></pre>
<h3 id="parameters-10" class="heading-with-anchor">Parameters<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#parameters-10"></a></h3>
<p><em>First1</em><br>
An input iterator addressing the position of the first element in the first range to be tested.</p>
<p><em>Last1</em><br>
An input iterator addressing the position one past the last element in the first range to be tested.</p>
<p><em>First2</em><br>
An input iterator addressing the position of the first element in the second range to be tested.</p>
<p><em>First2</em><br>
An input iterator addressing the position of one past the last element in the second range to be tested.</p>
<p><em>Comp</em><br>
User-defined predicate function object that defines the condition to be satisfied if two elements are to be taken as equivalent. A binary predicate takes two arguments and returns <strong>true</strong> when satisfied and <strong>false</strong> when not satisfied.</p>
<h3 id="return-value-10" class="heading-with-anchor">Return Value<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#return-value-10"></a></h3>
<p><strong>true</strong> if and only if the ranges are identical or equivalent under the binary predicate when compared element by element; otherwise, <strong>false</strong>.</p>
<h3 id="remarks-10" class="heading-with-anchor">Remarks<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#remarks-10"></a></h3>
<p>The range to be searched must be valid; all iterators must be dereferenceable and the last position is reachable from the first by incrementation.</p>
<p>If the two ranges are equal length, then the time complexity of the algorithm is linear in the number of elements contained in the range. Otherwise the function immediately returns <strong>false</strong>.</p>
<p>Neither the <code>operator==</code> nor the user-defined predicate is required to impose an equivalence relation that symmetric, reflexive and transitive between its operands.</p>
<h3 id="example-6" class="heading-with-anchor">Example<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#example-6"></a></h3>
<div class="codeHeader" id="code-try-21" data-bi-name="code-header"><span class="language">C++</span>
			<button class="action" data-bi-name="copy">
				<span class="docon docon-edit-copy" role="presentation"></span>
				<span>Copy</span>
			</button></div><pre><code class="lang-cpp" data-author-content="#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

using namespace std;

int main()
{
    vector&lt;int&gt; v1 { 0, 5, 10, 15, 20, 25 };
    vector&lt;int&gt; v2 { 0, 5, 10, 15, 20, 25 };
    vector&lt;int&gt; v3 { 0, 5, 10, 15, 20, 25, 30, 35, 40, 45, 50 };

    // Using range-and-a-half equal:
    bool b = equal(v1.begin(), v1.end(), v2.begin());
    cout &lt;&lt; &quot;v1 and v2 are equal: &quot;
       &lt;&lt; b &lt;&lt; endl; // true, as expected

    b = equal(v1.begin(), v1.end(), v3.begin());
    cout &lt;&lt; &quot;v1 and v3 are equal: &quot;
       &lt;&lt; b &lt;&lt; endl; // true, surprisingly

    // Using dual-range equal:
    b = equal(v1.begin(), v1.end(), v3.begin(), v3.end());
    cout &lt;&lt; &quot;v1 and v3 are equal with dual-range overload: &quot;
       &lt;&lt; b &lt;&lt; endl; // false

    return 0;
}
"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span>

<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; v1 { <span class="hljs-number">0</span>, <span class="hljs-number">5</span>, <span class="hljs-number">10</span>, <span class="hljs-number">15</span>, <span class="hljs-number">20</span>, <span class="hljs-number">25</span> };
    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; v2 { <span class="hljs-number">0</span>, <span class="hljs-number">5</span>, <span class="hljs-number">10</span>, <span class="hljs-number">15</span>, <span class="hljs-number">20</span>, <span class="hljs-number">25</span> };
    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; v3 { <span class="hljs-number">0</span>, <span class="hljs-number">5</span>, <span class="hljs-number">10</span>, <span class="hljs-number">15</span>, <span class="hljs-number">20</span>, <span class="hljs-number">25</span>, <span class="hljs-number">30</span>, <span class="hljs-number">35</span>, <span class="hljs-number">40</span>, <span class="hljs-number">45</span>, <span class="hljs-number">50</span> };

    <span class="hljs-comment">// Using range-and-a-half equal:</span>
    <span class="hljs-keyword">bool</span> b = equal(v1.begin(), v1.end(), v2.begin());
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"v1 and v2 are equal: "</span>
       &lt;&lt; b &lt;&lt; <span class="hljs-built_in">endl</span>; <span class="hljs-comment">// true, as expected</span>

    b = equal(v1.begin(), v1.end(), v3.begin());
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"v1 and v3 are equal: "</span>
       &lt;&lt; b &lt;&lt; <span class="hljs-built_in">endl</span>; <span class="hljs-comment">// true, surprisingly</span>

    <span class="hljs-comment">// Using dual-range equal:</span>
    b = equal(v1.begin(), v1.end(), v3.begin(), v3.end());
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"v1 and v3 are equal with dual-range overload: "</span>
       &lt;&lt; b &lt;&lt; <span class="hljs-built_in">endl</span>; <span class="hljs-comment">// false</span>

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<h2 id="equal_range" class="heading-with-anchor">  equal_range<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#equal_range"></a></h2>
<p>Given an ordered range, finds the subrange in which all elements are equivalent to a given value.</p>
<div class="codeHeader" id="code-try-22" data-bi-name="code-header"><span class="language">C++</span>
			<button class="action" data-bi-name="copy">
				<span class="docon docon-edit-copy" role="presentation"></span>
				<span>Copy</span>
			</button></div><pre><code class="lang-cpp" data-author-content="template&lt;class ForwardIterator, class Type&gt;
pair&lt;ForwardIterator, ForwardIterator&gt; equal_range(
    ForwardIterator first,
    ForwardIterator last,
    const Type&amp; val);

template&lt;class ForwardIterator, class Type, class Predicate&gt;
pair&lt;ForwardIterator, ForwardIterator&gt; equal_range(
    ForwardIterator first,
    ForwardIterator last,
    const Type&amp; val,
    Predicate comp);
"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ForwardIterator</span>, <span class="hljs-title">class</span> <span class="hljs-title">Type</span>&gt;
<span class="hljs-title">pair</span>&lt;ForwardIterator, ForwardIterator&gt; <span class="hljs-title">equal_range</span>(
    <span class="hljs-title">ForwardIterator</span> <span class="hljs-title">first</span>,
    <span class="hljs-title">ForwardIterator</span> <span class="hljs-title">last</span>,
    <span class="hljs-title">const</span> <span class="hljs-title">Type</span>&amp; <span class="hljs-title">val</span>);</span>

<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ForwardIterator</span>, <span class="hljs-title">class</span> <span class="hljs-title">Type</span>, <span class="hljs-title">class</span> <span class="hljs-title">Predicate</span>&gt;
<span class="hljs-title">pair</span>&lt;ForwardIterator, ForwardIterator&gt; <span class="hljs-title">equal_range</span>(
    <span class="hljs-title">ForwardIterator</span> <span class="hljs-title">first</span>,
    <span class="hljs-title">ForwardIterator</span> <span class="hljs-title">last</span>,
    <span class="hljs-title">const</span> <span class="hljs-title">Type</span>&amp; <span class="hljs-title">val</span>,
    <span class="hljs-title">Predicate</span> <span class="hljs-title">comp</span>);</span>
</code></pre>
<h3 id="parameters-11" class="heading-with-anchor">Parameters<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#parameters-11"></a></h3>
<p><em>first</em><br>
A forward iterator addressing the position of the first element in the range to be searched.</p>
<p><em>last</em><br>
A forward iterator addressing the position one past the final element in the range to be searched.</p>
<p><em>val</em><br>
The value being searched for in the ordered range.</p>
<p><em>comp</em><br>
User-defined predicate function object that defines the sense in which one element is less than another.</p>
<h3 id="return-value-11" class="heading-with-anchor">Return Value<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#return-value-11"></a></h3>
<p>A pair of forward iterators that specify a subrange, contained within the range searched, in which all of the elements are equivalent to <em>val</em> in the sense defined by the binary predicate used (either <em>comp</em> or the default, less-than).</p>
<p>If no elements in the range are equivalent to <em>val</em>, the returned pair of forward iterators are equal and specify the point where <em>val</em> could be inserted without disturbing the order of the range.</p>
<h3 id="remarks-11" class="heading-with-anchor">Remarks<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#remarks-11"></a></h3>
<p>The first iterator of the pair returned by the algorithm is <a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#lower_bound" data-linktype="relative-path">lower_bound</a>, and the second iterator is <a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#upper_bound" data-linktype="relative-path">upper_bound</a>.</p>
<p>The range must be sorted according to the predicate provided to <code>equal_range</code>. For example, if you are going to use the greater-than predicate, the range must be sorted in descending order.</p>
<p>Elements in the possibly empty subrange defined by the pair of iterators returned by <code>equal_range</code> will be equivalent to <em>val</em> in the sense defined by the predicate used.</p>
<p>The complexity of the algorithm is logarithmic for random-access iterators and linear otherwise, with the number of steps proportional to (<em>last</em> - <em>first</em>).</p>
<h3 id="example-7" class="heading-with-anchor">Example<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#example-7"></a></h3>
<div class="codeHeader" id="code-try-23" data-bi-name="code-header"><span class="language">C++</span>
			<button class="action" data-bi-name="copy">
				<span class="docon docon-edit-copy" role="presentation"></span>
				<span>Copy</span>
			</button></div><pre><code class="lang-cpp" data-author-content="// alg_equal_range.cpp
// compile with: /EHsc
#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;functional&gt;      // greater&lt;int&gt;()
#include &lt;iostream&gt;
#include &lt;string&gt;
using namespace std;

template&lt;class T&gt; void dump_vector( const vector&lt;T&gt;&amp; v, pair&lt;typename vector&lt;T&gt;::iterator, typename vector&lt;T&gt;::iterator&gt; range )
{
    // prints vector v with range delimited by [ and ]

    for ( typename vector&lt;T&gt;::const_iterator i = v.begin(); i != v.end(); ++i )
    {
        if ( i == range.first )
        {
            cout &lt;&lt; &quot;[ &quot;;
        }
        if ( i == range.second )
        {
            cout &lt;&lt; &quot;] &quot;;
        }

        cout &lt;&lt; *i &lt;&lt; &quot; &quot;;
    }
    cout &lt;&lt; endl;
}

template&lt;class T&gt; void equal_range_demo( const vector&lt;T&gt;&amp; original_vector, T val )
{
    vector&lt;T&gt; v(original_vector);

    sort( v.begin(), v.end() );
    cout &lt;&lt; &quot;Vector sorted by the default binary predicate &lt;:&quot; &lt;&lt; endl &lt;&lt; &#39;\t&#39;;
    for ( vector&lt;T&gt;::const_iterator i = v.begin(); i != v.end(); ++i )
    {
        cout &lt;&lt; *i &lt;&lt; &quot; &quot;;
    }
    cout &lt;&lt; endl &lt;&lt; endl;

    pair&lt;vector&lt;T&gt;::iterator, vector&lt;T&gt;::iterator&gt; result
        = equal_range( v.begin(), v.end(), val );

    cout &lt;&lt; &quot;Result of equal_range with val = &quot; &lt;&lt; val &lt;&lt; &quot;:&quot; &lt;&lt; endl &lt;&lt; &#39;\t&#39;;
    dump_vector( v, result );
    cout &lt;&lt; endl;
}

template&lt;class T, class F&gt; void equal_range_demo( const vector&lt;T&gt;&amp; original_vector, T val, F pred, string predname )
{
    vector&lt;T&gt; v(original_vector);

    sort( v.begin(), v.end(), pred );
    cout &lt;&lt; &quot;Vector sorted by the binary predicate &quot; &lt;&lt; predname &lt;&lt; &quot;:&quot; &lt;&lt; endl &lt;&lt; &#39;\t&#39;;
    for ( typename vector&lt;T&gt;::const_iterator i = v.begin(); i != v.end(); ++i )
    {
        cout &lt;&lt; *i &lt;&lt; &quot; &quot;;
    }
    cout &lt;&lt; endl &lt;&lt; endl;

    pair&lt;typename vector&lt;T&gt;::iterator, typename vector&lt;T&gt;::iterator&gt; result
        = equal_range( v.begin(), v.end(), val, pred );

    cout &lt;&lt; &quot;Result of equal_range with val = &quot; &lt;&lt; val &lt;&lt; &quot;:&quot; &lt;&lt; endl &lt;&lt; &#39;\t&#39;;
    dump_vector( v, result );
    cout &lt;&lt; endl;
}

// Return whether absolute value of elem1 is less than absolute value of elem2
bool abs_lesser( int elem1, int elem2 )
{
    return abs(elem1) &lt; abs(elem2);
}

// Return whether string l is shorter than string r
bool shorter_than(const string&amp; l, const string&amp; r)
{
    return l.size() &lt; r.size();
}

int main()
{
    vector&lt;int&gt; v1;

    // Constructing vector v1 with default less than ordering
    for ( int i = -1; i &lt;= 4; ++i )
    {
        v1.push_back(i);
    }

    for ( int i =-3; i &lt;= 0; ++i )
    {
        v1.push_back( i );
    }

    equal_range_demo( v1, 3 );
    equal_range_demo( v1, 3, greater&lt;int&gt;(), &quot;greater&quot; );
    equal_range_demo( v1, 3, abs_lesser, &quot;abs_lesser&quot; );

    vector&lt;string&gt; v2;

    v2.push_back(&quot;cute&quot;);
    v2.push_back(&quot;fluffy&quot;);
    v2.push_back(&quot;kittens&quot;);
    v2.push_back(&quot;fun&quot;);
    v2.push_back(&quot;meowmeowmeow&quot;);
    v2.push_back(&quot;blah&quot;);

    equal_range_demo&lt;string&gt;( v2, &quot;fred&quot; );
    equal_range_demo&lt;string&gt;( v2, &quot;fred&quot;, shorter_than, &quot;shorter_than&quot; );
}
"><span class="hljs-comment">// alg_equal_range.cpp</span>
<span class="hljs-comment">// compile with: /EHsc</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;functional&gt;      // greater&lt;int&gt;()</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;

<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>&gt; <span class="hljs-title">void</span> <span class="hljs-title">dump_vector</span>( <span class="hljs-title">const</span> <span class="hljs-title">vector</span>&lt;T&gt;&amp; <span class="hljs-title">v</span>, <span class="hljs-title">pair</span>&lt;typename vector&lt;T&gt;::iterator, typename vector&lt;T&gt;::iterator&gt; <span class="hljs-title">range</span> )
{</span>
    <span class="hljs-comment">// prints vector v with range delimited by [ and ]</span>

    <span class="hljs-keyword">for</span> ( <span class="hljs-keyword">typename</span> <span class="hljs-built_in">vector</span>&lt;T&gt;::const_iterator i = v.begin(); i != v.end(); ++i )
    {
        <span class="hljs-keyword">if</span> ( i == range.first )
        {
            <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"[ "</span>;
        }
        <span class="hljs-keyword">if</span> ( i == range.second )
        {
            <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"] "</span>;
        }

        <span class="hljs-built_in">cout</span> &lt;&lt; *i &lt;&lt; <span class="hljs-string">" "</span>;
    }
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
}

<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>&gt; <span class="hljs-title">void</span> <span class="hljs-title">equal_range_demo</span>( <span class="hljs-title">const</span> <span class="hljs-title">vector</span>&lt;T&gt;&amp; <span class="hljs-title">original_vector</span>, <span class="hljs-title">T</span> <span class="hljs-title">val</span> )
{</span>
    <span class="hljs-built_in">vector</span>&lt;T&gt; v(original_vector);

    sort( v.begin(), v.end() );
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Vector sorted by the default binary predicate &lt;:"</span> &lt;&lt; <span class="hljs-built_in">endl</span> &lt;&lt; <span class="hljs-string">'\t'</span>;
    <span class="hljs-keyword">for</span> ( <span class="hljs-built_in">vector</span>&lt;T&gt;::const_iterator i = v.begin(); i != v.end(); ++i )
    {
        <span class="hljs-built_in">cout</span> &lt;&lt; *i &lt;&lt; <span class="hljs-string">" "</span>;
    }
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">endl</span> &lt;&lt; <span class="hljs-built_in">endl</span>;

    pair&lt;<span class="hljs-built_in">vector</span>&lt;T&gt;::iterator, <span class="hljs-built_in">vector</span>&lt;T&gt;::iterator&gt; result
        = equal_range( v.begin(), v.end(), val );

    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Result of equal_range with val = "</span> &lt;&lt; val &lt;&lt; <span class="hljs-string">":"</span> &lt;&lt; <span class="hljs-built_in">endl</span> &lt;&lt; <span class="hljs-string">'\t'</span>;
    dump_vector( v, result );
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
}

<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>, <span class="hljs-title">class</span> <span class="hljs-title">F</span>&gt; <span class="hljs-title">void</span> <span class="hljs-title">equal_range_demo</span>( <span class="hljs-title">const</span> <span class="hljs-title">vector</span>&lt;T&gt;&amp; <span class="hljs-title">original_vector</span>, <span class="hljs-title">T</span> <span class="hljs-title">val</span>, <span class="hljs-title">F</span> <span class="hljs-title">pred</span>, <span class="hljs-title">string</span> <span class="hljs-title">predname</span> )
{</span>
    <span class="hljs-built_in">vector</span>&lt;T&gt; v(original_vector);

    sort( v.begin(), v.end(), pred );
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Vector sorted by the binary predicate "</span> &lt;&lt; predname &lt;&lt; <span class="hljs-string">":"</span> &lt;&lt; <span class="hljs-built_in">endl</span> &lt;&lt; <span class="hljs-string">'\t'</span>;
    <span class="hljs-keyword">for</span> ( <span class="hljs-keyword">typename</span> <span class="hljs-built_in">vector</span>&lt;T&gt;::const_iterator i = v.begin(); i != v.end(); ++i )
    {
        <span class="hljs-built_in">cout</span> &lt;&lt; *i &lt;&lt; <span class="hljs-string">" "</span>;
    }
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">endl</span> &lt;&lt; <span class="hljs-built_in">endl</span>;

    pair&lt;<span class="hljs-keyword">typename</span> <span class="hljs-built_in">vector</span>&lt;T&gt;::iterator, <span class="hljs-keyword">typename</span> <span class="hljs-built_in">vector</span>&lt;T&gt;::iterator&gt; result
        = equal_range( v.begin(), v.end(), val, pred );

    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Result of equal_range with val = "</span> &lt;&lt; val &lt;&lt; <span class="hljs-string">":"</span> &lt;&lt; <span class="hljs-built_in">endl</span> &lt;&lt; <span class="hljs-string">'\t'</span>;
    dump_vector( v, result );
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
}

<span class="hljs-comment">// Return whether absolute value of elem1 is less than absolute value of elem2</span>
<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">abs_lesser</span><span class="hljs-params">( <span class="hljs-keyword">int</span> elem1, <span class="hljs-keyword">int</span> elem2 )</span>
</span>{
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">abs</span>(elem1) &lt; <span class="hljs-built_in">abs</span>(elem2);
}

<span class="hljs-comment">// Return whether string l is shorter than string r</span>
<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">shorter_than</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span>&amp; l, <span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span>&amp; r)</span>
</span>{
    <span class="hljs-keyword">return</span> l.size() &lt; r.size();
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; v1;

    <span class="hljs-comment">// Constructing vector v1 with default less than ordering</span>
    <span class="hljs-keyword">for</span> ( <span class="hljs-keyword">int</span> i = <span class="hljs-number">-1</span>; i &lt;= <span class="hljs-number">4</span>; ++i )
    {
        v1.push_back(i);
    }

    <span class="hljs-keyword">for</span> ( <span class="hljs-keyword">int</span> i =<span class="hljs-number">-3</span>; i &lt;= <span class="hljs-number">0</span>; ++i )
    {
        v1.push_back( i );
    }

    equal_range_demo( v1, <span class="hljs-number">3</span> );
    equal_range_demo( v1, <span class="hljs-number">3</span>, greater&lt;<span class="hljs-keyword">int</span>&gt;(), <span class="hljs-string">"greater"</span> );
    equal_range_demo( v1, <span class="hljs-number">3</span>, abs_lesser, <span class="hljs-string">"abs_lesser"</span> );

    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt; v2;

    v2.push_back(<span class="hljs-string">"cute"</span>);
    v2.push_back(<span class="hljs-string">"fluffy"</span>);
    v2.push_back(<span class="hljs-string">"kittens"</span>);
    v2.push_back(<span class="hljs-string">"fun"</span>);
    v2.push_back(<span class="hljs-string">"meowmeowmeow"</span>);
    v2.push_back(<span class="hljs-string">"blah"</span>);

    equal_range_demo&lt;<span class="hljs-built_in">string</span>&gt;( v2, <span class="hljs-string">"fred"</span> );
    equal_range_demo&lt;<span class="hljs-built_in">string</span>&gt;( v2, <span class="hljs-string">"fred"</span>, shorter_than, <span class="hljs-string">"shorter_than"</span> );
}
</code></pre>
<h2 id="fill" class="heading-with-anchor">  fill<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#fill"></a></h2>
<p>Assigns the same new value to every element in a specified range.</p>
<div class="codeHeader" id="code-try-24" data-bi-name="code-header"><span class="language">C++</span>
			<button class="action" data-bi-name="copy">
				<span class="docon docon-edit-copy" role="presentation"></span>
				<span>Copy</span>
			</button></div><pre><code class="lang-cpp" data-author-content="template&lt;class ForwardIterator, class Type&gt;
void fill(
    ForwardIterator first,
    ForwardIterator last,
    const Type&amp; val);
"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ForwardIterator</span>, <span class="hljs-title">class</span> <span class="hljs-title">Type</span>&gt;
<span class="hljs-title">void</span> <span class="hljs-title">fill</span>(
    <span class="hljs-title">ForwardIterator</span> <span class="hljs-title">first</span>,
    <span class="hljs-title">ForwardIterator</span> <span class="hljs-title">last</span>,
    <span class="hljs-title">const</span> <span class="hljs-title">Type</span>&amp; <span class="hljs-title">val</span>);</span>
</code></pre>
<h3 id="parameters-12" class="heading-with-anchor">Parameters<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#parameters-12"></a></h3>
<p><em>first</em><br>
A forward iterator addressing the position of the first element in the range to be traversed.</p>
<p><em>last</em><br>
A forward iterator addressing the position one past the final element in the range to be traversed.</p>
<p><em>val</em><br>
The value to be assigned to elements in the range [  <em>first</em>, <em>last</em>).</p>
<h3 id="remarks-12" class="heading-with-anchor">Remarks<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#remarks-12"></a></h3>
<p>The destination range must be valid; all pointers must be dereferenceable, and the last position is reachable from the first by incrementation. The complexity is linear with the size of the range.</p>
<h3 id="example-8" class="heading-with-anchor">Example<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#example-8"></a></h3>
<div class="codeHeader" id="code-try-25" data-bi-name="code-header"><span class="language">C++</span>
			<button class="action" data-bi-name="copy">
				<span class="docon docon-edit-copy" role="presentation"></span>
				<span>Copy</span>
			</button></div><pre><code class="lang-cpp" data-author-content="// alg_fill.cpp
// compile with: /EHsc
#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;iostream&gt;

int main()
{
   using namespace std;
   vector &lt;int&gt; v1;
   vector &lt;int&gt;::iterator Iter1;

   int i;
   for ( i = 0 ; i &lt;= 9 ; i++ )
   {
      v1.push_back( 5 * i );
   }

   cout &lt;&lt; &quot;Vector v1 = ( &quot; ;
   for ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ; Iter1++ )
      cout &lt;&lt; *Iter1 &lt;&lt; &quot; &quot;;
   cout &lt;&lt; &quot;)&quot; &lt;&lt; endl;

   // Fill the last 5 positions with a value of 2
   fill( v1.begin( ) + 5, v1.end( ), 2 );

   cout &lt;&lt; &quot;Modified v1 = ( &quot; ;
   for ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ; Iter1++ )
      cout &lt;&lt; *Iter1 &lt;&lt; &quot; &quot;;
   cout &lt;&lt; &quot;)&quot; &lt;&lt; endl;
}
"><span class="hljs-comment">// alg_fill.cpp</span>
<span class="hljs-comment">// compile with: /EHsc</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span>

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
   <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;
   <span class="hljs-built_in">vector</span> &lt;<span class="hljs-keyword">int</span>&gt; v1;
   <span class="hljs-built_in">vector</span> &lt;<span class="hljs-keyword">int</span>&gt;::iterator Iter1;

   <span class="hljs-keyword">int</span> i;
   <span class="hljs-keyword">for</span> ( i = <span class="hljs-number">0</span> ; i &lt;= <span class="hljs-number">9</span> ; i++ )
   {
      v1.push_back( <span class="hljs-number">5</span> * i );
   }

   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Vector v1 = ( "</span> ;
   <span class="hljs-keyword">for</span> ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ; Iter1++ )
      <span class="hljs-built_in">cout</span> &lt;&lt; *Iter1 &lt;&lt; <span class="hljs-string">" "</span>;
   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">")"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;

   <span class="hljs-comment">// Fill the last 5 positions with a value of 2</span>
   fill( v1.begin( ) + <span class="hljs-number">5</span>, v1.end( ), <span class="hljs-number">2</span> );

   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Modified v1 = ( "</span> ;
   <span class="hljs-keyword">for</span> ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ; Iter1++ )
      <span class="hljs-built_in">cout</span> &lt;&lt; *Iter1 &lt;&lt; <span class="hljs-string">" "</span>;
   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">")"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
}
</code></pre>
<div class="codeHeader" id="code-try-26" data-bi-name="code-header"><span class="language">Output</span>
			<button class="action" data-bi-name="copy">
				<span class="docon docon-edit-copy" role="presentation"></span>
				<span>Copy</span>
			</button></div><pre><code class="lang-Output" data-author-content="Vector v1 = ( 0 5 10 15 20 25 30 35 40 45 )
Modified v1 = ( 0 5 10 15 20 2 2 2 2 2 )
">Vector v1 = ( 0 5 10 15 20 25 30 35 40 45 )
Modified v1 = ( 0 5 10 15 20 2 2 2 2 2 )
</code></pre>
<h2 id="fill_n" class="heading-with-anchor">  fill_n<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#fill_n"></a></h2>
<p>Assigns a new value to a specified number of elements in a range beginning with a particular element.</p>
<div class="codeHeader" id="code-try-27" data-bi-name="code-header"><span class="language">C++</span>
			<button class="action" data-bi-name="copy">
				<span class="docon docon-edit-copy" role="presentation"></span>
				<span>Copy</span>
			</button></div><pre><code class="lang-cpp" data-author-content="template&lt;class OutputIterator, class Size, class Type&gt;
OutputIterator fill_n(
    OutputIterator First,
    Size Count,
    const Type&amp; Val);
"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OutputIterator</span>, <span class="hljs-title">class</span> <span class="hljs-title">Size</span>, <span class="hljs-title">class</span> <span class="hljs-title">Type</span>&gt;
<span class="hljs-title">OutputIterator</span> <span class="hljs-title">fill_n</span>(
    <span class="hljs-title">OutputIterator</span> <span class="hljs-title">First</span>,
    <span class="hljs-title">Size</span> <span class="hljs-title">Count</span>,
    <span class="hljs-title">const</span> <span class="hljs-title">Type</span>&amp; <span class="hljs-title">Val</span>);</span>
</code></pre>
<h3 id="parameters-13" class="heading-with-anchor">Parameters<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#parameters-13"></a></h3>
<p><em>First</em><br>
An output iterator addressing the position of the first element in the range to be assigned the value <em>Val</em>.</p>
<p><em>Count</em><br>
A signed or unsigned integer type specifying the number of elements to be assigned the value.</p>
<p><em>Val</em><br>
The value to be assigned to elements in the range [ <em>First</em>, <em>First + Count</em>).</p>
<h3 id="return-value-12" class="heading-with-anchor">Return Value<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#return-value-12"></a></h3>
<p>An iterator to the element that follows the last element filled if <em>Count</em> &gt; zero, otherwise the first element.</p>
<h3 id="remarks-13" class="heading-with-anchor">Remarks<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#remarks-13"></a></h3>
<p>The destination range must be valid; all pointers must be dereferenceable, and the last position is reachable from the first by incrementation. The complexity is linear with the size of the range.</p>
<h3 id="example-9" class="heading-with-anchor">Example<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#example-9"></a></h3>
<div class="codeHeader" id="code-try-28" data-bi-name="code-header"><span class="language">C++</span>
			<button class="action" data-bi-name="copy">
				<span class="docon docon-edit-copy" role="presentation"></span>
				<span>Copy</span>
			</button></div><pre><code class="lang-cpp" data-author-content="// alg_fill_n.cpp
// compile using /EHsc
#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;iostream&gt;

int main()
{
    using namespace std;
    vector &lt;int&gt; v;

    for ( auto i = 0 ; i &lt; 9 ; ++i )
        v.push_back( 0 );

    cout &lt;&lt; &quot;  vector v = ( &quot; ;
    for ( const auto &amp;w : v )
        cout &lt;&lt; w &lt;&lt; &quot; &quot;;
    cout &lt;&lt; &quot;)&quot; &lt;&lt; endl;

    // Fill the first 3 positions with a value of 1, saving position.
    auto pos = fill_n( v.begin(), 3, 1 );

    cout &lt;&lt; &quot;modified v = ( &quot; ;
    for ( const auto &amp;w : v )
        cout &lt;&lt; w &lt;&lt; &quot; &quot;;
    cout &lt;&lt; &quot;)&quot; &lt;&lt; endl;

    // Fill the next 3 positions with a value of 2, using last position.
    fill_n( pos, 3, 2 );

    cout &lt;&lt; &quot;modified v = ( &quot; ;
    for ( const auto &amp;w : v )
        cout &lt;&lt; w &lt;&lt; &quot; &quot;;
    cout &lt;&lt; &quot;)&quot; &lt;&lt; endl;

    // Fill the last 3 positions with a value of 3, using relative math.
    fill_n( v.end()-3, 3, 3 );

    cout &lt;&lt; &quot;modified v = ( &quot; ;
    for ( const auto &amp;w : v )
        cout &lt;&lt; w &lt;&lt; &quot; &quot;;
    cout &lt;&lt; &quot;)&quot; &lt;&lt; endl;
}
"><span class="hljs-comment">// alg_fill_n.cpp</span>
<span class="hljs-comment">// compile using /EHsc</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span>

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;
    <span class="hljs-built_in">vector</span> &lt;<span class="hljs-keyword">int</span>&gt; v;

    <span class="hljs-keyword">for</span> ( <span class="hljs-keyword">auto</span> i = <span class="hljs-number">0</span> ; i &lt; <span class="hljs-number">9</span> ; ++i )
        v.push_back( <span class="hljs-number">0</span> );

    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"  vector v = ( "</span> ;
    <span class="hljs-keyword">for</span> ( <span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> &amp;w : v )
        <span class="hljs-built_in">cout</span> &lt;&lt; w &lt;&lt; <span class="hljs-string">" "</span>;
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">")"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;

    <span class="hljs-comment">// Fill the first 3 positions with a value of 1, saving position.</span>
    <span class="hljs-keyword">auto</span> pos = fill_n( v.begin(), <span class="hljs-number">3</span>, <span class="hljs-number">1</span> );

    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"modified v = ( "</span> ;
    <span class="hljs-keyword">for</span> ( <span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> &amp;w : v )
        <span class="hljs-built_in">cout</span> &lt;&lt; w &lt;&lt; <span class="hljs-string">" "</span>;
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">")"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;

    <span class="hljs-comment">// Fill the next 3 positions with a value of 2, using last position.</span>
    fill_n( pos, <span class="hljs-number">3</span>, <span class="hljs-number">2</span> );

    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"modified v = ( "</span> ;
    <span class="hljs-keyword">for</span> ( <span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> &amp;w : v )
        <span class="hljs-built_in">cout</span> &lt;&lt; w &lt;&lt; <span class="hljs-string">" "</span>;
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">")"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;

    <span class="hljs-comment">// Fill the last 3 positions with a value of 3, using relative math.</span>
    fill_n( v.end()<span class="hljs-number">-3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span> );

    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"modified v = ( "</span> ;
    <span class="hljs-keyword">for</span> ( <span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> &amp;w : v )
        <span class="hljs-built_in">cout</span> &lt;&lt; w &lt;&lt; <span class="hljs-string">" "</span>;
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">")"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
}
</code></pre>
<h2 id="find" class="heading-with-anchor">  find<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#find"></a></h2>
<p>Locates the position of the first occurrence of an element in a range that has a specified value.</p>
<div class="codeHeader" id="code-try-29" data-bi-name="code-header"><span class="language">C++</span>
			<button class="action" data-bi-name="copy">
				<span class="docon docon-edit-copy" role="presentation"></span>
				<span>Copy</span>
			</button></div><pre><code class="lang-cpp" data-author-content="template&lt;class InputIterator, class T&gt;
InputIterator find(
    InputIterator first,
    InputIterator last,
    const T&amp; val);
"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InputIterator</span>, <span class="hljs-title">class</span> <span class="hljs-title">T</span>&gt;
<span class="hljs-title">InputIterator</span> <span class="hljs-title">find</span>(
    <span class="hljs-title">InputIterator</span> <span class="hljs-title">first</span>,
    <span class="hljs-title">InputIterator</span> <span class="hljs-title">last</span>,
    <span class="hljs-title">const</span> <span class="hljs-title">T</span>&amp; <span class="hljs-title">val</span>);</span>
</code></pre>
<h3 id="parameters-14" class="heading-with-anchor">Parameters<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#parameters-14"></a></h3>
<p><em>first</em><br>
An input iterator addressing the position of the first element in the range to be searched for the specified value.</p>
<p><em>last</em><br>
An input iterator addressing the position one past the final element in the range to be searched for the specified value.</p>
<p><em>val</em><br>
The value to be searched for.</p>
<h3 id="return-value-13" class="heading-with-anchor">Return Value<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#return-value-13"></a></h3>
<p>An input iterator addressing the first occurrence of the specified value in the range being searched. If no element is found with an equivalent value, returns <em>last</em>.</p>
<h3 id="remarks-14" class="heading-with-anchor">Remarks<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#remarks-14"></a></h3>
<p>The <code>operator==</code> used to determine the match between an element and the specified value must impose an equivalence relation between its operands.</p>
<p>For a code example using <code>find()</code>, see <a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#find_if" data-linktype="relative-path">find_if</a>.</p>
<h2 id="find_end" class="heading-with-anchor">  find_end<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#find_end"></a></h2>
<p>Looks in a range for the last subsequence that is identical to a specified sequence or that is equivalent in a sense specified by a binary predicate.</p>
<div class="codeHeader" id="code-try-30" data-bi-name="code-header"><span class="language">C++</span>
			<button class="action" data-bi-name="copy">
				<span class="docon docon-edit-copy" role="presentation"></span>
				<span>Copy</span>
			</button></div><pre><code class="lang-cpp" data-author-content="template&lt;class ForwardIterator1, class ForwardIterator2&gt;
ForwardIterator1 find_end(
    ForwardIterator1 First1,
    ForwardIterator1 Last1,
    ForwardIterator2 First2,
    ForwardIterator2 Last2);

template&lt;class ForwardIterator1, class ForwardIterator2, class Pred&gt;
ForwardIterator1 find_end(
    ForwardIterator1 First1,
    ForwardIterator1 Last1,
    ForwardIterator2 First2,
    ForwardIterator2 Last2,
    Pred Comp);
"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ForwardIterator1</span>, <span class="hljs-title">class</span> <span class="hljs-title">ForwardIterator2</span>&gt;
<span class="hljs-title">ForwardIterator1</span> <span class="hljs-title">find_end</span>(
    <span class="hljs-title">ForwardIterator1</span> <span class="hljs-title">First1</span>,
    <span class="hljs-title">ForwardIterator1</span> <span class="hljs-title">Last1</span>,
    <span class="hljs-title">ForwardIterator2</span> <span class="hljs-title">First2</span>,
    <span class="hljs-title">ForwardIterator2</span> <span class="hljs-title">Last2</span>);</span>

<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ForwardIterator1</span>, <span class="hljs-title">class</span> <span class="hljs-title">ForwardIterator2</span>, <span class="hljs-title">class</span> <span class="hljs-title">Pred</span>&gt;
<span class="hljs-title">ForwardIterator1</span> <span class="hljs-title">find_end</span>(
    <span class="hljs-title">ForwardIterator1</span> <span class="hljs-title">First1</span>,
    <span class="hljs-title">ForwardIterator1</span> <span class="hljs-title">Last1</span>,
    <span class="hljs-title">ForwardIterator2</span> <span class="hljs-title">First2</span>,
    <span class="hljs-title">ForwardIterator2</span> <span class="hljs-title">Last2</span>,
    <span class="hljs-title">Pred</span> <span class="hljs-title">Comp</span>);</span>
</code></pre>
<h3 id="parameters-15" class="heading-with-anchor">Parameters<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#parameters-15"></a></h3>
<p><em>First1</em><br>
A forward iterator addressing the position of the first element in the range to be searched.</p>
<p><em>Last1</em><br>
A forward iterator addressing the position one past the last element in the range to be searched.</p>
<p><em>First2</em><br>
A forward iterator addressing the position of the first element in the range to search for.</p>
<p><em>Last2</em><br>
A forward iterator addressing the position one past the last element in the range to search for.</p>
<p><em>Comp</em><br>
User-defined predicate function object that defines the condition to be satisfied if two elements are to be taken as equivalent. A binary predicate takes two arguments and returns <strong>true</strong> when satisfied and <strong>false</strong> when not satisfied.</p>
<h3 id="return-value-14" class="heading-with-anchor">Return Value<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#return-value-14"></a></h3>
<p>A forward iterator addressing the position of the first element of the last subsequence within [First1, Last1) that matches the specified sequence [First2, Last2).</p>
<h3 id="remarks-15" class="heading-with-anchor">Remarks<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#remarks-15"></a></h3>
<p>The <code>operator==</code> used to determine the match between an element and the specified value must impose an equivalence relation between its operands.</p>
<p>The ranges referenced must be valid; all pointers must be dereferenceable and, within each sequence, the last position is reachable from the first by incrementation.</p>
<h3 id="example-10" class="heading-with-anchor">Example<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#example-10"></a></h3>
<div class="codeHeader" id="code-try-31" data-bi-name="code-header"><span class="language">C++</span>
			<button class="action" data-bi-name="copy">
				<span class="docon docon-edit-copy" role="presentation"></span>
				<span>Copy</span>
			</button></div><pre><code class="lang-cpp" data-author-content="// alg_find_end.cpp
// compile with: /EHsc
#include &lt;vector&gt;
#include &lt;list&gt;
#include &lt;algorithm&gt;
#include &lt;iostream&gt;

// Return whether second element is twice the first
bool twice ( int elem1, int elem2 )
{
   return 2 * elem1 == elem2;
}

int main()
{
   using namespace std;
   vector &lt;int&gt; v1, v2;
   list &lt;int&gt; L1;
   vector &lt;int&gt;::iterator Iter1, Iter2;
   list &lt;int&gt;::iterator L1_Iter, L1_inIter;

   int i;
   for ( i = 0 ; i &lt;= 5 ; i++ )
   {
      v1.push_back( 5 * i );
   }
   for ( i = 0 ; i &lt;= 5 ; i++ )
   {
      v1.push_back( 5 * i );
   }

   int ii;
   for ( ii = 1 ; ii &lt;= 4 ; ii++ )
   {
      L1.push_back( 5 * ii );
   }

   int iii;
   for ( iii = 2 ; iii &lt;= 4 ; iii++ )
   {
      v2.push_back( 10 * iii );
   }

   cout &lt;&lt; &quot;Vector v1 = ( &quot; ;
   for ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ; Iter1++ )
      cout &lt;&lt; *Iter1 &lt;&lt; &quot; &quot;;
   cout &lt;&lt; &quot;)&quot; &lt;&lt; endl;

   cout &lt;&lt; &quot;List L1 = ( &quot; ;
   for ( L1_Iter = L1.begin( ) ; L1_Iter!= L1.end( ) ; L1_Iter++ )
      cout &lt;&lt; *L1_Iter &lt;&lt; &quot; &quot;;
   cout &lt;&lt; &quot;)&quot; &lt;&lt; endl;

   cout &lt;&lt; &quot;Vector v2 = ( &quot; ;
   for ( Iter2 = v2.begin( ) ; Iter2 != v2.end( ) ; Iter2++ )
      cout &lt;&lt; *Iter2 &lt;&lt; &quot; &quot;;
      cout &lt;&lt; &quot;)&quot; &lt;&lt; endl;

   // Searching v1 for a match to L1 under identity
   vector &lt;int&gt;::iterator result1;
   result1 = find_end ( v1.begin( ), v1.end( ), L1.begin( ), L1.end( ) );

   if ( result1 == v1.end( ) )
      cout &lt;&lt; &quot;There is no match of L1 in v1.&quot;
           &lt;&lt; endl;
   else
      cout &lt;&lt; &quot;There is a match of L1 in v1 that begins at &quot;
           &lt;&lt; &quot;position &quot;&lt;&lt; result1 - v1.begin( ) &lt;&lt; &quot;.&quot; &lt;&lt; endl;

   // Searching v1 for a match to L1 under the binary predicate twice
   vector &lt;int&gt;::iterator result2;
   result2 = find_end ( v1.begin( ), v1.end( ), v2.begin( ), v2.end( ), twice );

   if ( result2 == v1.end( ) )
      cout &lt;&lt; &quot;There is no match of L1 in v1.&quot;
           &lt;&lt; endl;
   else
      cout &lt;&lt; &quot;There is a sequence of elements in v1 that &quot;
           &lt;&lt; &quot;are equivalent to those\n in v2 under the binary &quot;
           &lt;&lt; &quot;predicate twice and that begins at position &quot;
           &lt;&lt; result2 - v1.begin( ) &lt;&lt; &quot;.&quot; &lt;&lt; endl;
}
"><span class="hljs-comment">// alg_find_end.cpp</span>
<span class="hljs-comment">// compile with: /EHsc</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;list&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span>

<span class="hljs-comment">// Return whether second element is twice the first</span>
<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">twice</span> <span class="hljs-params">( <span class="hljs-keyword">int</span> elem1, <span class="hljs-keyword">int</span> elem2 )</span>
</span>{
   <span class="hljs-keyword">return</span> <span class="hljs-number">2</span> * elem1 == elem2;
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
   <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;
   <span class="hljs-built_in">vector</span> &lt;<span class="hljs-keyword">int</span>&gt; v1, v2;
   <span class="hljs-built_in">list</span> &lt;<span class="hljs-keyword">int</span>&gt; L1;
   <span class="hljs-built_in">vector</span> &lt;<span class="hljs-keyword">int</span>&gt;::iterator Iter1, Iter2;
   <span class="hljs-built_in">list</span> &lt;<span class="hljs-keyword">int</span>&gt;::iterator L1_Iter, L1_inIter;

   <span class="hljs-keyword">int</span> i;
   <span class="hljs-keyword">for</span> ( i = <span class="hljs-number">0</span> ; i &lt;= <span class="hljs-number">5</span> ; i++ )
   {
      v1.push_back( <span class="hljs-number">5</span> * i );
   }
   <span class="hljs-keyword">for</span> ( i = <span class="hljs-number">0</span> ; i &lt;= <span class="hljs-number">5</span> ; i++ )
   {
      v1.push_back( <span class="hljs-number">5</span> * i );
   }

   <span class="hljs-keyword">int</span> ii;
   <span class="hljs-keyword">for</span> ( ii = <span class="hljs-number">1</span> ; ii &lt;= <span class="hljs-number">4</span> ; ii++ )
   {
      L1.push_back( <span class="hljs-number">5</span> * ii );
   }

   <span class="hljs-keyword">int</span> iii;
   <span class="hljs-keyword">for</span> ( iii = <span class="hljs-number">2</span> ; iii &lt;= <span class="hljs-number">4</span> ; iii++ )
   {
      v2.push_back( <span class="hljs-number">10</span> * iii );
   }

   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Vector v1 = ( "</span> ;
   <span class="hljs-keyword">for</span> ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ; Iter1++ )
      <span class="hljs-built_in">cout</span> &lt;&lt; *Iter1 &lt;&lt; <span class="hljs-string">" "</span>;
   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">")"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;

   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"List L1 = ( "</span> ;
   <span class="hljs-keyword">for</span> ( L1_Iter = L1.begin( ) ; L1_Iter!= L1.end( ) ; L1_Iter++ )
      <span class="hljs-built_in">cout</span> &lt;&lt; *L1_Iter &lt;&lt; <span class="hljs-string">" "</span>;
   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">")"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;

   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Vector v2 = ( "</span> ;
   <span class="hljs-keyword">for</span> ( Iter2 = v2.begin( ) ; Iter2 != v2.end( ) ; Iter2++ )
      <span class="hljs-built_in">cout</span> &lt;&lt; *Iter2 &lt;&lt; <span class="hljs-string">" "</span>;
      <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">")"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;

   <span class="hljs-comment">// Searching v1 for a match to L1 under identity</span>
   <span class="hljs-built_in">vector</span> &lt;<span class="hljs-keyword">int</span>&gt;::iterator result1;
   result1 = find_end ( v1.begin( ), v1.end( ), L1.begin( ), L1.end( ) );

   <span class="hljs-keyword">if</span> ( result1 == v1.end( ) )
      <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"There is no match of L1 in v1."</span>
           &lt;&lt; <span class="hljs-built_in">endl</span>;
   <span class="hljs-keyword">else</span>
      <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"There is a match of L1 in v1 that begins at "</span>
           &lt;&lt; <span class="hljs-string">"position "</span>&lt;&lt; result1 - v1.begin( ) &lt;&lt; <span class="hljs-string">"."</span> &lt;&lt; <span class="hljs-built_in">endl</span>;

   <span class="hljs-comment">// Searching v1 for a match to L1 under the binary predicate twice</span>
   <span class="hljs-built_in">vector</span> &lt;<span class="hljs-keyword">int</span>&gt;::iterator result2;
   result2 = find_end ( v1.begin( ), v1.end( ), v2.begin( ), v2.end( ), twice );

   <span class="hljs-keyword">if</span> ( result2 == v1.end( ) )
      <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"There is no match of L1 in v1."</span>
           &lt;&lt; <span class="hljs-built_in">endl</span>;
   <span class="hljs-keyword">else</span>
      <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"There is a sequence of elements in v1 that "</span>
           &lt;&lt; <span class="hljs-string">"are equivalent to those\n in v2 under the binary "</span>
           &lt;&lt; <span class="hljs-string">"predicate twice and that begins at position "</span>
           &lt;&lt; result2 - v1.begin( ) &lt;&lt; <span class="hljs-string">"."</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
}
</code></pre>
<div class="codeHeader" id="code-try-32" data-bi-name="code-header"><span class="language">Output</span>
			<button class="action" data-bi-name="copy">
				<span class="docon docon-edit-copy" role="presentation"></span>
				<span>Copy</span>
			</button></div><pre><code class="lang-Output" data-author-content="Vector v1 = ( 0 5 10 15 20 25 0 5 10 15 20 25 )
List L1 = ( 5 10 15 20 )
Vector v2 = ( 20 30 40 )
There is a match of L1 in v1 that begins at position 7.
There is a sequence of elements in v1 that are equivalent to those
in v2 under the binary predicate twice and that begins at position 8.
">Vector v1 = ( 0 5 10 15 20 25 0 5 10 15 20 25 )
List L1 = ( 5 10 15 20 )
Vector v2 = ( 20 30 40 )
There is a match of L1 in v1 that begins at position 7.
There is a sequence of elements in v1 that are equivalent to those
in v2 under the binary predicate twice and that begins at position 8.
</code></pre>
<h2 id="find_first_of" class="heading-with-anchor">  find_first_of<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#find_first_of"></a></h2>
<p>Searches for the first occurrence of any of several values within a target range or for the first occurrence of any of several elements that are equivalent in a sense specified by a binary predicate to a specified set of the elements.</p>
<div class="codeHeader" id="code-try-33" data-bi-name="code-header"><span class="language">C++</span>
			<button class="action" data-bi-name="copy">
				<span class="docon docon-edit-copy" role="presentation"></span>
				<span>Copy</span>
			</button></div><pre><code class="lang-cpp" data-author-content="template&lt;class ForwardIterator1, class ForwardIterator2&gt;
ForwardIterator1 find_first_of(
    ForwardIterator1  first1,
    ForwardIterator1 Last1,
    ForwardIterator2  first2,
    ForwardIterator2 Last2);

template&lt;class ForwardIterator1, class ForwardIterator2, class BinaryPredicate&gt;
ForwardIterator1 find_first_of(
    ForwardIterator1  first1,
    ForwardIterator1 Last1,
    ForwardIterator2  first2,
    ForwardIterator2 Last2,
    BinaryPredicate  comp);
"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ForwardIterator1</span>, <span class="hljs-title">class</span> <span class="hljs-title">ForwardIterator2</span>&gt;
<span class="hljs-title">ForwardIterator1</span> <span class="hljs-title">find_first_of</span>(
    <span class="hljs-title">ForwardIterator1</span>  <span class="hljs-title">first1</span>,
    <span class="hljs-title">ForwardIterator1</span> <span class="hljs-title">Last1</span>,
    <span class="hljs-title">ForwardIterator2</span>  <span class="hljs-title">first2</span>,
    <span class="hljs-title">ForwardIterator2</span> <span class="hljs-title">Last2</span>);</span>

<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ForwardIterator1</span>, <span class="hljs-title">class</span> <span class="hljs-title">ForwardIterator2</span>, <span class="hljs-title">class</span> <span class="hljs-title">BinaryPredicate</span>&gt;
<span class="hljs-title">ForwardIterator1</span> <span class="hljs-title">find_first_of</span>(
    <span class="hljs-title">ForwardIterator1</span>  <span class="hljs-title">first1</span>,
    <span class="hljs-title">ForwardIterator1</span> <span class="hljs-title">Last1</span>,
    <span class="hljs-title">ForwardIterator2</span>  <span class="hljs-title">first2</span>,
    <span class="hljs-title">ForwardIterator2</span> <span class="hljs-title">Last2</span>,
    <span class="hljs-title">BinaryPredicate</span>  <span class="hljs-title">comp</span>);</span>
</code></pre>
<h3 id="parameters-16" class="heading-with-anchor">Parameters<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#parameters-16"></a></h3>
<p><em>first1</em><br>
A forward iterator addressing the position of the first element in the range to be searched.</p>
<p><em>last1</em><br>
A forward iterator addressing the position one past the final element in the range to be searched.</p>
<p><em>first2</em><br>
A forward iterator addressing the position of the first element in the range to be matched.</p>
<p><em>last2</em><br>
A forward iterator addressing the position one past the final element in the range to be matched.</p>
<p><em>comp</em><br>
User-defined predicate function object that defines the condition to be satisfied if two elements are to be taken as equivalent. A binary predicate takes two arguments and returns <strong>true</strong> when satisfied and <strong>false</strong> when not satisfied.</p>
<h3 id="return-value-15" class="heading-with-anchor">Return Value<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#return-value-15"></a></h3>
<p>A forward iterator addressing the position of the first element of the first subsequence that matches the specified sequence or that is equivalent in a sense specified by a binary predicate.</p>
<h3 id="remarks-16" class="heading-with-anchor">Remarks<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#remarks-16"></a></h3>
<p>The <code>operator==</code> used to determine the match between an element and the specified value must impose an equivalence relation between its operands.</p>
<p>The ranges referenced must be valid; all pointers must be dereferenceable and, within each sequence, the last position is reachable from the first by incrementation.</p>
<h3 id="example-11" class="heading-with-anchor">Example<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#example-11"></a></h3>
<div class="codeHeader" id="code-try-34" data-bi-name="code-header"><span class="language">C++</span>
			<button class="action" data-bi-name="copy">
				<span class="docon docon-edit-copy" role="presentation"></span>
				<span>Copy</span>
			</button></div><pre><code class="lang-cpp" data-author-content="// alg_find_first_of.cpp
// compile with: /EHsc
#include &lt;vector&gt;
#include &lt;list&gt;
#include &lt;algorithm&gt;
#include &lt;iostream&gt;

// Return whether second element is twice the first
bool twice ( int elem1, int elem2 )
{
   return 2 * elem1 == elem2;
}

int main()
{
   using namespace std;
   vector &lt;int&gt; v1, v2;
   list &lt;int&gt; L1;
   vector &lt;int&gt;::iterator Iter1, Iter2;
   list &lt;int&gt;::iterator L1_Iter, L1_inIter;

   int i;
   for ( i = 0 ; i &lt;= 5 ; i++ )
   {
      v1.push_back( 5 * i );
   }
   for ( i = 0 ; i &lt;= 5 ; i++ )
   {
      v1.push_back( 5 * i );
   }

   int ii;
   for ( ii = 3 ; ii &lt;= 4 ; ii++ )
   {
      L1.push_back( 5 * ii );
   }

   int iii;
   for ( iii = 2 ; iii &lt;= 4 ; iii++ )
   {
      v2.push_back( 10 * iii );
   }

   cout &lt;&lt; &quot;Vector v1 = ( &quot; ;
   for ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ; Iter1++ )
      cout &lt;&lt; *Iter1 &lt;&lt; &quot; &quot;;
   cout &lt;&lt; &quot;)&quot; &lt;&lt; endl;

   cout &lt;&lt; &quot;List L1 = ( &quot; ;
   for ( L1_Iter = L1.begin( ) ; L1_Iter!= L1.end( ) ; L1_Iter++ )
      cout &lt;&lt; *L1_Iter &lt;&lt; &quot; &quot;;
   cout &lt;&lt; &quot;)&quot; &lt;&lt; endl;

   cout &lt;&lt; &quot;Vector v2 = ( &quot; ;
   for ( Iter2 = v2.begin( ) ; Iter2 != v2.end( ) ; Iter2++ )
      cout &lt;&lt; *Iter2 &lt;&lt; &quot; &quot;;
      cout &lt;&lt; &quot;)&quot; &lt;&lt; endl;

   // Searching v1 for first match to L1 under identity
   vector &lt;int&gt;::iterator result1;
   result1 = find_first_of ( v1.begin( ), v1.end( ), L1.begin( ), L1.end( ) );

   if ( result1 == v1.end( ) )
      cout &lt;&lt; &quot;There is no match of L1 in v1.&quot;
           &lt;&lt; endl;
   else
      cout &lt;&lt; &quot;There is at least one match of L1 in v1&quot;
           &lt;&lt; &quot;\n and the first one begins at &quot;
           &lt;&lt; &quot;position &quot;&lt;&lt; result1 - v1.begin( ) &lt;&lt; &quot;.&quot; &lt;&lt; endl;

   // Searching v1 for a match to L1 under the binary predicate twice
   vector &lt;int&gt;::iterator result2;
   result2 = find_first_of ( v1.begin( ), v1.end( ), v2.begin( ), v2.end( ), twice );

   if ( result2 == v1.end( ) )
      cout &lt;&lt; &quot;There is no match of L1 in v1.&quot;
           &lt;&lt; endl;
   else
      cout &lt;&lt; &quot;There is a sequence of elements in v1 that &quot;
           &lt;&lt; &quot;are equivalent\n to those in v2 under the binary &quot;
           &lt;&lt; &quot;predicate twice\n and the first one begins at position &quot;
           &lt;&lt; result2 - v1.begin( ) &lt;&lt; &quot;.&quot; &lt;&lt; endl;
}
"><span class="hljs-comment">// alg_find_first_of.cpp</span>
<span class="hljs-comment">// compile with: /EHsc</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;list&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span>

<span class="hljs-comment">// Return whether second element is twice the first</span>
<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">twice</span> <span class="hljs-params">( <span class="hljs-keyword">int</span> elem1, <span class="hljs-keyword">int</span> elem2 )</span>
</span>{
   <span class="hljs-keyword">return</span> <span class="hljs-number">2</span> * elem1 == elem2;
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
   <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;
   <span class="hljs-built_in">vector</span> &lt;<span class="hljs-keyword">int</span>&gt; v1, v2;
   <span class="hljs-built_in">list</span> &lt;<span class="hljs-keyword">int</span>&gt; L1;
   <span class="hljs-built_in">vector</span> &lt;<span class="hljs-keyword">int</span>&gt;::iterator Iter1, Iter2;
   <span class="hljs-built_in">list</span> &lt;<span class="hljs-keyword">int</span>&gt;::iterator L1_Iter, L1_inIter;

   <span class="hljs-keyword">int</span> i;
   <span class="hljs-keyword">for</span> ( i = <span class="hljs-number">0</span> ; i &lt;= <span class="hljs-number">5</span> ; i++ )
   {
      v1.push_back( <span class="hljs-number">5</span> * i );
   }
   <span class="hljs-keyword">for</span> ( i = <span class="hljs-number">0</span> ; i &lt;= <span class="hljs-number">5</span> ; i++ )
   {
      v1.push_back( <span class="hljs-number">5</span> * i );
   }

   <span class="hljs-keyword">int</span> ii;
   <span class="hljs-keyword">for</span> ( ii = <span class="hljs-number">3</span> ; ii &lt;= <span class="hljs-number">4</span> ; ii++ )
   {
      L1.push_back( <span class="hljs-number">5</span> * ii );
   }

   <span class="hljs-keyword">int</span> iii;
   <span class="hljs-keyword">for</span> ( iii = <span class="hljs-number">2</span> ; iii &lt;= <span class="hljs-number">4</span> ; iii++ )
   {
      v2.push_back( <span class="hljs-number">10</span> * iii );
   }

   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Vector v1 = ( "</span> ;
   <span class="hljs-keyword">for</span> ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ; Iter1++ )
      <span class="hljs-built_in">cout</span> &lt;&lt; *Iter1 &lt;&lt; <span class="hljs-string">" "</span>;
   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">")"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;

   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"List L1 = ( "</span> ;
   <span class="hljs-keyword">for</span> ( L1_Iter = L1.begin( ) ; L1_Iter!= L1.end( ) ; L1_Iter++ )
      <span class="hljs-built_in">cout</span> &lt;&lt; *L1_Iter &lt;&lt; <span class="hljs-string">" "</span>;
   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">")"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;

   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Vector v2 = ( "</span> ;
   <span class="hljs-keyword">for</span> ( Iter2 = v2.begin( ) ; Iter2 != v2.end( ) ; Iter2++ )
      <span class="hljs-built_in">cout</span> &lt;&lt; *Iter2 &lt;&lt; <span class="hljs-string">" "</span>;
      <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">")"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;

   <span class="hljs-comment">// Searching v1 for first match to L1 under identity</span>
   <span class="hljs-built_in">vector</span> &lt;<span class="hljs-keyword">int</span>&gt;::iterator result1;
   result1 = find_first_of ( v1.begin( ), v1.end( ), L1.begin( ), L1.end( ) );

   <span class="hljs-keyword">if</span> ( result1 == v1.end( ) )
      <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"There is no match of L1 in v1."</span>
           &lt;&lt; <span class="hljs-built_in">endl</span>;
   <span class="hljs-keyword">else</span>
      <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"There is at least one match of L1 in v1"</span>
           &lt;&lt; <span class="hljs-string">"\n and the first one begins at "</span>
           &lt;&lt; <span class="hljs-string">"position "</span>&lt;&lt; result1 - v1.begin( ) &lt;&lt; <span class="hljs-string">"."</span> &lt;&lt; <span class="hljs-built_in">endl</span>;

   <span class="hljs-comment">// Searching v1 for a match to L1 under the binary predicate twice</span>
   <span class="hljs-built_in">vector</span> &lt;<span class="hljs-keyword">int</span>&gt;::iterator result2;
   result2 = find_first_of ( v1.begin( ), v1.end( ), v2.begin( ), v2.end( ), twice );

   <span class="hljs-keyword">if</span> ( result2 == v1.end( ) )
      <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"There is no match of L1 in v1."</span>
           &lt;&lt; <span class="hljs-built_in">endl</span>;
   <span class="hljs-keyword">else</span>
      <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"There is a sequence of elements in v1 that "</span>
           &lt;&lt; <span class="hljs-string">"are equivalent\n to those in v2 under the binary "</span>
           &lt;&lt; <span class="hljs-string">"predicate twice\n and the first one begins at position "</span>
           &lt;&lt; result2 - v1.begin( ) &lt;&lt; <span class="hljs-string">"."</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
}
</code></pre>
<div class="codeHeader" id="code-try-35" data-bi-name="code-header"><span class="language">Output</span>
			<button class="action" data-bi-name="copy">
				<span class="docon docon-edit-copy" role="presentation"></span>
				<span>Copy</span>
			</button></div><pre><code class="lang-Output" data-author-content="Vector v1 = ( 0 5 10 15 20 25 0 5 10 15 20 25 )
List L1 = ( 15 20 )
Vector v2 = ( 20 30 40 )
There is at least one match of L1 in v1
and the first one begins at position 3.
There is a sequence of elements in v1 that are equivalent
to those in v2 under the binary predicate twice
and the first one begins at position 2.
">Vector v1 = ( 0 5 10 15 20 25 0 5 10 15 20 25 )
List L1 = ( 15 20 )
Vector v2 = ( 20 30 40 )
There is at least one match of L1 in v1
and the first one begins at position 3.
There is a sequence of elements in v1 that are equivalent
to those in v2 under the binary predicate twice
and the first one begins at position 2.
</code></pre>
<h2 id="find_if" class="heading-with-anchor">  find_if<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#find_if"></a></h2>
<p>Locates the position of the first occurrence of an element in a range that satisfies a specified condition.</p>
<div class="codeHeader" id="code-try-36" data-bi-name="code-header"><span class="language">C++</span>
			<button class="action" data-bi-name="copy">
				<span class="docon docon-edit-copy" role="presentation"></span>
				<span>Copy</span>
			</button></div><pre><code class="lang-cpp" data-author-content="template&lt;class InputIterator, class Predicate&gt;
InputIterator find_if(
    InputIterator first,
    InputIterator last,
    Predicate pred);
"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InputIterator</span>, <span class="hljs-title">class</span> <span class="hljs-title">Predicate</span>&gt;
<span class="hljs-title">InputIterator</span> <span class="hljs-title">find_if</span>(
    <span class="hljs-title">InputIterator</span> <span class="hljs-title">first</span>,
    <span class="hljs-title">InputIterator</span> <span class="hljs-title">last</span>,
    <span class="hljs-title">Predicate</span> <span class="hljs-title">pred</span>);</span>
</code></pre>
<h3 id="parameters-17" class="heading-with-anchor">Parameters<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#parameters-17"></a></h3>
<p><em>first</em><br>
An input iterator addressing the position of the first element in the range to be searched.</p>
<p><em>last</em><br>
An input iterator addressing the position one past the final element in the range to be searched.</p>
<p><em>pred</em><br>
User-defined predicate function object or <a href="https://docs.microsoft.com/en-us/cpp/cpp/lambda-expressions-in-cpp?view=vs-2019" data-linktype="relative-path">lambda expression</a> that defines the condition to be satisfied by the element being searched for. A predicate takes single argument and returns <strong>true</strong> (satisfied) or <strong>false</strong> (not satisfied). The signature of <em>pred</em> must effectively be <code>bool pred(const T&amp; arg);</code>, where <code>T</code> is a type to which <code>InputIterator</code> can be implicitly converted when dereferenced. The <strong>const</strong> keyword is shown only to illustrate that the function object or lambda should not modify the argument.</p>
<h3 id="return-value-16" class="heading-with-anchor">Return Value<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#return-value-16"></a></h3>
<p>An input iterator that refers to the first element in the range that satisfies the condition specified by the predicate (the predicate results in <strong>true</strong>). If no element is found to satisfy the predicate, returns <em>last</em>.</p>
<h3 id="remarks-17" class="heading-with-anchor">Remarks<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#remarks-17"></a></h3>
<p>This template function is a generalization of the algorithm <a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#find" data-linktype="relative-path">find</a>, replacing the predicate "equals a specific value" with any predicate. For the logical opposite (find the first element that does not satisfy the predicate), see <a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#find_if_not" data-linktype="relative-path">find_if_not</a>.</p>
<h3 id="example-12" class="heading-with-anchor">Example<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#example-12"></a></h3>
<div class="codeHeader" id="code-try-37" data-bi-name="code-header"><span class="language">C++</span>
			<button class="action" data-bi-name="copy">
				<span class="docon docon-edit-copy" role="presentation"></span>
				<span>Copy</span>
			</button></div><pre><code class="lang-cpp" data-author-content="// cl.exe /W4 /nologo /EHsc /MTd
#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;

using namespace std;

template &lt;typename S&gt; void print(const S&amp; s) {
for (const auto&amp; p : s) {
        cout &lt;&lt; &quot;(&quot; &lt;&lt; p &lt;&lt; &quot;) &quot;;
    }
    cout &lt;&lt; endl;
}

// Test std::find()
template &lt;class InputIterator, class T&gt;
void find_print_result(InputIterator first, InputIterator last, const T&amp; value) {

    // call &lt;algorithm&gt; std::find()
    auto p = find(first, last, value);

    cout &lt;&lt; &quot;value &quot; &lt;&lt; value;
    if (p == last) {
        cout &lt;&lt; &quot; not found.&quot; &lt;&lt; endl;
    } else {
        cout &lt;&lt; &quot; found.&quot; &lt;&lt; endl;
    }
}

// Test std::find_if()
template &lt;class InputIterator, class Predicate&gt;
void find_if_print_result(InputIterator first, InputIterator last,
    Predicate Pred, const string&amp; Str) {

    // call &lt;algorithm&gt; std::find_if()
    auto p = find_if(first, last, Pred);

    if (p == last) {
        cout &lt;&lt; Str &lt;&lt; &quot; not found.&quot; &lt;&lt; endl;
    } else {
        cout &lt;&lt; &quot;first &quot; &lt;&lt; Str &lt;&lt; &quot; found: &quot; &lt;&lt; *p &lt;&lt; endl;
    }
}

// Function to use as the UnaryPredicate argument to find_if() in this example
bool is_odd_int(int i) {
    return ((i % 2) != 0);
}

int main()
{
    // Test using a plain old array.
    const int x[] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };
    cout &lt;&lt; &quot;array x[] contents: &quot;;
    print(x);
    // Using non-member std::begin()/std::end() to get input iterators for the plain old array.
    cout &lt;&lt; &quot;Test std::find() with array...&quot; &lt;&lt; endl;
    find_print_result(begin(x), end(x), 10);
    find_print_result(begin(x), end(x), 42);
    cout &lt;&lt; &quot;Test std::find_if() with array...&quot; &lt;&lt; endl;
    find_if_print_result(begin(x), end(x), is_odd_int, &quot;odd integer&quot;); // function name
    find_if_print_result(begin(x), end(x), // lambda
        [](int i){ return ((i % 2) == 0); }, &quot;even integer&quot;);

    // Test using a vector.
    vector&lt;int&gt; v;
    for (int i = 0; i &lt; 10; ++i) {
        v.push_back((i + 1) * 10);
    }
    cout &lt;&lt; endl &lt;&lt; &quot;vector v contents: &quot;;
    print(v);
    cout &lt;&lt; &quot;Test std::find() with vector...&quot; &lt;&lt; endl;
    find_print_result(v.begin(), v.end(), 20);
    find_print_result(v.begin(), v.end(), 12);
    cout &lt;&lt; &quot;Test std::find_if() with vector...&quot; &lt;&lt; endl;
    find_if_print_result(v.begin(), v.end(), is_odd_int, &quot;odd integer&quot;);
    find_if_print_result(v.begin(), v.end(), // lambda
        [](int i){ return ((i % 2) == 0); }, &quot;even integer&quot;);
}
"><span class="hljs-comment">// cl.exe /W4 /nologo /EHsc /MTd</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span>

<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> S&gt; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-keyword">const</span> S&amp; s)</span> </span>{
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span>&amp; p : s) {
        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"("</span> &lt;&lt; p &lt;&lt; <span class="hljs-string">") "</span>;
    }
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
}

<span class="hljs-comment">// Test std::find()</span>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InputIterator</span>, <span class="hljs-title">class</span> <span class="hljs-title">T</span>&gt;
<span class="hljs-title">void</span> <span class="hljs-title">find_print_result</span>(<span class="hljs-title">InputIterator</span> <span class="hljs-title">first</span>, <span class="hljs-title">InputIterator</span> <span class="hljs-title">last</span>, <span class="hljs-title">const</span> <span class="hljs-title">T</span>&amp; <span class="hljs-title">value</span>) {</span>

    <span class="hljs-comment">// call &lt;algorithm&gt; std::find()</span>
    <span class="hljs-keyword">auto</span> p = find(first, last, value);

    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"value "</span> &lt;&lt; value;
    <span class="hljs-keyword">if</span> (p == last) {
        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">" not found."</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
    } <span class="hljs-keyword">else</span> {
        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">" found."</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
    }
}

<span class="hljs-comment">// Test std::find_if()</span>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InputIterator</span>, <span class="hljs-title">class</span> <span class="hljs-title">Predicate</span>&gt;
<span class="hljs-title">void</span> <span class="hljs-title">find_if_print_result</span>(<span class="hljs-title">InputIterator</span> <span class="hljs-title">first</span>, <span class="hljs-title">InputIterator</span> <span class="hljs-title">last</span>,
    <span class="hljs-title">Predicate</span> <span class="hljs-title">Pred</span>, <span class="hljs-title">const</span> <span class="hljs-title">string</span>&amp; <span class="hljs-title">Str</span>) {</span>

    <span class="hljs-comment">// call &lt;algorithm&gt; std::find_if()</span>
    <span class="hljs-keyword">auto</span> p = find_if(first, last, Pred);

    <span class="hljs-keyword">if</span> (p == last) {
        <span class="hljs-built_in">cout</span> &lt;&lt; Str &lt;&lt; <span class="hljs-string">" not found."</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
    } <span class="hljs-keyword">else</span> {
        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"first "</span> &lt;&lt; Str &lt;&lt; <span class="hljs-string">" found: "</span> &lt;&lt; *p &lt;&lt; <span class="hljs-built_in">endl</span>;
    }
}

<span class="hljs-comment">// Function to use as the UnaryPredicate argument to find_if() in this example</span>
<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">is_odd_int</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span> </span>{
    <span class="hljs-keyword">return</span> ((i % <span class="hljs-number">2</span>) != <span class="hljs-number">0</span>);
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-comment">// Test using a plain old array.</span>
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> x[] = { <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span> };
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"array x[] contents: "</span>;
    print(x);
    <span class="hljs-comment">// Using non-member std::begin()/std::end() to get input iterators for the plain old array.</span>
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Test std::find() with array..."</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
    find_print_result(begin(x), end(x), <span class="hljs-number">10</span>);
    find_print_result(begin(x), end(x), <span class="hljs-number">42</span>);
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Test std::find_if() with array..."</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
    find_if_print_result(begin(x), end(x), is_odd_int, <span class="hljs-string">"odd integer"</span>); <span class="hljs-comment">// function name</span>
    find_if_print_result(begin(x), end(x), <span class="hljs-comment">// lambda</span>
        [](<span class="hljs-keyword">int</span> i){ <span class="hljs-keyword">return</span> ((i % <span class="hljs-number">2</span>) == <span class="hljs-number">0</span>); }, <span class="hljs-string">"even integer"</span>);

    <span class="hljs-comment">// Test using a vector.</span>
    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; v;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; ++i) {
        v.push_back((i + <span class="hljs-number">1</span>) * <span class="hljs-number">10</span>);
    }
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">endl</span> &lt;&lt; <span class="hljs-string">"vector v contents: "</span>;
    print(v);
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Test std::find() with vector..."</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
    find_print_result(v.begin(), v.end(), <span class="hljs-number">20</span>);
    find_print_result(v.begin(), v.end(), <span class="hljs-number">12</span>);
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Test std::find_if() with vector..."</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
    find_if_print_result(v.begin(), v.end(), is_odd_int, <span class="hljs-string">"odd integer"</span>);
    find_if_print_result(v.begin(), v.end(), <span class="hljs-comment">// lambda</span>
        [](<span class="hljs-keyword">int</span> i){ <span class="hljs-keyword">return</span> ((i % <span class="hljs-number">2</span>) == <span class="hljs-number">0</span>); }, <span class="hljs-string">"even integer"</span>);
}
</code></pre>
<h2 id="find_if_not" class="heading-with-anchor">  find_if_not<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#find_if_not"></a></h2>
<p>Returns the first element in the indicated range that does not satisfy a condition.</p>
<div class="codeHeader" id="code-try-38" data-bi-name="code-header"><span class="language">C++</span>
			<button class="action" data-bi-name="copy">
				<span class="docon docon-edit-copy" role="presentation"></span>
				<span>Copy</span>
			</button></div><pre><code class="lang-cpp" data-author-content="template&lt;class InputIterator, class Predicate&gt;
InputIterator find_if_not(
    InputIterator first,
    InputIterator last,
    Predicate pred);
"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InputIterator</span>, <span class="hljs-title">class</span> <span class="hljs-title">Predicate</span>&gt;
<span class="hljs-title">InputIterator</span> <span class="hljs-title">find_if_not</span>(
    <span class="hljs-title">InputIterator</span> <span class="hljs-title">first</span>,
    <span class="hljs-title">InputIterator</span> <span class="hljs-title">last</span>,
    <span class="hljs-title">Predicate</span> <span class="hljs-title">pred</span>);</span>
</code></pre>
<h3 id="parameters-18" class="heading-with-anchor">Parameters<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#parameters-18"></a></h3>
<p><em>first</em><br>
An input iterator addressing the position of the first element in the range to be searched.</p>
<p><em>last</em><br>
An input iterator addressing the position one past the final element in the range to be searched.</p>
<p><em>pred</em><br>
User-defined predicate function object or <a href="https://docs.microsoft.com/en-us/cpp/cpp/lambda-expressions-in-cpp?view=vs-2019" data-linktype="relative-path">lambda expression</a> that defines the condition to be not satisfied by the element being searched for. A predicate takes single argument and returns <strong>true</strong> (satisfied) or <strong>false</strong> (not satisfied). The signature of <em>pred</em> must effectively be <code>bool pred(const T&amp; arg);</code>, where <code>T</code> is a type to which <code>InputIterator</code> can be implicitly converted when dereferenced. The <strong>const</strong> keyword is shown only to illustrate that the function object or lambda should not modify the argument.</p>
<h3 id="return-value-17" class="heading-with-anchor">Return Value<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#return-value-17"></a></h3>
<p>An input iterator that refers to the first element in the range that does not satisfy the condition specified by the predicate (the predicate results in <strong>false</strong>). If all elements satisfy the predicate (the predicate results in <strong>true</strong> for every element), returns <em>last</em>.</p>
<h3 id="remarks-18" class="heading-with-anchor">Remarks<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#remarks-18"></a></h3>
<p class="">This template function is a generalization of the algorithm <a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#find" data-linktype="relative-path">find</a>, replacing the predicate "equals a specific value" with any predicate. For the logical opposite (find the first element that does satisfy the predicate), see <a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#find_if" data-linktype="relative-path" class="">find_if</a>.</p>
<p>For a code example readily adaptable to <code>find_if_not()</code>, see <a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#find_if" data-linktype="relative-path">find_if</a>.</p>
<h2 id="for_each" class="heading-with-anchor">  for_each<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#for_each"></a></h2>
<p>Applies a specified function object to each element in a forward order within a range and returns the function object.</p>
<div class="codeHeader" id="code-try-39" data-bi-name="code-header"><span class="language">C++</span>
			<button class="action" data-bi-name="copy">
				<span class="docon docon-edit-copy" role="presentation"></span>
				<span>Copy</span>
			</button></div><pre><code class="lang-cpp" data-author-content="template&lt;class InputIterator, class Function&gt;
Function for_each(
    InputIterator first,
    InputIterator last,
    Function func);
"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InputIterator</span>, <span class="hljs-title">class</span> <span class="hljs-title">Function</span>&gt;
<span class="hljs-title">Function</span> <span class="hljs-title">for_each</span>(
    <span class="hljs-title">InputIterator</span> <span class="hljs-title">first</span>,
    <span class="hljs-title">InputIterator</span> <span class="hljs-title">last</span>,
    <span class="hljs-title">Function</span> <span class="hljs-title">func</span>);</span>
</code></pre>
<h3 id="parameters-19" class="heading-with-anchor">Parameters<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#parameters-19"></a></h3>
<p class=""><em>first</em><br>
An input iterator addressing the position of the first element in the range to be operated on.</p>
<p><em>last</em><br>
An input iterator addressing the position one past the final element in the range operated on.</p>
<p><em>_Func</em><br>
User-defined function object that is applied to each element in the range.</p>
<h3 id="return-value-18" class="heading-with-anchor">Return Value<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#return-value-18"></a></h3>
<p>A copy of the function object after it has been applied to all of the elements in the range.</p>
<h3 id="remarks-19" class="heading-with-anchor">Remarks<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#remarks-19"></a></h3>
<p>The algorithm <code>for_each</code> is very flexible, allowing the modification of each element within a range in different, user-specified ways. Templatized functions may be reused in a modified form by passing different parameters. User-defined functions may accumulate information within an internal state that the algorithm may return after processing all of the elements in the range.</p>
<p>The range referenced must be valid; all pointers must be dereferenceable and, within the sequence, the last position must be reachable from the first by incrementation.</p>
<p>The complexity is linear with at most ( <em>last</em> -  <em>first</em>) comparisons.</p>
<h3 id="example-13" class="heading-with-anchor">Example<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#example-13"></a></h3>
<div class="codeHeader" id="code-try-40" data-bi-name="code-header"><span class="language">C++</span>
			<button class="action" data-bi-name="copy">
				<span class="docon docon-edit-copy" role="presentation"></span>
				<span>Copy</span>
			</button></div><pre><code class="lang-cpp" data-author-content="// alg_for_each.cpp
// compile with: /EHsc
#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;iostream&gt;

// The function object multiplies an element by a Factor
template &lt;class Type&gt;
class MultValue
{
private:
   Type Factor;   // The value to multiply by
public:
   // Constructor initializes the value to multiply by
   MultValue ( const Type&amp; val ) : Factor ( val ) {
   }

   // The function call for the element to be multiplied
   void operator( ) ( Type&amp; elem ) const
   {
      elem *= Factor;
   }
};

// The function object to determine the average
class Average
{
private:
   long num;      // The number of elements
   long sum;      // The sum of the elements
public:
   // Constructor initializes the value to multiply by
   Average( ) : num ( 0 ) , sum ( 0 )
   {
   }

   // The function call to process the next elment
   void operator( ) ( int elem ) \
   {
      num++;      // Increment the element count
      sum += elem;   // Add the value to the partial sum
   }

   // return Average
   operator double( )
   {
      return  static_cast &lt;double&gt; (sum) /
      static_cast &lt;double&gt; (num);
   }
};

int main()
{
   using namespace std;
   vector &lt;int&gt; v1;
   vector &lt;int&gt;::iterator Iter1;

   // Constructing vector v1
   int i;
   for ( i = -4 ; i &lt;= 2 ; i++ )
   {
      v1.push_back(  i );
   }

   cout &lt;&lt; &quot;Original vector  v1 = ( &quot; ;
   for ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ; Iter1++ )
      cout &lt;&lt; *Iter1 &lt;&lt; &quot; &quot;;
   cout &lt;&lt; &quot;).&quot; &lt;&lt; endl;

   // Using for_each to multiply each element by a Factor
   for_each ( v1.begin( ), v1.end( ), MultValue&lt;int&gt; ( -2 ) );

   cout &lt;&lt; &quot;Multiplying the elements of the vector v1\n &quot;
        &lt;&lt;  &quot;by the factor -2 gives:\n v1mod1 = ( &quot; ;
   for ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ; Iter1++ )
      cout &lt;&lt; *Iter1 &lt;&lt; &quot; &quot;;
   cout &lt;&lt; &quot;).&quot; &lt;&lt; endl;

   // The function object is templatized and so can be
   // used again on the elements with a different Factor
   for_each (v1.begin( ), v1.end( ), MultValue&lt;int&gt; (5 ) );

   cout &lt;&lt; &quot;Multiplying the elements of the vector v1mod\n &quot;
        &lt;&lt;  &quot;by the factor 5 gives:\n v1mod2 = ( &quot; ;
   for ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ; Iter1++ )
      cout &lt;&lt; *Iter1 &lt;&lt; &quot; &quot;;
   cout &lt;&lt; &quot;).&quot; &lt;&lt; endl;

   // The local state of a function object can accumulate
   // information about a sequence of actions that the
   // return value can make available, here the Average
   double avemod2 = for_each ( v1.begin( ), v1.end( ),
      Average( ) );
   cout &lt;&lt; &quot;The average of the elements of v1 is:\n Average ( v1mod2 ) = &quot;
        &lt;&lt; avemod2 &lt;&lt; &quot;.&quot; &lt;&lt; endl;
}
"><span class="hljs-comment">// alg_for_each.cpp</span>
<span class="hljs-comment">// compile with: /EHsc</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span>

<span class="hljs-comment">// The function object multiplies an element by a Factor</span>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Type</span>&gt;
<span class="hljs-title">class</span> <span class="hljs-title">MultValue</span>
{</span>
<span class="hljs-keyword">private</span>:
   Type Factor;   <span class="hljs-comment">// The value to multiply by</span>
<span class="hljs-keyword">public</span>:
   <span class="hljs-comment">// Constructor initializes the value to multiply by</span>
   MultValue ( <span class="hljs-keyword">const</span> Type&amp; val ) : Factor ( val ) {
   }

   <span class="hljs-comment">// The function call for the element to be multiplied</span>
   <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">operator</span><span class="hljs-params">( )</span> <span class="hljs-params">( Type&amp; elem )</span> <span class="hljs-keyword">const</span>
   </span>{
      elem *= Factor;
   }
};

<span class="hljs-comment">// The function object to determine the average</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Average</span>
{</span>
<span class="hljs-keyword">private</span>:
   <span class="hljs-keyword">long</span> num;      <span class="hljs-comment">// The number of elements</span>
   <span class="hljs-keyword">long</span> sum;      <span class="hljs-comment">// The sum of the elements</span>
<span class="hljs-keyword">public</span>:
   <span class="hljs-comment">// Constructor initializes the value to multiply by</span>
   Average( ) : num ( <span class="hljs-number">0</span> ) , sum ( <span class="hljs-number">0</span> )
   {
   }

   <span class="hljs-comment">// The function call to process the next elment</span>
   <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">operator</span><span class="hljs-params">( )</span> <span class="hljs-params">( <span class="hljs-keyword">int</span> elem )</span> \
   </span>{
      num++;      <span class="hljs-comment">// Increment the element count</span>
      sum += elem;   <span class="hljs-comment">// Add the value to the partial sum</span>
   }

   <span class="hljs-comment">// return Average</span>
   <span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">double</span><span class="hljs-params">( )</span>
   </span>{
      <span class="hljs-keyword">return</span>  <span class="hljs-keyword">static_cast</span> &lt;<span class="hljs-keyword">double</span>&gt; (sum) /
      <span class="hljs-keyword">static_cast</span> &lt;<span class="hljs-keyword">double</span>&gt; (num);
   }
};

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
   <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;
   <span class="hljs-built_in">vector</span> &lt;<span class="hljs-keyword">int</span>&gt; v1;
   <span class="hljs-built_in">vector</span> &lt;<span class="hljs-keyword">int</span>&gt;::iterator Iter1;

   <span class="hljs-comment">// Constructing vector v1</span>
   <span class="hljs-keyword">int</span> i;
   <span class="hljs-keyword">for</span> ( i = <span class="hljs-number">-4</span> ; i &lt;= <span class="hljs-number">2</span> ; i++ )
   {
      v1.push_back(  i );
   }

   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Original vector  v1 = ( "</span> ;
   <span class="hljs-keyword">for</span> ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ; Iter1++ )
      <span class="hljs-built_in">cout</span> &lt;&lt; *Iter1 &lt;&lt; <span class="hljs-string">" "</span>;
   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">")."</span> &lt;&lt; <span class="hljs-built_in">endl</span>;

   <span class="hljs-comment">// Using for_each to multiply each element by a Factor</span>
   for_each ( v1.begin( ), v1.end( ), MultValue&lt;<span class="hljs-keyword">int</span>&gt; ( <span class="hljs-number">-2</span> ) );

   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Multiplying the elements of the vector v1\n "</span>
        &lt;&lt;  <span class="hljs-string">"by the factor -2 gives:\n v1mod1 = ( "</span> ;
   <span class="hljs-keyword">for</span> ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ; Iter1++ )
      <span class="hljs-built_in">cout</span> &lt;&lt; *Iter1 &lt;&lt; <span class="hljs-string">" "</span>;
   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">")."</span> &lt;&lt; <span class="hljs-built_in">endl</span>;

   <span class="hljs-comment">// The function object is templatized and so can be</span>
   <span class="hljs-comment">// used again on the elements with a different Factor</span>
   for_each (v1.begin( ), v1.end( ), MultValue&lt;<span class="hljs-keyword">int</span>&gt; (<span class="hljs-number">5</span> ) );

   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Multiplying the elements of the vector v1mod\n "</span>
        &lt;&lt;  <span class="hljs-string">"by the factor 5 gives:\n v1mod2 = ( "</span> ;
   <span class="hljs-keyword">for</span> ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ; Iter1++ )
      <span class="hljs-built_in">cout</span> &lt;&lt; *Iter1 &lt;&lt; <span class="hljs-string">" "</span>;
   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">")."</span> &lt;&lt; <span class="hljs-built_in">endl</span>;

   <span class="hljs-comment">// The local state of a function object can accumulate</span>
   <span class="hljs-comment">// information about a sequence of actions that the</span>
   <span class="hljs-comment">// return value can make available, here the Average</span>
   <span class="hljs-keyword">double</span> avemod2 = for_each ( v1.begin( ), v1.end( ),
      Average( ) );
   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"The average of the elements of v1 is:\n Average ( v1mod2 ) = "</span>
        &lt;&lt; avemod2 &lt;&lt; <span class="hljs-string">"."</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
}
</code></pre>
<div class="codeHeader" id="code-try-41" data-bi-name="code-header"><span class="language">Output</span>
			<button class="action" data-bi-name="copy">
				<span class="docon docon-edit-copy" role="presentation"></span>
				<span>Copy</span>
			</button></div><pre><code class="lang-Output" data-author-content="Original vector  v1 = ( -4 -3 -2 -1 0 1 2 ).
Multiplying the elements of the vector v1
by the factor -2 gives:
v1mod1 = ( 8 6 4 2 0 -2 -4 ).
Multiplying the elements of the vector v1mod
by the factor 5 gives:
v1mod2 = ( 40 30 20 10 0 -10 -20 ).
The average of the elements of v1 is:
Average ( v1mod2 ) = 10.
">Original vector  v1 = ( -4 -3 -2 -1 0 1 2 ).
Multiplying the elements of the vector v1
by the factor -2 gives:
v1mod1 = ( 8 6 4 2 0 -2 -4 ).
Multiplying the elements of the vector v1mod
by the factor 5 gives:
v1mod2 = ( 40 30 20 10 0 -10 -20 ).
The average of the elements of v1 is:
Average ( v1mod2 ) = 10.
</code></pre>
<h2 id="generate" class="heading-with-anchor">  generate<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#generate"></a></h2>
<p>Assigns the values generated by a function object to each element in a range.</p>
<div class="codeHeader" id="code-try-42" data-bi-name="code-header"><span class="language">C++</span>
			<button class="action" data-bi-name="copy">
				<span class="docon docon-edit-copy" role="presentation"></span>
				<span>Copy</span>
			</button></div><pre><code class="lang-cpp" data-author-content="template&lt;class ForwardIterator, class Generator&gt;
void generate(
    ForwardIterator first,
    ForwardIterator last,
    Generator _Gen);
"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ForwardIterator</span>, <span class="hljs-title">class</span> <span class="hljs-title">Generator</span>&gt;
<span class="hljs-title">void</span> <span class="hljs-title">generate</span>(
    <span class="hljs-title">ForwardIterator</span> <span class="hljs-title">first</span>,
    <span class="hljs-title">ForwardIterator</span> <span class="hljs-title">last</span>,
    <span class="hljs-title">Generator</span> _<span class="hljs-title">Gen</span>);</span>
</code></pre>
<h3 id="parameters-20" class="heading-with-anchor">Parameters<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#parameters-20"></a></h3>
<p><em>first</em><br>
A forward iterator addressing the position of the first element in the range to which values are to be assigned.</p>
<p><em>last</em><br>
A forward iterator addressing the position one past the final element in the range to which values are to be assigned.</p>
<p><em>_Gen</em><br>
A function object that is called with no arguments that is used to generate the values to be assigned to each of the elements in the range.</p>
<h3 id="remarks-20" class="heading-with-anchor">Remarks<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#remarks-20"></a></h3>
<p>The function object is invoked for each element in the range and does not need to return the same value each time it is called. It may, for example, read from a file or refer to and modify a local state. The generator's result type must be convertible to the value type of the forward iterators for the range.</p>
<p>The range referenced must be valid; all pointers must be dereferenceable and, within the sequence, the last position must be reachable from the first by incrementation.</p>
<p>The complexity is linear, with exactly ( <code>last</code> -  <code>first</code>) calls to the generator being required.</p>
<h3 id="example-14" class="heading-with-anchor">Example<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#example-14"></a></h3>
<div class="codeHeader" id="code-try-43" data-bi-name="code-header"><span class="language">C++</span>
			<button class="action" data-bi-name="copy">
				<span class="docon docon-edit-copy" role="presentation"></span>
				<span>Copy</span>
			</button></div><pre><code class="lang-cpp" data-author-content="// alg_generate.cpp
// compile with: /EHsc
#include &lt;vector&gt;
#include &lt;deque&gt;
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;ostream&gt;

int main()
{
   using namespace std;

   // Assigning random values to vector integer elements
   vector &lt;int&gt; v1 ( 5 );
   vector &lt;int&gt;::iterator Iter1;
   deque &lt;int&gt; deq1 ( 5 );
   deque &lt;int&gt;::iterator d1_Iter;

   generate ( v1.begin( ), v1.end( ), rand );

   cout &lt;&lt; &quot;Vector v1 is ( &quot; ;
   for ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ; Iter1++ )
      cout &lt;&lt; *Iter1 &lt;&lt; &quot; &quot;;
   cout &lt;&lt; &quot;).&quot; &lt;&lt; endl;

   // Assigning random values to deque integer elements
   generate ( deq1.begin( ), deq1.end( ), rand );

   cout &lt;&lt; &quot;Deque deq1 is ( &quot; ;
   for ( d1_Iter = deq1.begin( ) ; d1_Iter != deq1.end( ) ; d1_Iter++ )
      cout &lt;&lt; *d1_Iter &lt;&lt; &quot; &quot;;
   cout &lt;&lt; &quot;).&quot; &lt;&lt; endl;
}
"><span class="hljs-comment">// alg_generate.cpp</span>
<span class="hljs-comment">// compile with: /EHsc</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;deque&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;ostream&gt;</span></span>

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
   <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;

   <span class="hljs-comment">// Assigning random values to vector integer elements</span>
   <span class="hljs-built_in">vector</span> &lt;<span class="hljs-keyword">int</span>&gt; v1 ( <span class="hljs-number">5</span> );
   <span class="hljs-built_in">vector</span> &lt;<span class="hljs-keyword">int</span>&gt;::iterator Iter1;
   <span class="hljs-built_in">deque</span> &lt;<span class="hljs-keyword">int</span>&gt; deq1 ( <span class="hljs-number">5</span> );
   <span class="hljs-built_in">deque</span> &lt;<span class="hljs-keyword">int</span>&gt;::iterator d1_Iter;

   generate ( v1.begin( ), v1.end( ), rand );

   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Vector v1 is ( "</span> ;
   <span class="hljs-keyword">for</span> ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ; Iter1++ )
      <span class="hljs-built_in">cout</span> &lt;&lt; *Iter1 &lt;&lt; <span class="hljs-string">" "</span>;
   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">")."</span> &lt;&lt; <span class="hljs-built_in">endl</span>;

   <span class="hljs-comment">// Assigning random values to deque integer elements</span>
   generate ( deq1.begin( ), deq1.end( ), rand );

   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Deque deq1 is ( "</span> ;
   <span class="hljs-keyword">for</span> ( d1_Iter = deq1.begin( ) ; d1_Iter != deq1.end( ) ; d1_Iter++ )
      <span class="hljs-built_in">cout</span> &lt;&lt; *d1_Iter &lt;&lt; <span class="hljs-string">" "</span>;
   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">")."</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
}
</code></pre>
<div class="codeHeader" id="code-try-44" data-bi-name="code-header"><span class="language">Output</span>
			<button class="action" data-bi-name="copy">
				<span class="docon docon-edit-copy" role="presentation"></span>
				<span>Copy</span>
			</button></div><pre><code class="lang-Output" data-author-content="Vector v1 is ( 41 18467 6334 26500 19169 ).
Deque deq1 is ( 15724 11478 29358 26962 24464 ).
">Vector v1 is ( 41 18467 6334 26500 19169 ).
Deque deq1 is ( 15724 11478 29358 26962 24464 ).
</code></pre>
<h2 id="generate_n" class="heading-with-anchor">  generate_n<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#generate_n"></a></h2>
<p>Assigns the values generated by a function object to a specified number of elements in a range and returns to the position one past the last assigned value.</p>
<div class="codeHeader" id="code-try-45" data-bi-name="code-header"><span class="language">C++</span>
			<button class="action" data-bi-name="copy">
				<span class="docon docon-edit-copy" role="presentation"></span>
				<span>Copy</span>
			</button></div><pre><code class="lang-cpp" data-author-content="template&lt;class OutputIterator, class Diff, class Generator&gt;
void generate_n(
    OutputIterator First,
    Diff Count,
    Generator Gen);
"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OutputIterator</span>, <span class="hljs-title">class</span> <span class="hljs-title">Diff</span>, <span class="hljs-title">class</span> <span class="hljs-title">Generator</span>&gt;
<span class="hljs-title">void</span> <span class="hljs-title">generate_n</span>(
    <span class="hljs-title">OutputIterator</span> <span class="hljs-title">First</span>,
    <span class="hljs-title">Diff</span> <span class="hljs-title">Count</span>,
    <span class="hljs-title">Generator</span> <span class="hljs-title">Gen</span>);</span>
</code></pre>
<h3 id="parameters-21" class="heading-with-anchor">Parameters<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#parameters-21"></a></h3>
<p><em>First</em><br>
An output iterator addressing the position of first element in the range to which values are to be assigned.</p>
<p><em>Count</em><br>
A signed or unsigned integer type specifying the number of elements to be assigned a value by the generator function.</p>
<p><em>Gen</em><br>
A function object that is called with no arguments that is used to generate the values to be assigned to each of the elements in the range.</p>
<h3 id="remarks-21" class="heading-with-anchor">Remarks<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#remarks-21"></a></h3>
<p>The function object is invoked for each element in the range and does not need to return the same value each time it is called. It may, for example, read from a file or refer to and modify a local state. The generator's result type must be convertible to the value type of the forward iterators for the range.</p>
<p>The range referenced must be valid; all pointers must be dereferenceable and, within the sequence, the last position must be reachable from the first by incrementation.</p>
<p>The complexity is linear, with exactly <code>Count</code> calls to the generator being required.</p>
<h3 id="example-15" class="heading-with-anchor">Example<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#example-15"></a></h3>
<div class="codeHeader" id="code-try-46" data-bi-name="code-header"><span class="language">C++</span>
			<button class="action" data-bi-name="copy">
				<span class="docon docon-edit-copy" role="presentation"></span>
				<span>Copy</span>
			</button></div><pre><code class="lang-cpp" data-author-content="// cl.exe /EHsc /nologo /W4 /MTd
#include &lt;vector&gt;
#include &lt;deque&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;algorithm&gt;
#include &lt;random&gt;

using namespace std;

template &lt;typename C&gt; void print(const string&amp; s, const C&amp; c) {
    cout &lt;&lt; s;

    for (const auto&amp; e : c) {
        cout &lt;&lt; e &lt;&lt; &quot; &quot;;
    }

    cout &lt;&lt; endl;
}

int main()
{
    const int elemcount = 5;
    vector&lt;int&gt; v(elemcount);
    deque&lt;int&gt; dq(elemcount);

    // Set up random number distribution
    random_device rd;
    mt19937 engine(rd());
    uniform_int_distribution&lt;int&gt; dist(-9, 9);

    // Call generate_n, using a lambda for the third parameter
    generate_n(v.begin(), elemcount, [&amp;](){ return dist(engine); });
    print(&quot;vector v is: &quot;, v);

    generate_n(dq.begin(), elemcount, [&amp;](){ return dist(engine); });
    print(&quot;deque dq is: &quot;, dq);
}
"><span class="hljs-comment">// cl.exe /EHsc /nologo /W4 /MTd</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;deque&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;random&gt;</span></span>

<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> C&gt; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span>&amp; s, <span class="hljs-keyword">const</span> C&amp; c)</span> </span>{
    <span class="hljs-built_in">cout</span> &lt;&lt; s;

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span>&amp; e : c) {
        <span class="hljs-built_in">cout</span> &lt;&lt; e &lt;&lt; <span class="hljs-string">" "</span>;
    }

    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> elemcount = <span class="hljs-number">5</span>;
    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; v(elemcount);
    <span class="hljs-built_in">deque</span>&lt;<span class="hljs-keyword">int</span>&gt; dq(elemcount);

    <span class="hljs-comment">// Set up random number distribution</span>
    random_device rd;
    <span class="hljs-function">mt19937 <span class="hljs-title">engine</span><span class="hljs-params">(rd()</span>)</span>;
    uniform_int_distribution&lt;<span class="hljs-keyword">int</span>&gt; dist(<span class="hljs-number">-9</span>, <span class="hljs-number">9</span>);

    <span class="hljs-comment">// Call generate_n, using a lambda for the third parameter</span>
    generate_n(v.begin(), elemcount, [&amp;](){ <span class="hljs-keyword">return</span> dist(engine); });
    print(<span class="hljs-string">"vector v is: "</span>, v);

    generate_n(dq.begin(), elemcount, [&amp;](){ <span class="hljs-keyword">return</span> dist(engine); });
    print(<span class="hljs-string">"deque dq is: "</span>, dq);
}
</code></pre>
<h2 id="includes" class="heading-with-anchor">  includes<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#includes"></a></h2>
<p>Tests whether one sorted range contains all the elements contained in a second sorted range, where the ordering or equivalence criterion between elements may be specified by a binary predicate.</p>
<div class="codeHeader" id="code-try-47" data-bi-name="code-header"><span class="language">C++</span>
			<button class="action" data-bi-name="copy">
				<span class="docon docon-edit-copy" role="presentation"></span>
				<span>Copy</span>
			</button></div><pre><code class="lang-cpp" data-author-content="template&lt;class InputIterator1, class InputIterator2&gt;
bool includes(
    InputIterator1 first1,
    InputIterator1 last1,
    InputIterator2 first2,
    InputIterator2 last2);

template&lt;class InputIterator1, class InputIterator2, class BinaryPredicate&gt;
bool includes(
    InputIterator1 first1,
    InputIterator1 last1,
    InputIterator2 first2,
    InputIterator2 last2,
    BinaryPredicate comp );
"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InputIterator1</span>, <span class="hljs-title">class</span> <span class="hljs-title">InputIterator2</span>&gt;
<span class="hljs-title">bool</span> <span class="hljs-title">includes</span>(
    <span class="hljs-title">InputIterator1</span> <span class="hljs-title">first1</span>,
    <span class="hljs-title">InputIterator1</span> <span class="hljs-title">last1</span>,
    <span class="hljs-title">InputIterator2</span> <span class="hljs-title">first2</span>,
    <span class="hljs-title">InputIterator2</span> <span class="hljs-title">last2</span>);</span>

<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InputIterator1</span>, <span class="hljs-title">class</span> <span class="hljs-title">InputIterator2</span>, <span class="hljs-title">class</span> <span class="hljs-title">BinaryPredicate</span>&gt;
<span class="hljs-title">bool</span> <span class="hljs-title">includes</span>(
    <span class="hljs-title">InputIterator1</span> <span class="hljs-title">first1</span>,
    <span class="hljs-title">InputIterator1</span> <span class="hljs-title">last1</span>,
    <span class="hljs-title">InputIterator2</span> <span class="hljs-title">first2</span>,
    <span class="hljs-title">InputIterator2</span> <span class="hljs-title">last2</span>,
    <span class="hljs-title">BinaryPredicate</span> <span class="hljs-title">comp</span> );</span>
</code></pre>
<h3 id="parameters-22" class="heading-with-anchor">Parameters<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#parameters-22"></a></h3>
<p><em>first1</em><br>
An input iterator addressing the position of the first element in the first of two sorted source ranges to be tested for whether all the elements of the second are contained in the first.</p>
<p><em>last1</em><br>
An input iterator addressing the position one past the last element in the first of two sorted source ranges to be tested for whether all the elements of the second are contained in the first.</p>
<p><em>first2</em><br>
An input iterator addressing the position of the first element in second of two consecutive sorted source ranges to be tested for whether all the elements of the second are contained in the first.</p>
<p><em>last2</em><br>
An input iterator addressing the position one past the last element in second of two consecutive sorted source ranges to be tested for whether all the elements of the second are contained in the first.</p>
<p><em>comp</em><br>
User-defined predicate function object that defines sense in which one element is less than another. A binary predicate takes two arguments and returns <strong>true</strong> when satisfied and <strong>false</strong> when not satisfied.</p>
<h3 id="return-value-19" class="heading-with-anchor">Return Value<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#return-value-19"></a></h3>
<p><strong>true</strong> if the first sorted range contains all the elements in the second sorted range; otherwise, <strong>false</strong>.</p>
<h3 id="remarks-22" class="heading-with-anchor">Remarks<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#remarks-22"></a></h3>
<p>Another way to think of this test is that it determined whether the second source range is a subset of the first source range.</p>
<p>The sorted source ranges referenced must be valid; all pointers must be dereferenceable and, within each sequence, the last position must be reachable from the first by incrementation.</p>
<p>The sorted source ranges must each be arranged as a precondition to the application of the algorithm includes in accordance with the same ordering as is to be used by the algorithm to sort the combined ranges.</p>
<p>The source ranges are not modified by the algorithm <code>merge</code>.</p>
<p>The value types of the input iterators need be less-than comparable to be ordered, so that, given two elements, it may be determined either that they are equivalent (in the sense that neither is less than the other) or that one is less than the other. This results in an ordering between the nonequivalent elements. More precisely, the algorithm tests whether all the elements in the first sorted range under a specified binary predicate have equivalent ordering to those in the second sorted range.</p>
<p>The complexity of the algorithm is linear with at most 2 * ( ( <em>last1 - first1</em>) - ( * last2 - first2*) ) - 1 comparisons for nonempty source ranges.</p>
<h3 id="example-16" class="heading-with-anchor">Example<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#example-16"></a></h3>
<div class="codeHeader" id="code-try-48" data-bi-name="code-header"><span class="language">C++</span>
			<button class="action" data-bi-name="copy">
				<span class="docon docon-edit-copy" role="presentation"></span>
				<span>Copy</span>
			</button></div><pre><code class="lang-cpp" data-author-content="// alg_includes.cpp
// compile with: /EHsc
#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;functional&gt;      // For greater&lt;int&gt;( )
#include &lt;iostream&gt;

// Return whether modulus of elem1 is less than modulus of elem2
bool mod_lesser (int elem1, int elem2 )
{
   if ( elem1 &lt; 0 )
      elem1 = - elem1;
   if ( elem2 &lt; 0 )
      elem2 = - elem2;
   return elem1 &lt; elem2;
}

int main()
{
   using namespace std;
   vector &lt;int&gt; v1a, v1b;
   vector &lt;int&gt;::iterator Iter1a,  Iter1b;

   // Constructing vectors v1a &amp; v1b with default less-than ordering
   int i;
   for ( i = -2 ; i &lt;= 4 ; i++ )
   {
      v1a.push_back(  i );
   }

   int ii;
   for ( ii =-2 ; ii &lt;= 3 ; ii++ )
   {
      v1b.push_back(  ii  );
   }

   cout &lt;&lt; &quot;Original vector v1a with range sorted by the\n &quot;
        &lt;&lt; &quot;binary predicate less than is v1a = ( &quot; ;
   for ( Iter1a = v1a.begin( ) ; Iter1a != v1a.end( ) ; Iter1a++ )
      cout &lt;&lt; *Iter1a &lt;&lt; &quot; &quot;;
   cout &lt;&lt; &quot;).&quot; &lt;&lt; endl;

   cout &lt;&lt; &quot;Original vector v1b with range sorted by the\n &quot;
        &lt;&lt;  &quot;binary predicate less than is v1b = ( &quot; ;
   for ( Iter1b = v1b.begin( ) ; Iter1b != v1b.end( ) ; Iter1b++ )
      cout &lt;&lt; *Iter1b &lt;&lt; &quot; &quot;;
   cout &lt;&lt; &quot;).&quot; &lt;&lt; endl;

   // Constructing vectors v2a &amp; v2b with ranges sorted by greater
   vector &lt;int&gt; v2a ( v1a ) , v2b ( v1b );
   vector &lt;int&gt;::iterator Iter2a,  Iter2b;
   sort ( v2a.begin( ), v2a.end( ), greater&lt;int&gt;( ) );
   sort ( v2b.begin( ), v2b.end( ), greater&lt;int&gt;( ) );
   v2a.pop_back( );

   cout &lt;&lt; &quot;Original vector v2a with range sorted by the\n &quot;
        &lt;&lt;  &quot;binary predicate greater is v2a = ( &quot; ;
   for ( Iter2a = v2a.begin( ) ; Iter2a != v2a.end( ) ; Iter2a++ )
      cout &lt;&lt; *Iter2a &lt;&lt; &quot; &quot;;
   cout &lt;&lt; &quot;).&quot; &lt;&lt; endl;

   cout &lt;&lt; &quot;Original vector v2b with range sorted by the\n &quot;
        &lt;&lt;  &quot;binary predicate greater is v2b = ( &quot; ;
   for ( Iter2b = v2b.begin( ) ; Iter2b != v2b.end( ) ; Iter2b++ )
      cout &lt;&lt; *Iter2b &lt;&lt; &quot; &quot;;
   cout &lt;&lt; &quot;).&quot; &lt;&lt; endl;

   // Constructing vectors v3a &amp; v3b with ranges sorted by mod_lesser
   vector &lt;int&gt; v3a ( v1a ), v3b ( v1b ) ;
   vector &lt;int&gt;::iterator Iter3a, Iter3b;
   reverse (v3a.begin( ), v3a.end( ) );
   v3a.pop_back( );
   v3a.pop_back( );
   sort ( v3a.begin( ), v3a.end( ), mod_lesser );
   sort ( v3b.begin( ), v3b.end( ), mod_lesser );

   cout &lt;&lt; &quot;Original vector v3a with range sorted by the\n &quot;
        &lt;&lt;  &quot;binary predicate mod_lesser is v3a = ( &quot; ;
   for ( Iter3a = v3a.begin( ) ; Iter3a != v3a.end( ) ; Iter3a++ )
      cout &lt;&lt; *Iter3a &lt;&lt; &quot; &quot;;
   cout &lt;&lt; &quot;).&quot; &lt;&lt; endl;

   cout &lt;&lt; &quot;Original vector v3b with range sorted by the\n &quot;
        &lt;&lt;  &quot;binary predicate mod_lesser is v3b = ( &quot; ;
   for ( Iter3b = v3b.begin( ) ; Iter3b != v3b.end( ) ; Iter3b++ )
      cout &lt;&lt; *Iter3b &lt;&lt; &quot; &quot;;
   cout &lt;&lt; &quot;).&quot; &lt;&lt; endl;

   // To test for inclusion under an asscending order
   // with the default binary predicate less &lt;int&gt;( )
   bool Result1;
   Result1 = includes ( v1a.begin( ), v1a.end( ),
      v1b.begin( ), v1b.end( ) );
   if ( Result1 )
      cout &lt;&lt; &quot;All the elements in vector v1b are &quot;
           &lt;&lt; &quot;contained in vector v1a.&quot; &lt;&lt; endl;
   else
      cout &lt;&lt; &quot;At least one of the elements in vector v1b &quot;
           &lt;&lt; &quot;is not contained in vector v1a.&quot; &lt;&lt; endl;

   // To test for inclusion under descending
   // order specify binary predicate greater&lt;int&gt;( )
   bool Result2;
   Result2 = includes ( v2a.begin( ), v2a.end( ),
      v2b.begin( ), v2b.end( ), greater &lt;int&gt;( ) );
   if ( Result2 )
      cout &lt;&lt; &quot;All the elements in vector v2b are &quot;
           &lt;&lt; &quot;contained in vector v2a.&quot; &lt;&lt; endl;
   else
      cout &lt;&lt; &quot;At least one of the elements in vector v2b &quot;
           &lt;&lt; &quot;is not contained in vector v2a.&quot; &lt;&lt; endl;

   // To test for inclusion under a user
   // defined binary predicate mod_lesser
   bool Result3;
   Result3 = includes ( v3a.begin( ), v3a.end( ),
      v3b.begin( ), v3b.end( ), mod_lesser );
   if ( Result3 )
      cout &lt;&lt; &quot;All the elements in vector v3b are &quot;
           &lt;&lt; &quot;contained under mod_lesser in vector v3a.&quot;
           &lt;&lt; endl;
   else
      cout &lt;&lt; &quot;At least one of the elements in vector v3b is &quot;
           &lt;&lt; &quot; not contained under mod_lesser in vector v3a.&quot;
           &lt;&lt; endl;
}
"><span class="hljs-comment">// alg_includes.cpp</span>
<span class="hljs-comment">// compile with: /EHsc</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;functional&gt;      // For greater&lt;int&gt;( )</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span>

<span class="hljs-comment">// Return whether modulus of elem1 is less than modulus of elem2</span>
<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">mod_lesser</span> <span class="hljs-params">(<span class="hljs-keyword">int</span> elem1, <span class="hljs-keyword">int</span> elem2 )</span>
</span>{
   <span class="hljs-keyword">if</span> ( elem1 &lt; <span class="hljs-number">0</span> )
      elem1 = - elem1;
   <span class="hljs-keyword">if</span> ( elem2 &lt; <span class="hljs-number">0</span> )
      elem2 = - elem2;
   <span class="hljs-keyword">return</span> elem1 &lt; elem2;
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
   <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;
   <span class="hljs-built_in">vector</span> &lt;<span class="hljs-keyword">int</span>&gt; v1a, v1b;
   <span class="hljs-built_in">vector</span> &lt;<span class="hljs-keyword">int</span>&gt;::iterator Iter1a,  Iter1b;

   <span class="hljs-comment">// Constructing vectors v1a &amp; v1b with default less-than ordering</span>
   <span class="hljs-keyword">int</span> i;
   <span class="hljs-keyword">for</span> ( i = <span class="hljs-number">-2</span> ; i &lt;= <span class="hljs-number">4</span> ; i++ )
   {
      v1a.push_back(  i );
   }

   <span class="hljs-keyword">int</span> ii;
   <span class="hljs-keyword">for</span> ( ii =<span class="hljs-number">-2</span> ; ii &lt;= <span class="hljs-number">3</span> ; ii++ )
   {
      v1b.push_back(  ii  );
   }

   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Original vector v1a with range sorted by the\n "</span>
        &lt;&lt; <span class="hljs-string">"binary predicate less than is v1a = ( "</span> ;
   <span class="hljs-keyword">for</span> ( Iter1a = v1a.begin( ) ; Iter1a != v1a.end( ) ; Iter1a++ )
      <span class="hljs-built_in">cout</span> &lt;&lt; *Iter1a &lt;&lt; <span class="hljs-string">" "</span>;
   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">")."</span> &lt;&lt; <span class="hljs-built_in">endl</span>;

   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Original vector v1b with range sorted by the\n "</span>
        &lt;&lt;  <span class="hljs-string">"binary predicate less than is v1b = ( "</span> ;
   <span class="hljs-keyword">for</span> ( Iter1b = v1b.begin( ) ; Iter1b != v1b.end( ) ; Iter1b++ )
      <span class="hljs-built_in">cout</span> &lt;&lt; *Iter1b &lt;&lt; <span class="hljs-string">" "</span>;
   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">")."</span> &lt;&lt; <span class="hljs-built_in">endl</span>;

   <span class="hljs-comment">// Constructing vectors v2a &amp; v2b with ranges sorted by greater</span>
   <span class="hljs-built_in">vector</span> &lt;<span class="hljs-keyword">int</span>&gt; v2a ( v1a ) , v2b ( v1b );
   <span class="hljs-built_in">vector</span> &lt;<span class="hljs-keyword">int</span>&gt;::iterator Iter2a,  Iter2b;
   sort ( v2a.begin( ), v2a.end( ), greater&lt;<span class="hljs-keyword">int</span>&gt;( ) );
   sort ( v2b.begin( ), v2b.end( ), greater&lt;<span class="hljs-keyword">int</span>&gt;( ) );
   v2a.pop_back( );

   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Original vector v2a with range sorted by the\n "</span>
        &lt;&lt;  <span class="hljs-string">"binary predicate greater is v2a = ( "</span> ;
   <span class="hljs-keyword">for</span> ( Iter2a = v2a.begin( ) ; Iter2a != v2a.end( ) ; Iter2a++ )
      <span class="hljs-built_in">cout</span> &lt;&lt; *Iter2a &lt;&lt; <span class="hljs-string">" "</span>;
   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">")."</span> &lt;&lt; <span class="hljs-built_in">endl</span>;

   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Original vector v2b with range sorted by the\n "</span>
        &lt;&lt;  <span class="hljs-string">"binary predicate greater is v2b = ( "</span> ;
   <span class="hljs-keyword">for</span> ( Iter2b = v2b.begin( ) ; Iter2b != v2b.end( ) ; Iter2b++ )
      <span class="hljs-built_in">cout</span> &lt;&lt; *Iter2b &lt;&lt; <span class="hljs-string">" "</span>;
   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">")."</span> &lt;&lt; <span class="hljs-built_in">endl</span>;

   <span class="hljs-comment">// Constructing vectors v3a &amp; v3b with ranges sorted by mod_lesser</span>
   <span class="hljs-built_in">vector</span> &lt;<span class="hljs-keyword">int</span>&gt; v3a ( v1a ), v3b ( v1b ) ;
   <span class="hljs-built_in">vector</span> &lt;<span class="hljs-keyword">int</span>&gt;::iterator Iter3a, Iter3b;
   reverse (v3a.begin( ), v3a.end( ) );
   v3a.pop_back( );
   v3a.pop_back( );
   sort ( v3a.begin( ), v3a.end( ), mod_lesser );
   sort ( v3b.begin( ), v3b.end( ), mod_lesser );

   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Original vector v3a with range sorted by the\n "</span>
        &lt;&lt;  <span class="hljs-string">"binary predicate mod_lesser is v3a = ( "</span> ;
   <span class="hljs-keyword">for</span> ( Iter3a = v3a.begin( ) ; Iter3a != v3a.end( ) ; Iter3a++ )
      <span class="hljs-built_in">cout</span> &lt;&lt; *Iter3a &lt;&lt; <span class="hljs-string">" "</span>;
   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">")."</span> &lt;&lt; <span class="hljs-built_in">endl</span>;

   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Original vector v3b with range sorted by the\n "</span>
        &lt;&lt;  <span class="hljs-string">"binary predicate mod_lesser is v3b = ( "</span> ;
   <span class="hljs-keyword">for</span> ( Iter3b = v3b.begin( ) ; Iter3b != v3b.end( ) ; Iter3b++ )
      <span class="hljs-built_in">cout</span> &lt;&lt; *Iter3b &lt;&lt; <span class="hljs-string">" "</span>;
   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">")."</span> &lt;&lt; <span class="hljs-built_in">endl</span>;

   <span class="hljs-comment">// To test for inclusion under an asscending order</span>
   <span class="hljs-comment">// with the default binary predicate less &lt;int&gt;( )</span>
   <span class="hljs-keyword">bool</span> Result1;
   Result1 = includes ( v1a.begin( ), v1a.end( ),
      v1b.begin( ), v1b.end( ) );
   <span class="hljs-keyword">if</span> ( Result1 )
      <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"All the elements in vector v1b are "</span>
           &lt;&lt; <span class="hljs-string">"contained in vector v1a."</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
   <span class="hljs-keyword">else</span>
      <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"At least one of the elements in vector v1b "</span>
           &lt;&lt; <span class="hljs-string">"is not contained in vector v1a."</span> &lt;&lt; <span class="hljs-built_in">endl</span>;

   <span class="hljs-comment">// To test for inclusion under descending</span>
   <span class="hljs-comment">// order specify binary predicate greater&lt;int&gt;( )</span>
   <span class="hljs-keyword">bool</span> Result2;
   Result2 = includes ( v2a.begin( ), v2a.end( ),
      v2b.begin( ), v2b.end( ), greater &lt;<span class="hljs-keyword">int</span>&gt;( ) );
   <span class="hljs-keyword">if</span> ( Result2 )
      <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"All the elements in vector v2b are "</span>
           &lt;&lt; <span class="hljs-string">"contained in vector v2a."</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
   <span class="hljs-keyword">else</span>
      <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"At least one of the elements in vector v2b "</span>
           &lt;&lt; <span class="hljs-string">"is not contained in vector v2a."</span> &lt;&lt; <span class="hljs-built_in">endl</span>;

   <span class="hljs-comment">// To test for inclusion under a user</span>
   <span class="hljs-comment">// defined binary predicate mod_lesser</span>
   <span class="hljs-keyword">bool</span> Result3;
   Result3 = includes ( v3a.begin( ), v3a.end( ),
      v3b.begin( ), v3b.end( ), mod_lesser );
   <span class="hljs-keyword">if</span> ( Result3 )
      <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"All the elements in vector v3b are "</span>
           &lt;&lt; <span class="hljs-string">"contained under mod_lesser in vector v3a."</span>
           &lt;&lt; <span class="hljs-built_in">endl</span>;
   <span class="hljs-keyword">else</span>
      <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"At least one of the elements in vector v3b is "</span>
           &lt;&lt; <span class="hljs-string">" not contained under mod_lesser in vector v3a."</span>
           &lt;&lt; <span class="hljs-built_in">endl</span>;
}
</code></pre>
<div class="codeHeader" id="code-try-49" data-bi-name="code-header"><span class="language">Output</span>
			<button class="action" data-bi-name="copy">
				<span class="docon docon-edit-copy" role="presentation"></span>
				<span>Copy</span>
			</button></div><pre><code class="lang-Output" data-author-content="Original vector v1a with range sorted by the
binary predicate less than is v1a = ( -2 -1 0 1 2 3 4 ).
Original vector v1b with range sorted by the
binary predicate less than is v1b = ( -2 -1 0 1 2 3 ).
Original vector v2a with range sorted by the
binary predicate greater is v2a = ( 4 3 2 1 0 -1 ).
Original vector v2b with range sorted by the
binary predicate greater is v2b = ( 3 2 1 0 -1 -2 ).
Original vector v3a with range sorted by the
binary predicate mod_lesser is v3a = ( 0 1 2 3 4 ).
Original vector v3b with range sorted by the
binary predicate mod_lesser is v3b = ( 0 -1 1 -2 2 3 ).
All the elements in vector v1b are contained in vector v1a.
At least one of the elements in vector v2b is not contained in vector v2a.
At least one of the elements in vector v3b is  not contained under mod_lesser in vector v3a.
">Original vector v1a with range sorted by the
binary predicate less than is v1a = ( -2 -1 0 1 2 3 4 ).
Original vector v1b with range sorted by the
binary predicate less than is v1b = ( -2 -1 0 1 2 3 ).
Original vector v2a with range sorted by the
binary predicate greater is v2a = ( 4 3 2 1 0 -1 ).
Original vector v2b with range sorted by the
binary predicate greater is v2b = ( 3 2 1 0 -1 -2 ).
Original vector v3a with range sorted by the
binary predicate mod_lesser is v3a = ( 0 1 2 3 4 ).
Original vector v3b with range sorted by the
binary predicate mod_lesser is v3b = ( 0 -1 1 -2 2 3 ).
All the elements in vector v1b are contained in vector v1a.
At least one of the elements in vector v2b is not contained in vector v2a.
At least one of the elements in vector v3b is  not contained under mod_lesser in vector v3a.
</code></pre>
<h2 id="inplace_merge" class="heading-with-anchor">  inplace_merge<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#inplace_merge"></a></h2>
<p>Combines the elements from two consecutive sorted ranges into a single sorted range, where the ordering criterion may be specified by a binary predicate.</p>
<div class="codeHeader" id="code-try-50" data-bi-name="code-header"><span class="language">C++</span>
			<button class="action" data-bi-name="copy">
				<span class="docon docon-edit-copy" role="presentation"></span>
				<span>Copy</span>
			</button></div><pre><code class="lang-cpp" data-author-content="template&lt;class BidirectionalIterator&gt;
void inplace_merge(
    BidirectionalIterator first,
    BidirectionalIterator middle,
    BidirectionalIterator last);

template&lt;class BidirectionalIterator, class Predicate&gt;
void inplace_merge(
    BidirectionalIterator first,
    BidirectionalIterator middle,
    BidirectionalIterator last,
    Predicate comp);
"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BidirectionalIterator</span>&gt;
<span class="hljs-title">void</span> <span class="hljs-title">inplace_merge</span>(
    <span class="hljs-title">BidirectionalIterator</span> <span class="hljs-title">first</span>,
    <span class="hljs-title">BidirectionalIterator</span> <span class="hljs-title">middle</span>,
    <span class="hljs-title">BidirectionalIterator</span> <span class="hljs-title">last</span>);</span>

<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BidirectionalIterator</span>, <span class="hljs-title">class</span> <span class="hljs-title">Predicate</span>&gt;
<span class="hljs-title">void</span> <span class="hljs-title">inplace_merge</span>(
    <span class="hljs-title">BidirectionalIterator</span> <span class="hljs-title">first</span>,
    <span class="hljs-title">BidirectionalIterator</span> <span class="hljs-title">middle</span>,
    <span class="hljs-title">BidirectionalIterator</span> <span class="hljs-title">last</span>,
    <span class="hljs-title">Predicate</span> <span class="hljs-title">comp</span>);</span>
</code></pre>
<h3 id="parameters-23" class="heading-with-anchor">Parameters<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#parameters-23"></a></h3>
<p><em>first</em><br>
A bidirectional iterator addressing the position of the first element in the first of two consecutive sorted ranges to be combined and sorted into a single range.</p>
<p><em>middle</em><br>
A bidirectional iterator addressing the position of the first element in the second of two consecutive sorted ranges to be combined and sorted into a single range.</p>
<p><em>last</em><br>
A bidirectional iterator addressing the position one past the last element in the second of two consecutive sorted ranges to be combined and sorted into a single range.</p>
<p><em>comp</em><br>
User-defined predicate function object that defines the sense in which one element is greater than another. The binary predicate takes two arguments and should return <strong>true</strong> when the first element is less than the second element and <strong>false</strong> otherwise.</p>
<h3 id="remarks-23" class="heading-with-anchor">Remarks<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#remarks-23"></a></h3>
<p>The sorted consecutive ranges referenced must be valid; all pointers must be dereferenceable and, within each sequence, the last position must be reachable from the first by incrementation.</p>
<p>The sorted consecutive ranges must each be arranged as a precondition to the application of the <code>inplace_merge</code> algorithm in accordance with the same ordering as is to be used by the algorithm to sort the combined ranges. The operation is stable as the relative order of elements within each range is preserved. When there are equivalent elements in both source ranges, the element is the first range precedes the element from the second in the combined range.</p>
<p>The complexity depends on the available memory as the algorithm allocates memory to a temporary buffer. If sufficient memory is available, the best case is linear with (<em>last</em> - <em>first</em>) - 1 comparisons; if no auxiliary memory is available, the worst case is  <em>N</em> log (<em>N</em>), where  <em>N</em> = (<em>last</em> - <em>first</em>).</p>
<h3 id="example-17" class="heading-with-anchor">Example<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#example-17"></a></h3>
<div class="codeHeader" id="code-try-51" data-bi-name="code-header"><span class="language">C++</span>
			<button class="action" data-bi-name="copy">
				<span class="docon docon-edit-copy" role="presentation"></span>
				<span>Copy</span>
			</button></div><pre><code class="lang-cpp" data-author-content="// alg_inplace_merge.cpp
// compile with: /EHsc
#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;functional&gt;      //For greater&lt;int&gt;( )
#include &lt;iostream&gt;

// Return whether modulus of elem1 is less than modulus of elem2
bool mod_lesser ( int elem1, int elem2 )
{
   if ( elem1 &lt; 0 )
      elem1 = - elem1;
   if ( elem2 &lt; 0 )
      elem2 = - elem2;
   return elem1 &lt; elem2;
}

int main()
{
   using namespace std;
   vector &lt;int&gt; v1;
   vector &lt;int&gt;::iterator Iter1, Iter2, Iter3;

   // Constructing vector v1 with default less-than ordering
   int i;
   for ( i = 0 ; i &lt;= 5 ; i++ )
   {
      v1.push_back( i );
   }

   int ii;
   for ( ii =-5 ; ii &lt;= 0 ; ii++ )
   {
      v1.push_back(  ii  );
   }

   cout &lt;&lt; &quot;Original vector v1 with subranges sorted by the\n &quot;
        &lt;&lt;  &quot;binary predicate less than is  v1 = ( &quot; ;
   for ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ; Iter1++ )
      cout &lt;&lt; *Iter1 &lt;&lt; &quot; &quot;;
   cout &lt;&lt; &quot;)&quot; &lt;&lt; endl;

   // Constructing vector v2 with ranges sorted by greater
   vector &lt;int&gt; v2 ( v1 );
   vector &lt;int&gt;::iterator break2;
   break2 = find ( v2.begin( ), v2.end( ), -5 );
   sort ( v2.begin( ), break2 , greater&lt;int&gt;( ) );
   sort ( break2 , v2.end( ), greater&lt;int&gt;( ) );
   cout &lt;&lt; &quot;Original vector v2 with subranges sorted by the\n &quot;
        &lt;&lt; &quot;binary predicate greater is v2 = ( &quot; ;
   for ( Iter2 = v2.begin( ) ; Iter2 != v2.end( ) ; Iter2++ )
      cout &lt;&lt; *Iter2 &lt;&lt; &quot; &quot;;
   cout &lt;&lt; &quot;)&quot; &lt;&lt; endl;

   // Constructing vector v3 with ranges sorted by mod_lesser
   vector &lt;int&gt; v3 ( v1 );
   vector &lt;int&gt;::iterator break3;
   break3 = find ( v3.begin( ), v3.end( ), -5 );
   sort ( v3.begin( ), break3 , mod_lesser );
   sort ( break3 , v3.end( ), mod_lesser );
   cout &lt;&lt; &quot;Original vector v3 with subranges sorted by the\n &quot;
        &lt;&lt; &quot;binary predicate mod_lesser is v3 = ( &quot; ;
   for ( Iter3 = v3.begin( ) ; Iter3 != v3.end( ) ; Iter3++ )
      cout &lt;&lt; *Iter3 &lt;&lt; &quot; &quot;;
   cout &lt;&lt; &quot;)&quot; &lt;&lt; endl;

   vector &lt;int&gt;::iterator break1;
   break1 = find (v1.begin( ), v1.end( ), -5 );
   inplace_merge ( v1.begin( ), break1, v1.end( ) );
   cout &lt;&lt; &quot;Merged inplace with default order,\n vector v1mod = ( &quot; ;
   for ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ; Iter1++ )
      cout &lt;&lt; *Iter1 &lt;&lt; &quot; &quot;;
   cout &lt;&lt; &quot;)&quot; &lt;&lt; endl;

   // To merge inplace in descending order, specify binary
   // predicate greater&lt;int&gt;( )
   inplace_merge ( v2.begin( ), break2 , v2.end( ) , greater&lt;int&gt;( ) );
   cout &lt;&lt; &quot;Merged inplace with binary predicate greater specified,\n &quot;
        &lt;&lt; &quot;vector v2mod = ( &quot; ;
   for ( Iter2 = v2.begin( ) ; Iter2 != v2.end( ) ; Iter2++ )
      cout &lt;&lt; *Iter2 &lt;&lt; &quot; &quot;;
   cout &lt;&lt; &quot;)&quot; &lt;&lt; endl;

   // Applying a user defined (UD) binary predicate mod_lesser
   inplace_merge ( v3.begin( ), break3, v3.end( ), mod_lesser );
   cout &lt;&lt; &quot;Merged inplace with binary predicate mod_lesser specified,\n &quot;
        &lt;&lt; &quot;vector v3mod = ( &quot; ; ;
   for ( Iter3 = v3.begin( ) ; Iter3 != v3.end( ) ; Iter3++ )
      cout &lt;&lt; *Iter3 &lt;&lt; &quot; &quot;;
   cout &lt;&lt; &quot;)&quot; &lt;&lt; endl;
}
"><span class="hljs-comment">// alg_inplace_merge.cpp</span>
<span class="hljs-comment">// compile with: /EHsc</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;functional&gt;      //For greater&lt;int&gt;( )</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span>

<span class="hljs-comment">// Return whether modulus of elem1 is less than modulus of elem2</span>
<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">mod_lesser</span> <span class="hljs-params">( <span class="hljs-keyword">int</span> elem1, <span class="hljs-keyword">int</span> elem2 )</span>
</span>{
   <span class="hljs-keyword">if</span> ( elem1 &lt; <span class="hljs-number">0</span> )
      elem1 = - elem1;
   <span class="hljs-keyword">if</span> ( elem2 &lt; <span class="hljs-number">0</span> )
      elem2 = - elem2;
   <span class="hljs-keyword">return</span> elem1 &lt; elem2;
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
   <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;
   <span class="hljs-built_in">vector</span> &lt;<span class="hljs-keyword">int</span>&gt; v1;
   <span class="hljs-built_in">vector</span> &lt;<span class="hljs-keyword">int</span>&gt;::iterator Iter1, Iter2, Iter3;

   <span class="hljs-comment">// Constructing vector v1 with default less-than ordering</span>
   <span class="hljs-keyword">int</span> i;
   <span class="hljs-keyword">for</span> ( i = <span class="hljs-number">0</span> ; i &lt;= <span class="hljs-number">5</span> ; i++ )
   {
      v1.push_back( i );
   }

   <span class="hljs-keyword">int</span> ii;
   <span class="hljs-keyword">for</span> ( ii =<span class="hljs-number">-5</span> ; ii &lt;= <span class="hljs-number">0</span> ; ii++ )
   {
      v1.push_back(  ii  );
   }

   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Original vector v1 with subranges sorted by the\n "</span>
        &lt;&lt;  <span class="hljs-string">"binary predicate less than is  v1 = ( "</span> ;
   <span class="hljs-keyword">for</span> ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ; Iter1++ )
      <span class="hljs-built_in">cout</span> &lt;&lt; *Iter1 &lt;&lt; <span class="hljs-string">" "</span>;
   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">")"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;

   <span class="hljs-comment">// Constructing vector v2 with ranges sorted by greater</span>
   <span class="hljs-built_in">vector</span> &lt;<span class="hljs-keyword">int</span>&gt; v2 ( v1 );
   <span class="hljs-built_in">vector</span> &lt;<span class="hljs-keyword">int</span>&gt;::iterator break2;
   break2 = find ( v2.begin( ), v2.end( ), <span class="hljs-number">-5</span> );
   sort ( v2.begin( ), break2 , greater&lt;<span class="hljs-keyword">int</span>&gt;( ) );
   sort ( break2 , v2.end( ), greater&lt;<span class="hljs-keyword">int</span>&gt;( ) );
   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Original vector v2 with subranges sorted by the\n "</span>
        &lt;&lt; <span class="hljs-string">"binary predicate greater is v2 = ( "</span> ;
   <span class="hljs-keyword">for</span> ( Iter2 = v2.begin( ) ; Iter2 != v2.end( ) ; Iter2++ )
      <span class="hljs-built_in">cout</span> &lt;&lt; *Iter2 &lt;&lt; <span class="hljs-string">" "</span>;
   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">")"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;

   <span class="hljs-comment">// Constructing vector v3 with ranges sorted by mod_lesser</span>
   <span class="hljs-built_in">vector</span> &lt;<span class="hljs-keyword">int</span>&gt; v3 ( v1 );
   <span class="hljs-built_in">vector</span> &lt;<span class="hljs-keyword">int</span>&gt;::iterator break3;
   break3 = find ( v3.begin( ), v3.end( ), <span class="hljs-number">-5</span> );
   sort ( v3.begin( ), break3 , mod_lesser );
   sort ( break3 , v3.end( ), mod_lesser );
   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Original vector v3 with subranges sorted by the\n "</span>
        &lt;&lt; <span class="hljs-string">"binary predicate mod_lesser is v3 = ( "</span> ;
   <span class="hljs-keyword">for</span> ( Iter3 = v3.begin( ) ; Iter3 != v3.end( ) ; Iter3++ )
      <span class="hljs-built_in">cout</span> &lt;&lt; *Iter3 &lt;&lt; <span class="hljs-string">" "</span>;
   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">")"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;

   <span class="hljs-built_in">vector</span> &lt;<span class="hljs-keyword">int</span>&gt;::iterator break1;
   break1 = find (v1.begin( ), v1.end( ), <span class="hljs-number">-5</span> );
   inplace_merge ( v1.begin( ), break1, v1.end( ) );
   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Merged inplace with default order,\n vector v1mod = ( "</span> ;
   <span class="hljs-keyword">for</span> ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ; Iter1++ )
      <span class="hljs-built_in">cout</span> &lt;&lt; *Iter1 &lt;&lt; <span class="hljs-string">" "</span>;
   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">")"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;

   <span class="hljs-comment">// To merge inplace in descending order, specify binary</span>
   <span class="hljs-comment">// predicate greater&lt;int&gt;( )</span>
   inplace_merge ( v2.begin( ), break2 , v2.end( ) , greater&lt;<span class="hljs-keyword">int</span>&gt;( ) );
   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Merged inplace with binary predicate greater specified,\n "</span>
        &lt;&lt; <span class="hljs-string">"vector v2mod = ( "</span> ;
   <span class="hljs-keyword">for</span> ( Iter2 = v2.begin( ) ; Iter2 != v2.end( ) ; Iter2++ )
      <span class="hljs-built_in">cout</span> &lt;&lt; *Iter2 &lt;&lt; <span class="hljs-string">" "</span>;
   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">")"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;

   <span class="hljs-comment">// Applying a user defined (UD) binary predicate mod_lesser</span>
   inplace_merge ( v3.begin( ), break3, v3.end( ), mod_lesser );
   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Merged inplace with binary predicate mod_lesser specified,\n "</span>
        &lt;&lt; <span class="hljs-string">"vector v3mod = ( "</span> ; ;
   <span class="hljs-keyword">for</span> ( Iter3 = v3.begin( ) ; Iter3 != v3.end( ) ; Iter3++ )
      <span class="hljs-built_in">cout</span> &lt;&lt; *Iter3 &lt;&lt; <span class="hljs-string">" "</span>;
   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">")"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
}
</code></pre>
<div class="codeHeader" id="code-try-52" data-bi-name="code-header"><span class="language">Output</span>
			<button class="action" data-bi-name="copy">
				<span class="docon docon-edit-copy" role="presentation"></span>
				<span>Copy</span>
			</button></div><pre><code class="lang-Output" data-author-content="Original vector v1 with subranges sorted by the
binary predicate less than is  v1 = ( 0 1 2 3 4 5 -5 -4 -3 -2 -1 0 )
Original vector v2 with subranges sorted by the
binary predicate greater is v2 = ( 5 4 3 2 1 0 0 -1 -2 -3 -4 -5 )
Original vector v3 with subranges sorted by the
binary predicate mod_lesser is v3 = ( 0 1 2 3 4 5 0 -1 -2 -3 -4 -5 )
Merged inplace with default order,
vector v1mod = ( -5 -4 -3 -2 -1 0 0 1 2 3 4 5 )
Merged inplace with binary predicate greater specified,
vector v2mod = ( 5 4 3 2 1 0 0 -1 -2 -3 -4 -5 )
Merged inplace with binary predicate mod_lesser specified,
vector v3mod = ( 0 0 1 -1 2 -2 3 -3 4 -4 5 -5 )
">Original vector v1 with subranges sorted by the
binary predicate less than is  v1 = ( 0 1 2 3 4 5 -5 -4 -3 -2 -1 0 )
Original vector v2 with subranges sorted by the
binary predicate greater is v2 = ( 5 4 3 2 1 0 0 -1 -2 -3 -4 -5 )
Original vector v3 with subranges sorted by the
binary predicate mod_lesser is v3 = ( 0 1 2 3 4 5 0 -1 -2 -3 -4 -5 )
Merged inplace with default order,
vector v1mod = ( -5 -4 -3 -2 -1 0 0 1 2 3 4 5 )
Merged inplace with binary predicate greater specified,
vector v2mod = ( 5 4 3 2 1 0 0 -1 -2 -3 -4 -5 )
Merged inplace with binary predicate mod_lesser specified,
vector v3mod = ( 0 0 1 -1 2 -2 3 -3 4 -4 5 -5 )
</code></pre>
<h2 id="is_heap" class="heading-with-anchor">  is_heap<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#is_heap"></a></h2>
<p>Returns <strong>true</strong> if the elements in the specified range form a heap.</p>
<div class="codeHeader" id="code-try-53" data-bi-name="code-header"><span class="language">C++</span>
			<button class="action" data-bi-name="copy">
				<span class="docon docon-edit-copy" role="presentation"></span>
				<span>Copy</span>
			</button></div><pre><code class="lang-cpp" data-author-content="template&lt;class RandomAccessIterator&gt;
bool is_heap(
    RandomAccessIterator first,
    RandomAccessIterator last);

template&lt;class RandomAccessIterator, class BinaryPredicate&gt;
bool is_heap(
    RandomAccessIterator first,
    RandomAccessIterator last,
    BinaryPredicate comp);
"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RandomAccessIterator</span>&gt;
<span class="hljs-title">bool</span> <span class="hljs-title">is_heap</span>(
    <span class="hljs-title">RandomAccessIterator</span> <span class="hljs-title">first</span>,
    <span class="hljs-title">RandomAccessIterator</span> <span class="hljs-title">last</span>);</span>

<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RandomAccessIterator</span>, <span class="hljs-title">class</span> <span class="hljs-title">BinaryPredicate</span>&gt;
<span class="hljs-title">bool</span> <span class="hljs-title">is_heap</span>(
    <span class="hljs-title">RandomAccessIterator</span> <span class="hljs-title">first</span>,
    <span class="hljs-title">RandomAccessIterator</span> <span class="hljs-title">last</span>,
    <span class="hljs-title">BinaryPredicate</span> <span class="hljs-title">comp</span>);</span>
</code></pre>
<h3 id="parameters-24" class="heading-with-anchor">Parameters<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#parameters-24"></a></h3>
<p><em>first</em><br>
A random access iterator that indicates the start of a range to check for a heap.</p>
<p><em>last</em><br>
A random access iterator that indicates the end of a range.</p>
<p><em>comp</em><br>
A condition to test to order elements. A binary predicate takes a single argument and returns <strong>true</strong> or <strong>false</strong>.</p>
<h3 id="return-value-20" class="heading-with-anchor">Return Value<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#return-value-20"></a></h3>
<p>Returns <strong>true</strong> if the elements in the specified range form a heap, <strong>false</strong> if they do not.</p>
<h3 id="remarks-24" class="heading-with-anchor">Remarks<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#remarks-24"></a></h3>
<p>The first template function returns <a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#is_heap_until" data-linktype="relative-path">is_heap_until</a><code>(first , last) == last</code>.</p>
<p>The second template function returns</p>
<p><code>is_heap_until(first, last, comp) == last</code>.</p>
<h2 id="is_heap_until" class="heading-with-anchor">  is_heap_until<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#is_heap_until"></a></h2>
<p>Returns an iterator positioned at the first element in the range [ <code>begin</code>, <code>end</code>) that does not satisfy the heap ordering condition, or <em>end</em> if the range forms a heap.</p>
<div class="codeHeader" id="code-try-54" data-bi-name="code-header"><span class="language">C++</span>
			<button class="action" data-bi-name="copy">
				<span class="docon docon-edit-copy" role="presentation"></span>
				<span>Copy</span>
			</button></div><pre><code class="lang-cpp" data-author-content="template&lt;class RandomAccessIterator&gt;
RandomAccessIterator is_heap_until(
    RandomAccessIterator begin,
    RandomAccessIterator end);

template&lt;class RandomAccessIterator, class BinaryPredicate&gt;
RandomAccessIterator is_heap_until(
    RandomAccessIterator begin,
    RandomAccessIterator end,
    BinaryPredicate compare);
"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RandomAccessIterator</span>&gt;
<span class="hljs-title">RandomAccessIterator</span> <span class="hljs-title">is_heap_until</span>(
    <span class="hljs-title">RandomAccessIterator</span> <span class="hljs-title">begin</span>,
    <span class="hljs-title">RandomAccessIterator</span> <span class="hljs-title">end</span>);</span>

<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RandomAccessIterator</span>, <span class="hljs-title">class</span> <span class="hljs-title">BinaryPredicate</span>&gt;
<span class="hljs-title">RandomAccessIterator</span> <span class="hljs-title">is_heap_until</span>(
    <span class="hljs-title">RandomAccessIterator</span> <span class="hljs-title">begin</span>,
    <span class="hljs-title">RandomAccessIterator</span> <span class="hljs-title">end</span>,
    <span class="hljs-title">BinaryPredicate</span> <span class="hljs-title">compare</span>);</span>
</code></pre>
<h3 id="parameters-25" class="heading-with-anchor">Parameters<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#parameters-25"></a></h3>
<p><em>begin</em><br>
A random access iterator that specifies the first element of a range to check for a heap.</p>
<p><em>end</em><br>
A random access iterator that specifies the end of the range to check for a heap.</p>
<p><em>compare</em><br>
A binary predicate that specifies the strict weak ordering condition that defines a heap. The default predicate when <em>compare</em> is not specified is <code>std::less&lt;&gt;</code>.</p>
<h3 id="return-value-21" class="heading-with-anchor">Return Value<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#return-value-21"></a></h3>
<p>Returns <em>end</em> if the specified range forms a heap or contains one or fewer elements. Otherwise, returns an iterator for the first element found that does not satisfy the heap condition.</p>
<h3 id="remarks-25" class="heading-with-anchor">Remarks<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#remarks-25"></a></h3>
<p>The first template function returns the last iterator <code>next</code> in <code>[ begin , end ]</code> where <code>[ begin , next)</code> is a heap ordered by the function object <code>std::less&lt;&gt;</code>. If the distance <code>end - begin &lt; 2</code>, the function returns <em>end</em>.</p>
<p>The second template function behaves the same as the first, except that it uses the predicate <code>compare</code> instead of <code>std::less&lt;&gt;</code> as the heap ordering condition.</p>
<h2 id="is_partitioned" class="heading-with-anchor">  is_partitioned<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#is_partitioned"></a></h2>
<p>Returns <strong>true</strong> if all the elements in the given range that test <strong>true</strong> for a condition come before any elements that test <strong>false</strong>.</p>
<div class="codeHeader" id="code-try-55" data-bi-name="code-header"><span class="language">C++</span>
			<button class="action" data-bi-name="copy">
				<span class="docon docon-edit-copy" role="presentation"></span>
				<span>Copy</span>
			</button></div><pre><code class="lang-cpp" data-author-content="template&lt;class InputIterator, class BinaryPredicate&gt;
bool is_partitioned(
    InputIterator first,
    InputIterator last,
    BinaryPredicate comp);
"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InputIterator</span>, <span class="hljs-title">class</span> <span class="hljs-title">BinaryPredicate</span>&gt;
<span class="hljs-title">bool</span> <span class="hljs-title">is_partitioned</span>(
    <span class="hljs-title">InputIterator</span> <span class="hljs-title">first</span>,
    <span class="hljs-title">InputIterator</span> <span class="hljs-title">last</span>,
    <span class="hljs-title">BinaryPredicate</span> <span class="hljs-title">comp</span>);</span>
</code></pre>
<h3 id="parameters-26" class="heading-with-anchor">Parameters<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#parameters-26"></a></h3>
<p><em>first</em><br>
An input iterator that indicates where a range starts to check for a condition.</p>
<p><em>last</em><br>
An input iterator that indicates the end of a range.</p>
<p><em>comp</em><br>
The condition to test for. This is provided by a user-defined predicate function object that defines the condition to be satisfied by the element being searched for. A predicate takes a single argument and returns <strong>true</strong> or <strong>false</strong>.</p>
<h3 id="return-value-22" class="heading-with-anchor">Return Value<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#return-value-22"></a></h3>
<p>Returns true when all of the elements in the given range that test <strong>true</strong> for a condition come before any elements that test <strong>false</strong>, and otherwise returns <strong>false</strong>.</p>
<h3 id="remarks-26" class="heading-with-anchor">Remarks<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#remarks-26"></a></h3>
<p>The template function returns <strong>true</strong> only if all elements in <code>[</code> <code>first ,</code> <code>last )</code> are partitioned by <em>comp</em>; that is, all elements <code>X</code> in <code>[</code> <code>first ,</code> <code>last )</code> for which <code>comp (X)</code> is true occur before all elements <code>Y</code> for which <code>comp (Y)</code> is <strong>false</strong>.</p>
<h2 id="is_permutation" class="heading-with-anchor">  is_permutation<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#is_permutation"></a></h2>
<p>Returns true if both ranges contain the same elements, whether or not the elements are in the same order. Use the dual-range overloads in C++14 code because the overloads that only take a single iterator for the second range will not detect differences if the second range is longer than the first range, and will result in undefined behavior if the second range is shorter than the first range.</p>
<div class="codeHeader" id="code-try-56" data-bi-name="code-header"><span class="language">C++</span>
			<button class="action" data-bi-name="copy">
				<span class="docon docon-edit-copy" role="presentation"></span>
				<span>Copy</span>
			</button></div><pre><code class="lang-cpp" data-author-content="template&lt;class ForwardIterator1, class ForwardIterator2&gt;
bool is_permutation(
    ForwardIterator1 First1,
    ForwardIterator1 Last1,
    ForwardIterator2 First2);

template&lt;class ForwardIterator1, class ForwardIterator2, class Predicate&gt;
bool is_permutation(
    ForwardIterator1 First1,
    ForwardIterator1 Last1,
    ForwardIterator2 First2,
    Predicate Pred);

// C++14
template&lt;class ForwardIterator1, class ForwardIterator2&gt;
bool is_permutation(
    ForwardIterator1 First1,
    ForwardIterator1 Last1,
    ForwardIterator2 First2,
    ForwardIterator2 Last2);

template&lt;class ForwardIterator1, class ForwardIterator2, class Predicate&gt;
bool is_permutation(
    ForwardIterator1 First1,
    ForwardIterator1 Last1,
    ForwardIterator2 First2,
    ForwardIterator2 Last2,
    Predicate Pred);
"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ForwardIterator1</span>, <span class="hljs-title">class</span> <span class="hljs-title">ForwardIterator2</span>&gt;
<span class="hljs-title">bool</span> <span class="hljs-title">is_permutation</span>(
    <span class="hljs-title">ForwardIterator1</span> <span class="hljs-title">First1</span>,
    <span class="hljs-title">ForwardIterator1</span> <span class="hljs-title">Last1</span>,
    <span class="hljs-title">ForwardIterator2</span> <span class="hljs-title">First2</span>);</span>

<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ForwardIterator1</span>, <span class="hljs-title">class</span> <span class="hljs-title">ForwardIterator2</span>, <span class="hljs-title">class</span> <span class="hljs-title">Predicate</span>&gt;
<span class="hljs-title">bool</span> <span class="hljs-title">is_permutation</span>(
    <span class="hljs-title">ForwardIterator1</span> <span class="hljs-title">First1</span>,
    <span class="hljs-title">ForwardIterator1</span> <span class="hljs-title">Last1</span>,
    <span class="hljs-title">ForwardIterator2</span> <span class="hljs-title">First2</span>,
    <span class="hljs-title">Predicate</span> <span class="hljs-title">Pred</span>);</span>

<span class="hljs-comment">// C++14</span>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ForwardIterator1</span>, <span class="hljs-title">class</span> <span class="hljs-title">ForwardIterator2</span>&gt;
<span class="hljs-title">bool</span> <span class="hljs-title">is_permutation</span>(
    <span class="hljs-title">ForwardIterator1</span> <span class="hljs-title">First1</span>,
    <span class="hljs-title">ForwardIterator1</span> <span class="hljs-title">Last1</span>,
    <span class="hljs-title">ForwardIterator2</span> <span class="hljs-title">First2</span>,
    <span class="hljs-title">ForwardIterator2</span> <span class="hljs-title">Last2</span>);</span>

<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ForwardIterator1</span>, <span class="hljs-title">class</span> <span class="hljs-title">ForwardIterator2</span>, <span class="hljs-title">class</span> <span class="hljs-title">Predicate</span>&gt;
<span class="hljs-title">bool</span> <span class="hljs-title">is_permutation</span>(
    <span class="hljs-title">ForwardIterator1</span> <span class="hljs-title">First1</span>,
    <span class="hljs-title">ForwardIterator1</span> <span class="hljs-title">Last1</span>,
    <span class="hljs-title">ForwardIterator2</span> <span class="hljs-title">First2</span>,
    <span class="hljs-title">ForwardIterator2</span> <span class="hljs-title">Last2</span>,
    <span class="hljs-title">Predicate</span> <span class="hljs-title">Pred</span>);</span>
</code></pre>
<h3 id="parameters-27" class="heading-with-anchor">Parameters<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#parameters-27"></a></h3>
<p><em>First1</em><br>
A forward iterator that refers to the first element of the range.</p>
<p><em>Last1</em><br>
A forward iterator that refers one past the last element of the range.</p>
<p><em>First2</em><br>
A forward iterator that refers to the first element of a second range, used for comparison.</p>
<p><em>Last2</em><br>
A forward iterator that refers to one past the last element of a second range, used for comparison.</p>
<p><em>Pred</em><br>
A predicate that tests for equivalence and returns a <strong>bool</strong>.</p>
<h3 id="return-value-23" class="heading-with-anchor">Return Value<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#return-value-23"></a></h3>
<p><strong>true</strong> when the ranges can be rearranged so as to be identical according to the comparator predicate; otherwise, <strong>false</strong>.</p>
<h3 id="remarks-27" class="heading-with-anchor">Remarks<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#remarks-27"></a></h3>
<p><code>is_permutation</code> has quadratic complexity in the worst case.</p>
<p>The first template function assumes that there are as many elements in the range beginning at <em>First2</em> as there are in the range designated by [ <code>First1</code>, <code>Last1</code>). If there are more elements in the second range, they are ignored; if there are less, undefined behavior will occur. The third template function (C++14 and later) does not make this assumption.  Both return <strong>true</strong> only if, for each element X in the range designated by [ <code>First1</code>, <code>Last1</code>) there are as many elements Y in the same range for which X == Y as there are in the range beginning at <em>First2</em> or [ <code>First2, Last2).</code> Here, <code>operator==</code> must perform a pairwise comparison between its operands.</p>
<p>The second and fourth template functions behave the same, except that they replace <code>operator==(X, Y)</code> with <code>Pred(X, Y)</code>. To behave correctly, the predicate must be symmetric, reflexive and transitive.</p>
<h3 id="example-18" class="heading-with-anchor">Example<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#example-18"></a></h3>
<p>The following example shows how to use <code>is_permutation</code>:</p>
<div class="codeHeader" id="code-try-57" data-bi-name="code-header"><span class="language">C++</span>
			<button class="action" data-bi-name="copy">
				<span class="docon docon-edit-copy" role="presentation"></span>
				<span>Copy</span>
			</button></div><pre><code class="lang-cpp" data-author-content="#include &lt;vector&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;string&gt;

using namespace std;

int main()
{
    vector&lt;int&gt; vec_1{ 2, 3, 0, 1, 4, 5 };
    vector&lt;int&gt; vec_2{ 5, 4, 0, 3, 1, 2 };

    vector&lt;int&gt; vec_3{ 4, 9, 13, 3, 6, 5 };
    vector&lt;int&gt; vec_4{ 7, 4, 11, 9, 2, 1 };

    cout &lt;&lt; &quot;(1) Compare using built-in == operator: &quot;;
    cout &lt;&lt; boolalpha &lt;&lt; is_permutation(vec_1.begin(), vec_1.end(),
        vec_2.begin(), vec_2.end()) &lt;&lt; endl; // true

    cout &lt;&lt; &quot;(2) Compare after modifying vec_2: &quot;;
    vec_2[0] = 6;
    cout &lt;&lt; is_permutation(vec_1.begin(), vec_1.end(),
        vec_2.begin(), vec_2.end()) &lt;&lt; endl; // false

    // Define equivalence as &quot;both are odd or both are even&quot;
    cout &lt;&lt; &quot;(3) vec_3 is a permutation of vec_4: &quot;;
    cout &lt;&lt; is_permutation(vec_3.begin(), vec_3.end(),
        vec_4.begin(), vec_4.end(),
        [](int lhs, int rhs) { return lhs % 2 == rhs % 2; }) &lt;&lt; endl; // true

    // Initialize a vector using the &#39;s&#39; string literal to specify a std::string
    vector&lt;string&gt; animals_1{ &quot;dog&quot;s, &quot;cat&quot;s, &quot;bird&quot;s, &quot;monkey&quot;s };
    vector&lt;string&gt; animals_2{ &quot;donkey&quot;s, &quot;bird&quot;s, &quot;meerkat&quot;s, &quot;cat&quot;s };

    // Define equivalence as &quot;first letters are equal&quot;:
    bool is_perm = is_permutation(animals_1.begin(), animals_1.end(), animals_2.begin(), animals_2.end(),
        [](const string&amp; lhs, const string&amp; rhs)
    {
        return lhs[0] == rhs[0]; //std::string guaranteed to have at least a null terminator
    });

    cout &lt;&lt; &quot;animals_2 is a permutation of animals_1: &quot; &lt;&lt; is_perm &lt;&lt; endl; // true

    cout &lt;&lt; &quot;Press a letter&quot; &lt;&lt; endl;
    char c;
    cin &gt;&gt; c;

    return 0;
}
"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span>

<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; vec_1{ <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span> };
    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; vec_2{ <span class="hljs-number">5</span>, <span class="hljs-number">4</span>, <span class="hljs-number">0</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span> };

    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; vec_3{ <span class="hljs-number">4</span>, <span class="hljs-number">9</span>, <span class="hljs-number">13</span>, <span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">5</span> };
    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; vec_4{ <span class="hljs-number">7</span>, <span class="hljs-number">4</span>, <span class="hljs-number">11</span>, <span class="hljs-number">9</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span> };

    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"(1) Compare using built-in == operator: "</span>;
    <span class="hljs-built_in">cout</span> &lt;&lt; boolalpha &lt;&lt; is_permutation(vec_1.begin(), vec_1.end(),
        vec_2.begin(), vec_2.end()) &lt;&lt; <span class="hljs-built_in">endl</span>; <span class="hljs-comment">// true</span>

    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"(2) Compare after modifying vec_2: "</span>;
    vec_2[<span class="hljs-number">0</span>] = <span class="hljs-number">6</span>;
    <span class="hljs-built_in">cout</span> &lt;&lt; is_permutation(vec_1.begin(), vec_1.end(),
        vec_2.begin(), vec_2.end()) &lt;&lt; <span class="hljs-built_in">endl</span>; <span class="hljs-comment">// false</span>

    <span class="hljs-comment">// Define equivalence as "both are odd or both are even"</span>
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"(3) vec_3 is a permutation of vec_4: "</span>;
    <span class="hljs-built_in">cout</span> &lt;&lt; is_permutation(vec_3.begin(), vec_3.end(),
        vec_4.begin(), vec_4.end(),
        [](<span class="hljs-keyword">int</span> lhs, <span class="hljs-keyword">int</span> rhs) { <span class="hljs-keyword">return</span> lhs % <span class="hljs-number">2</span> == rhs % <span class="hljs-number">2</span>; }) &lt;&lt; <span class="hljs-built_in">endl</span>; <span class="hljs-comment">// true</span>

    <span class="hljs-comment">// Initialize a vector using the 's' string literal to specify a std::string</span>
    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt; animals_1{ <span class="hljs-string">"dog"</span>s, <span class="hljs-string">"cat"</span>s, <span class="hljs-string">"bird"</span>s, <span class="hljs-string">"monkey"</span>s };
    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt; animals_2{ <span class="hljs-string">"donkey"</span>s, <span class="hljs-string">"bird"</span>s, <span class="hljs-string">"meerkat"</span>s, <span class="hljs-string">"cat"</span>s };

    <span class="hljs-comment">// Define equivalence as "first letters are equal":</span>
    <span class="hljs-keyword">bool</span> is_perm = is_permutation(animals_1.begin(), animals_1.end(), animals_2.begin(), animals_2.end(),
        [](<span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span>&amp; lhs, <span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span>&amp; rhs)
    {
        <span class="hljs-keyword">return</span> lhs[<span class="hljs-number">0</span>] == rhs[<span class="hljs-number">0</span>]; <span class="hljs-comment">//std::string guaranteed to have at least a null terminator</span>
    });

    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"animals_2 is a permutation of animals_1: "</span> &lt;&lt; is_perm &lt;&lt; <span class="hljs-built_in">endl</span>; <span class="hljs-comment">// true</span>

    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Press a letter"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
    <span class="hljs-keyword">char</span> c;
    <span class="hljs-built_in">cin</span> &gt;&gt; c;

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<h2 id="is_sorted" class="heading-with-anchor">  is_sorted<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#is_sorted"></a></h2>
<p>Returns <strong>true</strong> if the elements in the specified range are in sorted order.</p>
<div class="codeHeader" id="code-try-58" data-bi-name="code-header"><span class="language">C++</span>
			<button class="action" data-bi-name="copy">
				<span class="docon docon-edit-copy" role="presentation"></span>
				<span>Copy</span>
			</button></div><pre><code class="lang-cpp" data-author-content="template&lt;class ForwardIterator&gt;
bool is_sorted(
    ForwardIterator first,
    ForwardIterator last);

template&lt;class ForwardIterator, class BinaryPredicate&gt;
bool is_sorted(
    ForwardIterator first,
    ForwardIterator last,
    BinaryPredicate comp);
"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ForwardIterator</span>&gt;
<span class="hljs-title">bool</span> <span class="hljs-title">is_sorted</span>(
    <span class="hljs-title">ForwardIterator</span> <span class="hljs-title">first</span>,
    <span class="hljs-title">ForwardIterator</span> <span class="hljs-title">last</span>);</span>

<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ForwardIterator</span>, <span class="hljs-title">class</span> <span class="hljs-title">BinaryPredicate</span>&gt;
<span class="hljs-title">bool</span> <span class="hljs-title">is_sorted</span>(
    <span class="hljs-title">ForwardIterator</span> <span class="hljs-title">first</span>,
    <span class="hljs-title">ForwardIterator</span> <span class="hljs-title">last</span>,
    <span class="hljs-title">BinaryPredicate</span> <span class="hljs-title">comp</span>);</span>
</code></pre>
<h3 id="parameters-28" class="heading-with-anchor">Parameters<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#parameters-28"></a></h3>
<p><em>first</em><br>
A forward iterator that indicates where the range to check begins.</p>
<p><em>last</em><br>
A forward iterator that indicates the end of a range.</p>
<p><em>comp</em><br>
The condition to test to determine an order between two elements. A predicate takes a single argument and returns <strong>true</strong> or <strong>false</strong>. This performs the same task as <code>operator&lt;</code>.</p>
<h3 id="remarks-28" class="heading-with-anchor">Remarks<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#remarks-28"></a></h3>
<p>The first template function returns <a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#is_sorted_until" data-linktype="self-bookmark">is_sorted_until</a><code>( first, last ) == last</code>. The <code>operator&lt;</code> function performs the order comparison.</p>
<p>The second template function returns <code>is_sorted_until( first, last , comp ) == last</code>. The <em>comp</em> predicate function performs the order comparison.</p>
<h2 id="is_sorted_until" class="heading-with-anchor">  is_sorted_until<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#is_sorted_until"></a></h2>
<p>Returns a <code>ForwardIterator</code> that is set to the last element that is in sorted order from a specified range.</p>
<p>The second version lets you provide a <code>BinaryPredicate</code> function that returns <strong>true</strong> when two given elements are in sorted order, and <strong>false</strong> otherwise.</p>
<div class="codeHeader" id="code-try-59" data-bi-name="code-header"><span class="language">C++</span>
			<button class="action" data-bi-name="copy">
				<span class="docon docon-edit-copy" role="presentation"></span>
				<span>Copy</span>
			</button></div><pre><code class="lang-cpp" data-author-content="template&lt;class ForwardIterator&gt;
ForwardIterator is_sorted_until(
    ForwardIterator first,
    ForwardIterator last);
template&lt;class ForwardIterator, class BinaryPredicate&gt;
ForwardIterator is_sorted_until(
    ForwardIterator first,
    ForwardIterator last,
    BinaryPredicate comp);
"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ForwardIterator</span>&gt;
<span class="hljs-title">ForwardIterator</span> <span class="hljs-title">is_sorted_until</span>(
    <span class="hljs-title">ForwardIterator</span> <span class="hljs-title">first</span>,
    <span class="hljs-title">ForwardIterator</span> <span class="hljs-title">last</span>);</span>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ForwardIterator</span>, <span class="hljs-title">class</span> <span class="hljs-title">BinaryPredicate</span>&gt;
<span class="hljs-title">ForwardIterator</span> <span class="hljs-title">is_sorted_until</span>(
    <span class="hljs-title">ForwardIterator</span> <span class="hljs-title">first</span>,
    <span class="hljs-title">ForwardIterator</span> <span class="hljs-title">last</span>,
    <span class="hljs-title">BinaryPredicate</span> <span class="hljs-title">comp</span>);</span>
</code></pre>
<h3 id="parameters-29" class="heading-with-anchor">Parameters<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#parameters-29"></a></h3>
<p><em>first</em><br>
A forward iterator that indicates where the range to check starts.</p>
<p><em>last</em><br>
A forward iterator that indicates the end of a range.</p>
<p><em>comp</em><br>
The condition to test to determine an order between two elements. A predicate takes a single argument and returns <strong>true</strong> or <strong>false</strong>.</p>
<h3 id="return-value-24" class="heading-with-anchor">Return Value<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#return-value-24"></a></h3>
<p>Returns a <code>ForwardIterator</code> set to the last element in sorted order. The sorted sequence starts from  <em>first</em>.</p>
<h3 id="remarks-29" class="heading-with-anchor">Remarks<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#remarks-29"></a></h3>
<p>The first template function returns the last iterator <code>next</code> in <code>[</code> <code>first ,</code> <code>last ]</code> so that <code>[</code> <code>first , next)</code> is a sorted sequence ordered by <code>operator&lt;</code>. If <code>distance()</code> <code>&lt; 2</code> the function returns <em>last</em>.</p>
<p>The second template function behaves the same, except that it replaces <code>operator&lt;(X, Y)</code> with <code>comp (X, Y)</code>.</p>
<h2 id="iter_swap" class="heading-with-anchor">  iter_swap<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#iter_swap"></a></h2>
<p>Exchanges two values referred to by a pair of specified iterators.</p>
<div class="codeHeader" id="code-try-60" data-bi-name="code-header"><span class="language">C++</span>
			<button class="action" data-bi-name="copy">
				<span class="docon docon-edit-copy" role="presentation"></span>
				<span>Copy</span>
			</button></div><pre><code class="lang-cpp" data-author-content="template&lt;class ForwardIterator1, class ForwardIterator2&gt;
void iter_swap( ForwardIterator1 left, ForwardIterator2 right );
"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ForwardIterator1</span>, <span class="hljs-title">class</span> <span class="hljs-title">ForwardIterator2</span>&gt;
<span class="hljs-title">void</span> <span class="hljs-title">iter_swap</span>( <span class="hljs-title">ForwardIterator1</span> <span class="hljs-title">left</span>, <span class="hljs-title">ForwardIterator2</span> <span class="hljs-title">right</span> );</span>
</code></pre>
<h3 id="parameters-30" class="heading-with-anchor">Parameters<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#parameters-30"></a></h3>
<p><em>left</em><br>
One of the forward iterators whose value is to be exchanged.</p>
<p><em>right</em><br>
The second of the forward iterators whose value is to be exchanged.</p>
<h3 id="remarks-30" class="heading-with-anchor">Remarks<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#remarks-30"></a></h3>
<p><code>swap</code> should be used in preference to i <strong>ter_swap</strong>, which was included in the C++ Standard for backward compatibility. If <code>Fit1</code> and <code>Fit2</code> are forward iterators, then <code>iter_swap</code> ( <code>Fit1</code>, <code>Fit2</code> ), is equivalent to <code>swap</code> ( * <code>Fit1</code>, * <code>Fit2</code> ).</p>
<p>The value types of the input forward iterators must have the same value.</p>
<h3 id="example-19" class="heading-with-anchor">Example<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#example-19"></a></h3>
<div class="codeHeader" id="code-try-61" data-bi-name="code-header"><span class="language">C++</span>
			<button class="action" data-bi-name="copy">
				<span class="docon docon-edit-copy" role="presentation"></span>
				<span>Copy</span>
			</button></div><pre><code class="lang-cpp" data-author-content="// alg_iter_swap.cpp
// compile with: /EHsc
#include &lt;vector&gt;
#include &lt;deque&gt;
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;ostream&gt;

using namespace std;
class CInt;
ostream&amp; operator&lt;&lt;( ostream&amp; osIn, const CInt&amp; rhs );

class CInt
{
public:
   CInt( int n = 0 ) : m_nVal( n ){}
   CInt( const CInt&amp; rhs ) : m_nVal( rhs.m_nVal ){}
   CInt&amp;   operator=( const CInt&amp; rhs ) { m_nVal =
   rhs.m_nVal; return *this; }
   bool operator&lt;( const CInt&amp; rhs ) const
      { return ( m_nVal &lt; rhs.m_nVal );}
   friend ostream&amp; operator&lt;&lt;( ostream&amp; osIn, const CInt&amp; rhs );

private:
   int m_nVal;
};

inline ostream&amp; operator&lt;&lt;( ostream&amp; osIn, const CInt&amp; rhs )
{
   osIn &lt;&lt; &quot;CInt(&quot; &lt;&lt; rhs.m_nVal &lt;&lt; &quot;)&quot;;
   return osIn;
}

// Return whether modulus of elem1 is less than modulus of elem2
bool mod_lesser ( int elem1, int elem2 )
{
   if ( elem1 &lt; 0 )
      elem1 = - elem1;
   if ( elem2 &lt; 0 )
      elem2 = - elem2;
   return elem1 &lt; elem2;
};

int main()
{
   CInt c1 = 5, c2 = 1, c3 = 10;
   deque&lt;CInt&gt; deq1;
   deque&lt;CInt&gt;::iterator d1_Iter;

   deq1.push_back ( c1 );
   deq1.push_back ( c2 );
   deq1.push_back ( c3 );

   cout &lt;&lt; &quot;The original deque of CInts is deq1 = (&quot;;
   for ( d1_Iter = deq1.begin( ); d1_Iter != --deq1.end( ); d1_Iter++ )
      cout &lt;&lt; &quot; &quot; &lt;&lt; *d1_Iter &lt;&lt; &quot;,&quot;;
   d1_Iter = --deq1.end( );
   cout &lt;&lt; &quot; &quot; &lt;&lt; *d1_Iter &lt;&lt; &quot; ).&quot; &lt;&lt; endl;

   // Exchanging first and last elements with iter_swap
   iter_swap ( deq1.begin( ), --deq1.end( ) );

   cout &lt;&lt; &quot;The deque of CInts with first &amp; last elements swapped is:\n deq1 = (&quot;;
   for ( d1_Iter = deq1.begin( ); d1_Iter != --deq1.end( ); d1_Iter++ )
      cout &lt;&lt; &quot; &quot; &lt;&lt; *d1_Iter &lt;&lt; &quot;,&quot;;
   d1_Iter = --deq1.end( );
   cout &lt;&lt; &quot; &quot; &lt;&lt; *d1_Iter &lt;&lt; &quot; ).&quot; &lt;&lt; endl;

   // Swapping back first and last elements with swap
   swap ( *deq1.begin( ), *(deq1.end( ) -1 ) );

   cout &lt;&lt; &quot;The deque of CInts with first &amp; last elements swapped back is:\n deq1 = (&quot;;
   for ( d1_Iter = deq1.begin( ); d1_Iter != --deq1.end( ); d1_Iter++ )
      cout &lt;&lt; &quot; &quot; &lt;&lt; *d1_Iter &lt;&lt; &quot;,&quot;;
   d1_Iter = --deq1.end( );
   cout &lt;&lt; &quot; &quot; &lt;&lt; *d1_Iter &lt;&lt; &quot; ).&quot; &lt;&lt; endl;

   // Swapping a vector element with a deque element
   vector &lt;int&gt; v1;
   vector &lt;int&gt;::iterator Iter1;
   deque &lt;int&gt; deq2;
   deque &lt;int&gt;::iterator d2_Iter;

   int i;
   for ( i = 0 ; i &lt;= 3 ; i++ )
   {
      v1.push_back( i );
   }

   int ii;
   for ( ii = 4 ; ii &lt;= 5 ; ii++ )
   {
      deq2.push_back( ii );
   }

   cout &lt;&lt; &quot;Vector v1 is ( &quot; ;
   for ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ; Iter1++ )
      cout &lt;&lt; *Iter1 &lt;&lt; &quot; &quot;;
   cout &lt;&lt; &quot;).&quot; &lt;&lt; endl;

   cout &lt;&lt; &quot;Deque deq2 is ( &quot; ;
   for ( d2_Iter = deq2.begin( ) ; d2_Iter != deq2.end( ) ; d2_Iter++ )
      cout &lt;&lt; *d2_Iter &lt;&lt; &quot; &quot;;
   cout &lt;&lt; &quot;).&quot; &lt;&lt; endl;

   iter_swap ( v1.begin( ), deq2.begin( ) );

   cout &lt;&lt; &quot;After exchanging first elements,\n vector v1 is: v1 = ( &quot; ;
   for ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ; Iter1++ )
      cout &lt;&lt; *Iter1 &lt;&lt; &quot; &quot;;
   cout &lt;&lt; &quot;).&quot; &lt;&lt; endl &lt;&lt; &quot; &amp; deque deq2 is: deq2 = ( &quot;;
   for ( d2_Iter = deq2.begin( ) ; d2_Iter != deq2.end( ) ; d2_Iter++ )
      cout &lt;&lt; *d2_Iter &lt;&lt; &quot; &quot;;
   cout &lt;&lt; &quot;).&quot; &lt;&lt; endl;
}
"><span class="hljs-comment">// alg_iter_swap.cpp</span>
<span class="hljs-comment">// compile with: /EHsc</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;deque&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;ostream&gt;</span></span>

<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CInt</span>;</span>
ostream&amp; <span class="hljs-keyword">operator</span>&lt;&lt;( ostream&amp; osIn, <span class="hljs-keyword">const</span> CInt&amp; rhs );

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CInt</span>
{</span>
<span class="hljs-keyword">public</span>:
   CInt( <span class="hljs-keyword">int</span> n = <span class="hljs-number">0</span> ) : m_nVal( n ){}
   CInt( <span class="hljs-keyword">const</span> CInt&amp; rhs ) : m_nVal( rhs.m_nVal ){}
   CInt&amp;   <span class="hljs-keyword">operator</span>=( <span class="hljs-keyword">const</span> CInt&amp; rhs ) { m_nVal =
   rhs.m_nVal; <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>; }
   <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>&lt;( <span class="hljs-keyword">const</span> CInt&amp; rhs ) <span class="hljs-keyword">const</span>
      { <span class="hljs-keyword">return</span> ( m_nVal &lt; rhs.m_nVal );}
   <span class="hljs-keyword">friend</span> ostream&amp; <span class="hljs-keyword">operator</span>&lt;&lt;( ostream&amp; osIn, <span class="hljs-keyword">const</span> CInt&amp; rhs );

<span class="hljs-keyword">private</span>:
   <span class="hljs-keyword">int</span> m_nVal;
};

<span class="hljs-keyword">inline</span> ostream&amp; <span class="hljs-keyword">operator</span>&lt;&lt;( ostream&amp; osIn, <span class="hljs-keyword">const</span> CInt&amp; rhs )
{
   osIn &lt;&lt; <span class="hljs-string">"CInt("</span> &lt;&lt; rhs.m_nVal &lt;&lt; <span class="hljs-string">")"</span>;
   <span class="hljs-keyword">return</span> osIn;
}

<span class="hljs-comment">// Return whether modulus of elem1 is less than modulus of elem2</span>
<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">mod_lesser</span> <span class="hljs-params">( <span class="hljs-keyword">int</span> elem1, <span class="hljs-keyword">int</span> elem2 )</span>
</span>{
   <span class="hljs-keyword">if</span> ( elem1 &lt; <span class="hljs-number">0</span> )
      elem1 = - elem1;
   <span class="hljs-keyword">if</span> ( elem2 &lt; <span class="hljs-number">0</span> )
      elem2 = - elem2;
   <span class="hljs-keyword">return</span> elem1 &lt; elem2;
};

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
   CInt c1 = <span class="hljs-number">5</span>, c2 = <span class="hljs-number">1</span>, c3 = <span class="hljs-number">10</span>;
   <span class="hljs-built_in">deque</span>&lt;CInt&gt; deq1;
   <span class="hljs-built_in">deque</span>&lt;CInt&gt;::iterator d1_Iter;

   deq1.push_back ( c1 );
   deq1.push_back ( c2 );
   deq1.push_back ( c3 );

   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"The original deque of CInts is deq1 = ("</span>;
   <span class="hljs-keyword">for</span> ( d1_Iter = deq1.begin( ); d1_Iter != --deq1.end( ); d1_Iter++ )
      <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">" "</span> &lt;&lt; *d1_Iter &lt;&lt; <span class="hljs-string">","</span>;
   d1_Iter = --deq1.end( );
   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">" "</span> &lt;&lt; *d1_Iter &lt;&lt; <span class="hljs-string">" )."</span> &lt;&lt; <span class="hljs-built_in">endl</span>;

   <span class="hljs-comment">// Exchanging first and last elements with iter_swap</span>
   iter_swap ( deq1.begin( ), --deq1.end( ) );

   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"The deque of CInts with first &amp; last elements swapped is:\n deq1 = ("</span>;
   <span class="hljs-keyword">for</span> ( d1_Iter = deq1.begin( ); d1_Iter != --deq1.end( ); d1_Iter++ )
      <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">" "</span> &lt;&lt; *d1_Iter &lt;&lt; <span class="hljs-string">","</span>;
   d1_Iter = --deq1.end( );
   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">" "</span> &lt;&lt; *d1_Iter &lt;&lt; <span class="hljs-string">" )."</span> &lt;&lt; <span class="hljs-built_in">endl</span>;

   <span class="hljs-comment">// Swapping back first and last elements with swap</span>
   swap ( *deq1.begin( ), *(deq1.end( ) <span class="hljs-number">-1</span> ) );

   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"The deque of CInts with first &amp; last elements swapped back is:\n deq1 = ("</span>;
   <span class="hljs-keyword">for</span> ( d1_Iter = deq1.begin( ); d1_Iter != --deq1.end( ); d1_Iter++ )
      <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">" "</span> &lt;&lt; *d1_Iter &lt;&lt; <span class="hljs-string">","</span>;
   d1_Iter = --deq1.end( );
   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">" "</span> &lt;&lt; *d1_Iter &lt;&lt; <span class="hljs-string">" )."</span> &lt;&lt; <span class="hljs-built_in">endl</span>;

   <span class="hljs-comment">// Swapping a vector element with a deque element</span>
   <span class="hljs-built_in">vector</span> &lt;<span class="hljs-keyword">int</span>&gt; v1;
   <span class="hljs-built_in">vector</span> &lt;<span class="hljs-keyword">int</span>&gt;::iterator Iter1;
   <span class="hljs-built_in">deque</span> &lt;<span class="hljs-keyword">int</span>&gt; deq2;
   <span class="hljs-built_in">deque</span> &lt;<span class="hljs-keyword">int</span>&gt;::iterator d2_Iter;

   <span class="hljs-keyword">int</span> i;
   <span class="hljs-keyword">for</span> ( i = <span class="hljs-number">0</span> ; i &lt;= <span class="hljs-number">3</span> ; i++ )
   {
      v1.push_back( i );
   }

   <span class="hljs-keyword">int</span> ii;
   <span class="hljs-keyword">for</span> ( ii = <span class="hljs-number">4</span> ; ii &lt;= <span class="hljs-number">5</span> ; ii++ )
   {
      deq2.push_back( ii );
   }

   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Vector v1 is ( "</span> ;
   <span class="hljs-keyword">for</span> ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ; Iter1++ )
      <span class="hljs-built_in">cout</span> &lt;&lt; *Iter1 &lt;&lt; <span class="hljs-string">" "</span>;
   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">")."</span> &lt;&lt; <span class="hljs-built_in">endl</span>;

   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Deque deq2 is ( "</span> ;
   <span class="hljs-keyword">for</span> ( d2_Iter = deq2.begin( ) ; d2_Iter != deq2.end( ) ; d2_Iter++ )
      <span class="hljs-built_in">cout</span> &lt;&lt; *d2_Iter &lt;&lt; <span class="hljs-string">" "</span>;
   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">")."</span> &lt;&lt; <span class="hljs-built_in">endl</span>;

   iter_swap ( v1.begin( ), deq2.begin( ) );

   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"After exchanging first elements,\n vector v1 is: v1 = ( "</span> ;
   <span class="hljs-keyword">for</span> ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ; Iter1++ )
      <span class="hljs-built_in">cout</span> &lt;&lt; *Iter1 &lt;&lt; <span class="hljs-string">" "</span>;
   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">")."</span> &lt;&lt; <span class="hljs-built_in">endl</span> &lt;&lt; <span class="hljs-string">" &amp; deque deq2 is: deq2 = ( "</span>;
   <span class="hljs-keyword">for</span> ( d2_Iter = deq2.begin( ) ; d2_Iter != deq2.end( ) ; d2_Iter++ )
      <span class="hljs-built_in">cout</span> &lt;&lt; *d2_Iter &lt;&lt; <span class="hljs-string">" "</span>;
   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">")."</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
}
</code></pre>
<div class="codeHeader" id="code-try-62" data-bi-name="code-header"><span class="language">Output</span>
			<button class="action" data-bi-name="copy">
				<span class="docon docon-edit-copy" role="presentation"></span>
				<span>Copy</span>
			</button></div><pre><code class="lang-Output" data-author-content="The original deque of CInts is deq1 = ( CInt(5), CInt(1), CInt(10) ).
The deque of CInts with first &amp; last elements swapped is:
deq1 = ( CInt(10), CInt(1), CInt(5) ).
The deque of CInts with first &amp; last elements swapped back is:
deq1 = ( CInt(5), CInt(1), CInt(10) ).
Vector v1 is ( 0 1 2 3 ).
Deque deq2 is ( 4 5 ).
After exchanging first elements,
vector v1 is: v1 = ( 4 1 2 3 ).
&amp; deque deq2 is: deq2 = ( 0 5 ).
">The original deque of CInts is deq1 = ( CInt(5), CInt(1), CInt(10) ).
The deque of CInts with first &amp; last elements swapped is:
deq1 = ( CInt(10), CInt(1), CInt(5) ).
The deque of CInts with first &amp; last elements swapped back is:
deq1 = ( CInt(5), CInt(1), CInt(10) ).
Vector v1 is ( 0 1 2 3 ).
Deque deq2 is ( 4 5 ).
After exchanging first elements,
vector v1 is: v1 = ( 4 1 2 3 ).
&amp; deque deq2 is: deq2 = ( 0 5 ).
</code></pre>
<h2 id="lexicographical_compare" class="heading-with-anchor">  lexicographical_compare<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#lexicographical_compare"></a></h2>
<p>Compares element by element between two sequences to determine which is lesser of the two.</p>
<div class="codeHeader" id="code-try-63" data-bi-name="code-header"><span class="language">C++</span>
			<button class="action" data-bi-name="copy">
				<span class="docon docon-edit-copy" role="presentation"></span>
				<span>Copy</span>
			</button></div><pre><code class="lang-cpp" data-author-content="template&lt;class InputIterator1, class InputIterator2&gt;
bool lexicographical_compare(
    InputIterator1  first1,
    InputIterator1 Last1,
    InputIterator2  first2,
    InputIterator2 Last2  );

template&lt;class InputIterator1, class InputIterator2, class BinaryPredicate&gt;
bool lexicographical_compare(
    InputIterator1  first1,
    InputIterator1 Last1,
    InputIterator2  first2,
    InputIterator2 Last2,
    BinaryPredicate  comp  );
"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InputIterator1</span>, <span class="hljs-title">class</span> <span class="hljs-title">InputIterator2</span>&gt;
<span class="hljs-title">bool</span> <span class="hljs-title">lexicographical_compare</span>(
    <span class="hljs-title">InputIterator1</span>  <span class="hljs-title">first1</span>,
    <span class="hljs-title">InputIterator1</span> <span class="hljs-title">Last1</span>,
    <span class="hljs-title">InputIterator2</span>  <span class="hljs-title">first2</span>,
    <span class="hljs-title">InputIterator2</span> <span class="hljs-title">Last2</span>  );</span>

<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InputIterator1</span>, <span class="hljs-title">class</span> <span class="hljs-title">InputIterator2</span>, <span class="hljs-title">class</span> <span class="hljs-title">BinaryPredicate</span>&gt;
<span class="hljs-title">bool</span> <span class="hljs-title">lexicographical_compare</span>(
    <span class="hljs-title">InputIterator1</span>  <span class="hljs-title">first1</span>,
    <span class="hljs-title">InputIterator1</span> <span class="hljs-title">Last1</span>,
    <span class="hljs-title">InputIterator2</span>  <span class="hljs-title">first2</span>,
    <span class="hljs-title">InputIterator2</span> <span class="hljs-title">Last2</span>,
    <span class="hljs-title">BinaryPredicate</span>  <span class="hljs-title">comp</span>  );</span>
</code></pre>
<h3 id="parameters-31" class="heading-with-anchor">Parameters<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#parameters-31"></a></h3>
<p><em>first1</em><br>
An input iterator addressing the position of the first element in the first range to be compared.</p>
<p><em>last1</em><br>
An input iterator addressing the position one past the final element in the first range to be compared.</p>
<p><em>first2</em><br>
An input iterator addressing the position of the first element in the second range to be compared.</p>
<p><em>last2</em><br>
An input iterator addressing the position one past the final element in the second range to be compared.</p>
<p><em>comp</em><br>
User-defined predicate function object that defines sense in which one element is less than another. A binary predicate takes two arguments and returns <strong>true</strong> when satisfied and <strong>false</strong> when not satisfied.</p>
<h3 id="return-value-25" class="heading-with-anchor">Return Value<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#return-value-25"></a></h3>
<p><strong>true</strong> if the first range is lexicographically less than the second range; otherwise <strong>false</strong>.</p>
<h3 id="remarks-31" class="heading-with-anchor">Remarks<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#remarks-31"></a></h3>
<p>A lexicographical comparison between sequences compares them element by element until:</p>
<ul>
<li><p>It finds two corresponding elements unequal, and the result of their comparison is taken as the result of the comparison between sequences.</p>
</li>
<li><p>No inequalities are found, but one sequence has more elements than the other, and the shorter sequence is considered less than the longer sequence.</p>
</li>
<li><p>No inequalities are found and the sequences have the same number of elements, and so the sequences are equal and the result of the comparison is false.</p>
</li>
</ul>
<h3 id="example-20" class="heading-with-anchor">Example<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#example-20"></a></h3>
<div class="codeHeader" id="code-try-64" data-bi-name="code-header"><span class="language">C++</span>
			<button class="action" data-bi-name="copy">
				<span class="docon docon-edit-copy" role="presentation"></span>
				<span>Copy</span>
			</button></div><pre><code class="lang-cpp" data-author-content="// alg_lex_comp.cpp
// compile with: /EHsc
#include &lt;vector&gt;
#include &lt;list&gt;
#include &lt;algorithm&gt;
#include &lt;iostream&gt;

// Return whether second element is twice the first
bool twice ( int elem1, int elem2 )
{
   return 2 * elem1 &lt; elem2;
}

int main()
{
   using namespace std;
   vector &lt;int&gt; v1, v2;
   list &lt;int&gt; L1;
   vector &lt;int&gt;::iterator Iter1, Iter2;
   list &lt;int&gt;::iterator L1_Iter, L1_inIter;

   int i;
   for ( i = 0 ; i &lt;= 5 ; i++ )
   {
      v1.push_back( 5 * i );
   }
   int ii;
   for ( ii = 0 ; ii &lt;= 6 ; ii++ )
   {
      L1.push_back( 5 * ii );
   }

   int iii;
   for ( iii = 0 ; iii &lt;= 5 ; iii++ )
   {
      v2.push_back( 10 * iii );
   }

   cout &lt;&lt; &quot;Vector v1 = ( &quot; ;
   for ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ; Iter1++ )
      cout &lt;&lt; *Iter1 &lt;&lt; &quot; &quot;;
   cout &lt;&lt; &quot;)&quot; &lt;&lt; endl;

   cout &lt;&lt; &quot;List L1 = ( &quot; ;
   for ( L1_Iter = L1.begin( ) ; L1_Iter!= L1.end( ) ; L1_Iter++ )
      cout &lt;&lt; *L1_Iter &lt;&lt; &quot; &quot;;
   cout &lt;&lt; &quot;)&quot; &lt;&lt; endl;

   cout &lt;&lt; &quot;Vector v2 = ( &quot; ;
   for ( Iter2 = v2.begin( ) ; Iter2 != v2.end( ) ; Iter2++ )
      cout &lt;&lt; *Iter2 &lt;&lt; &quot; &quot;;
      cout &lt;&lt; &quot;)&quot; &lt;&lt; endl;

   // Self lexicographical_comparison of v1 under identity
   bool result1;
   result1 = lexicographical_compare (v1.begin( ), v1.end( ),
                  v1.begin( ), v1.end( ) );
   if ( result1 )
      cout &lt;&lt; &quot;Vector v1 is lexicographically_less than v1.&quot; &lt;&lt; endl;
   else
      cout &lt;&lt; &quot;Vector v1 is not lexicographically_less than v1.&quot; &lt;&lt; endl;

   // lexicographical_comparison of v1 and L2 under identity
   bool result2;
   result2 = lexicographical_compare (v1.begin( ), v1.end( ),
                  L1.begin( ), L1.end( ) );
   if ( result2 )
      cout &lt;&lt; &quot;Vector v1 is lexicographically_less than L1.&quot; &lt;&lt; endl;
   else
      cout &lt;&lt; &quot;Vector v1 is lexicographically_less than L1.&quot; &lt;&lt; endl;

   bool result3;
   result3 = lexicographical_compare (v1.begin( ), v1.end( ),
                  v2.begin( ), v2.end( ), twice );
   if ( result3 )
      cout &lt;&lt; &quot;Vector v1 is lexicographically_less than v2 &quot;
           &lt;&lt; &quot;under twice.&quot; &lt;&lt; endl;
   else
      cout &lt;&lt; &quot;Vector v1 is not lexicographically_less than v2 &quot;
           &lt;&lt; &quot;under twice.&quot; &lt;&lt; endl;
}
"><span class="hljs-comment">// alg_lex_comp.cpp</span>
<span class="hljs-comment">// compile with: /EHsc</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;list&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span>

<span class="hljs-comment">// Return whether second element is twice the first</span>
<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">twice</span> <span class="hljs-params">( <span class="hljs-keyword">int</span> elem1, <span class="hljs-keyword">int</span> elem2 )</span>
</span>{
   <span class="hljs-keyword">return</span> <span class="hljs-number">2</span> * elem1 &lt; elem2;
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
   <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;
   <span class="hljs-built_in">vector</span> &lt;<span class="hljs-keyword">int</span>&gt; v1, v2;
   <span class="hljs-built_in">list</span> &lt;<span class="hljs-keyword">int</span>&gt; L1;
   <span class="hljs-built_in">vector</span> &lt;<span class="hljs-keyword">int</span>&gt;::iterator Iter1, Iter2;
   <span class="hljs-built_in">list</span> &lt;<span class="hljs-keyword">int</span>&gt;::iterator L1_Iter, L1_inIter;

   <span class="hljs-keyword">int</span> i;
   <span class="hljs-keyword">for</span> ( i = <span class="hljs-number">0</span> ; i &lt;= <span class="hljs-number">5</span> ; i++ )
   {
      v1.push_back( <span class="hljs-number">5</span> * i );
   }
   <span class="hljs-keyword">int</span> ii;
   <span class="hljs-keyword">for</span> ( ii = <span class="hljs-number">0</span> ; ii &lt;= <span class="hljs-number">6</span> ; ii++ )
   {
      L1.push_back( <span class="hljs-number">5</span> * ii );
   }

   <span class="hljs-keyword">int</span> iii;
   <span class="hljs-keyword">for</span> ( iii = <span class="hljs-number">0</span> ; iii &lt;= <span class="hljs-number">5</span> ; iii++ )
   {
      v2.push_back( <span class="hljs-number">10</span> * iii );
   }

   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Vector v1 = ( "</span> ;
   <span class="hljs-keyword">for</span> ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ; Iter1++ )
      <span class="hljs-built_in">cout</span> &lt;&lt; *Iter1 &lt;&lt; <span class="hljs-string">" "</span>;
   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">")"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;

   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"List L1 = ( "</span> ;
   <span class="hljs-keyword">for</span> ( L1_Iter = L1.begin( ) ; L1_Iter!= L1.end( ) ; L1_Iter++ )
      <span class="hljs-built_in">cout</span> &lt;&lt; *L1_Iter &lt;&lt; <span class="hljs-string">" "</span>;
   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">")"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;

   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Vector v2 = ( "</span> ;
   <span class="hljs-keyword">for</span> ( Iter2 = v2.begin( ) ; Iter2 != v2.end( ) ; Iter2++ )
      <span class="hljs-built_in">cout</span> &lt;&lt; *Iter2 &lt;&lt; <span class="hljs-string">" "</span>;
      <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">")"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;

   <span class="hljs-comment">// Self lexicographical_comparison of v1 under identity</span>
   <span class="hljs-keyword">bool</span> result1;
   result1 = lexicographical_compare (v1.begin( ), v1.end( ),
                  v1.begin( ), v1.end( ) );
   <span class="hljs-keyword">if</span> ( result1 )
      <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Vector v1 is lexicographically_less than v1."</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
   <span class="hljs-keyword">else</span>
      <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Vector v1 is not lexicographically_less than v1."</span> &lt;&lt; <span class="hljs-built_in">endl</span>;

   <span class="hljs-comment">// lexicographical_comparison of v1 and L2 under identity</span>
   <span class="hljs-keyword">bool</span> result2;
   result2 = lexicographical_compare (v1.begin( ), v1.end( ),
                  L1.begin( ), L1.end( ) );
   <span class="hljs-keyword">if</span> ( result2 )
      <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Vector v1 is lexicographically_less than L1."</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
   <span class="hljs-keyword">else</span>
      <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Vector v1 is lexicographically_less than L1."</span> &lt;&lt; <span class="hljs-built_in">endl</span>;

   <span class="hljs-keyword">bool</span> result3;
   result3 = lexicographical_compare (v1.begin( ), v1.end( ),
                  v2.begin( ), v2.end( ), twice );
   <span class="hljs-keyword">if</span> ( result3 )
      <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Vector v1 is lexicographically_less than v2 "</span>
           &lt;&lt; <span class="hljs-string">"under twice."</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
   <span class="hljs-keyword">else</span>
      <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Vector v1 is not lexicographically_less than v2 "</span>
           &lt;&lt; <span class="hljs-string">"under twice."</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
}
</code></pre>
<div class="codeHeader" id="code-try-65" data-bi-name="code-header"><span class="language">Output</span>
			<button class="action" data-bi-name="copy">
				<span class="docon docon-edit-copy" role="presentation"></span>
				<span>Copy</span>
			</button></div><pre><code class="lang-Output" data-author-content="Vector v1 = ( 0 5 10 15 20 25 )
List L1 = ( 0 5 10 15 20 25 30 )
Vector v2 = ( 0 10 20 30 40 50 )
Vector v1 is not lexicographically_less than v1.
Vector v1 is lexicographically_less than L1.
Vector v1 is not lexicographically_less than v2 under twice.
">Vector v1 = ( 0 5 10 15 20 25 )
List L1 = ( 0 5 10 15 20 25 30 )
Vector v2 = ( 0 10 20 30 40 50 )
Vector v1 is not lexicographically_less than v1.
Vector v1 is lexicographically_less than L1.
Vector v1 is not lexicographically_less than v2 under twice.
</code></pre>
<h2 id="lower_bound" class="heading-with-anchor">  lower_bound<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#lower_bound"></a></h2>
<p>Finds the position of the first element in an ordered range that has a value greater than or equivalent to a specified value, where the ordering criterion may be specified by a binary predicate.</p>
<div class="codeHeader" id="code-try-66" data-bi-name="code-header"><span class="language">C++</span>
			<button class="action" data-bi-name="copy">
				<span class="docon docon-edit-copy" role="presentation"></span>
				<span>Copy</span>
			</button></div><pre><code class="lang-cpp" data-author-content="template&lt;class ForwardIterator, class Type&gt;
ForwardIterator lower_bound(
    ForwardIterator first,
    ForwardIterator last,
    const Type&amp; value );

template&lt;class ForwardIterator, class Type, class BinaryPredicate&gt;
ForwardIterator lower_bound(
    ForwardIterator first,
    ForwardIterator last,
    const Type&amp; value,
    BinaryPredicate comp );
"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ForwardIterator</span>, <span class="hljs-title">class</span> <span class="hljs-title">Type</span>&gt;
<span class="hljs-title">ForwardIterator</span> <span class="hljs-title">lower_bound</span>(
    <span class="hljs-title">ForwardIterator</span> <span class="hljs-title">first</span>,
    <span class="hljs-title">ForwardIterator</span> <span class="hljs-title">last</span>,
    <span class="hljs-title">const</span> <span class="hljs-title">Type</span>&amp; <span class="hljs-title">value</span> );</span>

<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ForwardIterator</span>, <span class="hljs-title">class</span> <span class="hljs-title">Type</span>, <span class="hljs-title">class</span> <span class="hljs-title">BinaryPredicate</span>&gt;
<span class="hljs-title">ForwardIterator</span> <span class="hljs-title">lower_bound</span>(
    <span class="hljs-title">ForwardIterator</span> <span class="hljs-title">first</span>,
    <span class="hljs-title">ForwardIterator</span> <span class="hljs-title">last</span>,
    <span class="hljs-title">const</span> <span class="hljs-title">Type</span>&amp; <span class="hljs-title">value</span>,
    <span class="hljs-title">BinaryPredicate</span> <span class="hljs-title">comp</span> );</span>
</code></pre>
<h3 id="parameters-32" class="heading-with-anchor">Parameters<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#parameters-32"></a></h3>
<p><em>first</em><br>
A forward iterator addressing the position of the first element in the range to be searched.</p>
<p><em>last</em><br>
A forward iterator addressing the position one past the final element in the range to be searched.</p>
<p><em>value</em><br>
The value whose first position or possible first position is being searched for in the ordered range.</p>
<p><em>comp</em><br>
User-defined predicate function object that defines sense in which one element is less than another. A binary predicate takes two arguments and returns <strong>true</strong> when satisfied and <strong>false</strong> when not satisfied.</p>
<h3 id="return-value-26" class="heading-with-anchor">Return Value<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#return-value-26"></a></h3>
<p>A forward iterator at the position of the first element in an ordered range with a value that is greater than or equivalent to a specified value, where the equivalence is specified with a binary predicate.</p>
<h3 id="remarks-32" class="heading-with-anchor">Remarks<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#remarks-32"></a></h3>
<p>The sorted source range referenced must be valid; all iterators must be dereferenceable and within the sequence the last position must be reachable from the first by incrementation.</p>
<p>A sorted range is a precondition of using <code>lower_bound</code> and where the ordering is the same as specified by with binary predicate.</p>
<p>The range is not modified by the algorithm <code>lower_bound</code>.</p>
<p>The value types of the forward iterators need be less-than comparable to be ordered, so that, given two elements, it may be determined either that they are equivalent (in the sense that neither is less than the other) or that one is less than the other. This results in an ordering between the nonequivalent elements</p>
<p>The complexity of the algorithm is logarithmic for random-access iterators and linear otherwise, with the number of steps proportional to (<code>last - first</code>).</p>
<h3 id="example-21" class="heading-with-anchor">Example<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#example-21"></a></h3>
<div class="codeHeader" id="code-try-67" data-bi-name="code-header"><span class="language">C++</span>
			<button class="action" data-bi-name="copy">
				<span class="docon docon-edit-copy" role="presentation"></span>
				<span>Copy</span>
			</button></div><pre><code class="lang-cpp" data-author-content="// alg_lower_bound.cpp
// compile with: /EHsc
#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;functional&gt;      // greater&lt;int&gt;( )
#include &lt;iostream&gt;

// Return whether modulus of elem1 is less than modulus of elem2
bool mod_lesser( int elem1, int elem2 )
{
    if ( elem1 &lt; 0 )
        elem1 = - elem1;
    if ( elem2 &lt; 0 )
        elem2 = - elem2;
    return elem1 &lt; elem2;
}

int main()
{
    using namespace std;

    vector&lt;int&gt; v1;
    // Constructing vector v1 with default less-than ordering
    for ( auto i = -1 ; i &lt;= 4 ; ++i )
    {
        v1.push_back(  i );
    }

    for ( auto ii =-3 ; ii &lt;= 0 ; ++ii )
    {
        v1.push_back(  ii  );
    }

    cout &lt;&lt; &quot;Starting vector v1 = ( &quot; ;
    for (const auto &amp;Iter : v1)
        cout &lt;&lt; Iter &lt;&lt; &quot; &quot;;
    cout &lt;&lt; &quot;).&quot; &lt;&lt; endl;

    sort(v1.begin(), v1.end());
    cout &lt;&lt; &quot;Original vector v1 with range sorted by the\n &quot;
        &lt;&lt; &quot;binary predicate less than is v1 = ( &quot; ;
    for (const auto &amp;Iter : v1)
        cout &lt;&lt; Iter &lt;&lt; &quot; &quot;;
    cout &lt;&lt; &quot;).&quot; &lt;&lt; endl;

    // Constructing vector v2 with range sorted by greater
    vector&lt;int&gt; v2(v1);

    sort(v2.begin(), v2.end(), greater&lt;int&gt;());

    cout &lt;&lt; &quot;Original vector v2 with range sorted by the\n &quot;
        &lt;&lt; &quot;binary predicate greater is v2 = ( &quot; ;
    for (const auto &amp;Iter : v2)
        cout &lt;&lt; Iter &lt;&lt; &quot; &quot;;
    cout &lt;&lt; &quot;).&quot; &lt;&lt; endl;

    // Constructing vectors v3 with range sorted by mod_lesser
    vector&lt;int&gt; v3(v1);
    sort(v3.begin(), v3.end(), mod_lesser);

    cout &lt;&lt; &quot;Original vector v3 with range sorted by the\n &quot;
        &lt;&lt;  &quot;binary predicate mod_lesser is v3 = ( &quot; ;
    for (const auto &amp;Iter : v3)
        cout &lt;&lt; Iter &lt;&lt; &quot; &quot;;
    cout &lt;&lt; &quot;).&quot; &lt;&lt; endl;

    // Demonstrate lower_bound

    vector&lt;int&gt;::iterator Result;

    // lower_bound of 3 in v1 with default binary predicate less&lt;int&gt;()
    Result = lower_bound(v1.begin(), v1.end(), 3);
    cout &lt;&lt; &quot;The lower_bound in v1 for the element with a value of 3 is: &quot;
        &lt;&lt; *Result &lt;&lt; &quot;.&quot; &lt;&lt; endl;

    // lower_bound of 3 in v2 with the binary predicate greater&lt;int&gt;( )
    Result = lower_bound(v2.begin(), v2.end(), 3, greater&lt;int&gt;());
    cout &lt;&lt; &quot;The lower_bound in v2 for the element with a value of 3 is: &quot;
        &lt;&lt; *Result &lt;&lt; &quot;.&quot; &lt;&lt; endl;

    // lower_bound of 3 in v3 with the binary predicate  mod_lesser
    Result = lower_bound(v3.begin(), v3.end(), 3,  mod_lesser);
    cout &lt;&lt; &quot;The lower_bound in v3 for the element with a value of 3 is: &quot;
        &lt;&lt; *Result &lt;&lt; &quot;.&quot; &lt;&lt; endl;
}
"><span class="hljs-comment">// alg_lower_bound.cpp</span>
<span class="hljs-comment">// compile with: /EHsc</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;functional&gt;      // greater&lt;int&gt;( )</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span>

<span class="hljs-comment">// Return whether modulus of elem1 is less than modulus of elem2</span>
<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">mod_lesser</span><span class="hljs-params">( <span class="hljs-keyword">int</span> elem1, <span class="hljs-keyword">int</span> elem2 )</span>
</span>{
    <span class="hljs-keyword">if</span> ( elem1 &lt; <span class="hljs-number">0</span> )
        elem1 = - elem1;
    <span class="hljs-keyword">if</span> ( elem2 &lt; <span class="hljs-number">0</span> )
        elem2 = - elem2;
    <span class="hljs-keyword">return</span> elem1 &lt; elem2;
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;

    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; v1;
    <span class="hljs-comment">// Constructing vector v1 with default less-than ordering</span>
    <span class="hljs-keyword">for</span> ( <span class="hljs-keyword">auto</span> i = <span class="hljs-number">-1</span> ; i &lt;= <span class="hljs-number">4</span> ; ++i )
    {
        v1.push_back(  i );
    }

    <span class="hljs-keyword">for</span> ( <span class="hljs-keyword">auto</span> ii =<span class="hljs-number">-3</span> ; ii &lt;= <span class="hljs-number">0</span> ; ++ii )
    {
        v1.push_back(  ii  );
    }

    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Starting vector v1 = ( "</span> ;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> &amp;Iter : v1)
        <span class="hljs-built_in">cout</span> &lt;&lt; Iter &lt;&lt; <span class="hljs-string">" "</span>;
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">")."</span> &lt;&lt; <span class="hljs-built_in">endl</span>;

    sort(v1.begin(), v1.end());
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Original vector v1 with range sorted by the\n "</span>
        &lt;&lt; <span class="hljs-string">"binary predicate less than is v1 = ( "</span> ;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> &amp;Iter : v1)
        <span class="hljs-built_in">cout</span> &lt;&lt; Iter &lt;&lt; <span class="hljs-string">" "</span>;
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">")."</span> &lt;&lt; <span class="hljs-built_in">endl</span>;

    <span class="hljs-comment">// Constructing vector v2 with range sorted by greater</span>
    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; v2(v1);

    sort(v2.begin(), v2.end(), greater&lt;<span class="hljs-keyword">int</span>&gt;());

    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Original vector v2 with range sorted by the\n "</span>
        &lt;&lt; <span class="hljs-string">"binary predicate greater is v2 = ( "</span> ;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> &amp;Iter : v2)
        <span class="hljs-built_in">cout</span> &lt;&lt; Iter &lt;&lt; <span class="hljs-string">" "</span>;
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">")."</span> &lt;&lt; <span class="hljs-built_in">endl</span>;

    <span class="hljs-comment">// Constructing vectors v3 with range sorted by mod_lesser</span>
    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; v3(v1);
    sort(v3.begin(), v3.end(), mod_lesser);

    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Original vector v3 with range sorted by the\n "</span>
        &lt;&lt;  <span class="hljs-string">"binary predicate mod_lesser is v3 = ( "</span> ;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> &amp;Iter : v3)
        <span class="hljs-built_in">cout</span> &lt;&lt; Iter &lt;&lt; <span class="hljs-string">" "</span>;
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">")."</span> &lt;&lt; <span class="hljs-built_in">endl</span>;

    <span class="hljs-comment">// Demonstrate lower_bound</span>

    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;::iterator Result;

    <span class="hljs-comment">// lower_bound of 3 in v1 with default binary predicate less&lt;int&gt;()</span>
    Result = lower_bound(v1.begin(), v1.end(), <span class="hljs-number">3</span>);
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"The lower_bound in v1 for the element with a value of 3 is: "</span>
        &lt;&lt; *Result &lt;&lt; <span class="hljs-string">"."</span> &lt;&lt; <span class="hljs-built_in">endl</span>;

    <span class="hljs-comment">// lower_bound of 3 in v2 with the binary predicate greater&lt;int&gt;( )</span>
    Result = lower_bound(v2.begin(), v2.end(), <span class="hljs-number">3</span>, greater&lt;<span class="hljs-keyword">int</span>&gt;());
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"The lower_bound in v2 for the element with a value of 3 is: "</span>
        &lt;&lt; *Result &lt;&lt; <span class="hljs-string">"."</span> &lt;&lt; <span class="hljs-built_in">endl</span>;

    <span class="hljs-comment">// lower_bound of 3 in v3 with the binary predicate  mod_lesser</span>
    Result = lower_bound(v3.begin(), v3.end(), <span class="hljs-number">3</span>,  mod_lesser);
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"The lower_bound in v3 for the element with a value of 3 is: "</span>
        &lt;&lt; *Result &lt;&lt; <span class="hljs-string">"."</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
}
</code></pre>
<h2 id="make_heap" class="heading-with-anchor">  make_heap<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#make_heap"></a></h2>
<p>Converts elements from a specified range into a heap in which the first element is the largest and for which a sorting criterion may be specified with a binary predicate.</p>
<div class="codeHeader" id="code-try-68" data-bi-name="code-header"><span class="language">C++</span>
			<button class="action" data-bi-name="copy">
				<span class="docon docon-edit-copy" role="presentation"></span>
				<span>Copy</span>
			</button></div><pre><code class="lang-cpp" data-author-content="template&lt;class RandomAccessIterator&gt;
void make_heap(
    RandomAccessIterator first,
    RandomAccessIterator last );

template&lt;class RandomAccessIterator, class BinaryPredicate&gt;
void make_heap(
    RandomAccessIterator first,
    RandomAccessIterator last,
    BinaryPredicate comp );
"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RandomAccessIterator</span>&gt;
<span class="hljs-title">void</span> <span class="hljs-title">make_heap</span>(
    <span class="hljs-title">RandomAccessIterator</span> <span class="hljs-title">first</span>,
    <span class="hljs-title">RandomAccessIterator</span> <span class="hljs-title">last</span> );</span>

<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RandomAccessIterator</span>, <span class="hljs-title">class</span> <span class="hljs-title">BinaryPredicate</span>&gt;
<span class="hljs-title">void</span> <span class="hljs-title">make_heap</span>(
    <span class="hljs-title">RandomAccessIterator</span> <span class="hljs-title">first</span>,
    <span class="hljs-title">RandomAccessIterator</span> <span class="hljs-title">last</span>,
    <span class="hljs-title">BinaryPredicate</span> <span class="hljs-title">comp</span> );</span>
</code></pre>
<h3 id="parameters-33" class="heading-with-anchor">Parameters<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#parameters-33"></a></h3>
<p><em>first</em><br>
A random-access iterator addressing the position of the first element in the range to be converted into a heap.</p>
<p><em>last</em><br>
A random-access iterator addressing the position one past the final element in the range to be converted into a heap.</p>
<p><em>comp</em><br>
User-defined predicate function object that defines sense in which one element is less than another. A binary predicate takes two arguments and returns <strong>true</strong> when satisfied and <strong>false</strong> when not satisfied.</p>
<h3 id="remarks-33" class="heading-with-anchor">Remarks<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#remarks-33"></a></h3>
<p>Heaps have two properties:</p>
<ul>
<li><p>The first element is always the largest.</p>
</li>
<li><p>Elements may be added or removed in logarithmic time.</p>
</li>
</ul>
<p>Heaps are an ideal way to implement priority queues and they are used in the implementation of the C++ Standard Library container adaptor <a href="https://docs.microsoft.com/en-us/cpp/standard-library/priority-queue-class?view=vs-2019" data-linktype="relative-path">priority_queue Class</a>.</p>
<p>The complexity is linear, requiring 3 * ( * last - first*) comparisons.</p>
<h3 id="example-22" class="heading-with-anchor">Example<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#example-22"></a></h3>
<div class="codeHeader" id="code-try-69" data-bi-name="code-header"><span class="language">C++</span>
			<button class="action" data-bi-name="copy">
				<span class="docon docon-edit-copy" role="presentation"></span>
				<span>Copy</span>
			</button></div><pre><code class="lang-cpp" data-author-content="// alg_make_heap.cpp
// compile with: /EHsc
#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;functional&gt;
#include &lt;iostream&gt;

int main() {
   using namespace std;
   vector &lt;int&gt; v1, v2;
   vector &lt;int&gt;::iterator Iter1, Iter2;

   int i;
   for ( i = 0 ; i &lt;= 9 ; i++ )
      v1.push_back( i );

   random_shuffle( v1.begin( ), v1.end( ) );

   cout &lt;&lt; &quot;Vector v1 is ( &quot; ;
   for ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ; Iter1++ )
      cout &lt;&lt; *Iter1 &lt;&lt; &quot; &quot;;
   cout &lt;&lt; &quot;).&quot; &lt;&lt; endl;

   // Make v1 a heap with default less than ordering
   make_heap ( v1.begin( ), v1.end( ) );
   cout &lt;&lt; &quot;The heaped version of vector v1 is ( &quot; ;
   for ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ; Iter1++ )
      cout &lt;&lt; *Iter1 &lt;&lt; &quot; &quot;;
   cout &lt;&lt; &quot;).&quot; &lt;&lt; endl;

   // Make v1 a heap with greater than ordering
   make_heap ( v1.begin( ), v1.end( ), greater&lt;int&gt;( ) );
   cout &lt;&lt; &quot;The greater-than heaped version of v1 is ( &quot; ;
   for ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ; Iter1++ )
      cout &lt;&lt; *Iter1 &lt;&lt; &quot; &quot;;
   cout &lt;&lt; &quot;).&quot; &lt;&lt; endl;
}
"><span class="hljs-comment">// alg_make_heap.cpp</span>
<span class="hljs-comment">// compile with: /EHsc</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;functional&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span>

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
   <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;
   <span class="hljs-built_in">vector</span> &lt;<span class="hljs-keyword">int</span>&gt; v1, v2;
   <span class="hljs-built_in">vector</span> &lt;<span class="hljs-keyword">int</span>&gt;::iterator Iter1, Iter2;

   <span class="hljs-keyword">int</span> i;
   <span class="hljs-keyword">for</span> ( i = <span class="hljs-number">0</span> ; i &lt;= <span class="hljs-number">9</span> ; i++ )
      v1.push_back( i );

   random_shuffle( v1.begin( ), v1.end( ) );

   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Vector v1 is ( "</span> ;
   <span class="hljs-keyword">for</span> ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ; Iter1++ )
      <span class="hljs-built_in">cout</span> &lt;&lt; *Iter1 &lt;&lt; <span class="hljs-string">" "</span>;
   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">")."</span> &lt;&lt; <span class="hljs-built_in">endl</span>;

   <span class="hljs-comment">// Make v1 a heap with default less than ordering</span>
   make_heap ( v1.begin( ), v1.end( ) );
   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"The heaped version of vector v1 is ( "</span> ;
   <span class="hljs-keyword">for</span> ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ; Iter1++ )
      <span class="hljs-built_in">cout</span> &lt;&lt; *Iter1 &lt;&lt; <span class="hljs-string">" "</span>;
   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">")."</span> &lt;&lt; <span class="hljs-built_in">endl</span>;

   <span class="hljs-comment">// Make v1 a heap with greater than ordering</span>
   make_heap ( v1.begin( ), v1.end( ), greater&lt;<span class="hljs-keyword">int</span>&gt;( ) );
   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"The greater-than heaped version of v1 is ( "</span> ;
   <span class="hljs-keyword">for</span> ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ; Iter1++ )
      <span class="hljs-built_in">cout</span> &lt;&lt; *Iter1 &lt;&lt; <span class="hljs-string">" "</span>;
   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">")."</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
}
</code></pre>
<h2 id="max" class="heading-with-anchor">  max<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#max"></a></h2>
<p>Compares two objects and returns the larger of the two, where the ordering criterion may be specified by a binary predicate.</p>
<div class="codeHeader" id="code-try-70" data-bi-name="code-header"><span class="language">C++</span>
			<button class="action" data-bi-name="copy">
				<span class="docon docon-edit-copy" role="presentation"></span>
				<span>Copy</span>
			</button></div><pre><code class="lang-cpp" data-author-content="template&lt;class Type&gt;
constexpr Type&amp; max(
    const Type&amp; left,
    const Type&amp; right);
template&lt;class Type, class Pr&gt;
constexpr Type&amp; max(
    const Type&amp; left,
    const Type&amp; right,
    BinaryPredicate comp);
template&lt;class Type&gt;
constexpr Type&amp; max (
    initializer_list&lt;Type&gt; );
template&lt;class Type, class Pr&gt;
constexpr Type&amp; max(
    initializer_list&lt;Type&gt; ,
    BinaryPredicate comp);
"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Type</span>&gt;
<span class="hljs-title">constexpr</span> <span class="hljs-title">Type</span>&amp; <span class="hljs-title">max</span>(
    <span class="hljs-title">const</span> <span class="hljs-title">Type</span>&amp; <span class="hljs-title">left</span>,
    <span class="hljs-title">const</span> <span class="hljs-title">Type</span>&amp; <span class="hljs-title">right</span>);</span>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Type</span>, <span class="hljs-title">class</span> <span class="hljs-title">Pr</span>&gt;
<span class="hljs-title">constexpr</span> <span class="hljs-title">Type</span>&amp; <span class="hljs-title">max</span>(
    <span class="hljs-title">const</span> <span class="hljs-title">Type</span>&amp; <span class="hljs-title">left</span>,
    <span class="hljs-title">const</span> <span class="hljs-title">Type</span>&amp; <span class="hljs-title">right</span>,
    <span class="hljs-title">BinaryPredicate</span> <span class="hljs-title">comp</span>);</span>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Type</span>&gt;
<span class="hljs-title">constexpr</span> <span class="hljs-title">Type</span>&amp; <span class="hljs-title">max</span> (
    <span class="hljs-title">initializer_list</span>&lt;Type&gt; );</span>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Type</span>, <span class="hljs-title">class</span> <span class="hljs-title">Pr</span>&gt;
<span class="hljs-title">constexpr</span> <span class="hljs-title">Type</span>&amp; <span class="hljs-title">max</span>(
    <span class="hljs-title">initializer_list</span>&lt;Type&gt; ,
    <span class="hljs-title">BinaryPredicate</span> <span class="hljs-title">comp</span>);</span>
</code></pre>
<h3 id="parameters-34" class="heading-with-anchor">Parameters<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#parameters-34"></a></h3>
<p><em>left</em><br>
The first of the two objects being compared.</p>
<p><em>right</em><br>
The second of the two objects being compared.</p>
<p><em>comp</em><br>
A binary predicate used to compare the two objects.</p>
<p><em>_IList</em><br>
The initializer list that contains the objects to be compared.</p>
<h3 id="return-value-27" class="heading-with-anchor">Return Value<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#return-value-27"></a></h3>
<p>The greater of the two objects, unless neither is greater; in that case, it returns the first of the two objects. In the case of an initializer_list, it returns the greatest of the objects in the list.</p>
<h3 id="remarks-34" class="heading-with-anchor">Remarks<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#remarks-34"></a></h3>
<p>The <code>max</code> algorithm is unusual in having objects passed as parameters. Most C++ Standard Library algorithms operate on a range of elements whose position is specified by iterators passed as parameters. If you need a function that operates on a range of elements, use <a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#max_element" data-linktype="relative-path">max_element</a> instead. Visual Studio 2017 enables <strong>constexpr</strong> on the overloads that take an initializer_list.</p>
<h3 id="example-23" class="heading-with-anchor">Example<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#example-23"></a></h3>
<div class="codeHeader" id="code-try-71" data-bi-name="code-header"><span class="language">C++</span>
			<button class="action" data-bi-name="copy">
				<span class="docon docon-edit-copy" role="presentation"></span>
				<span>Copy</span>
			</button></div><pre><code class="lang-cpp" data-author-content="// alg_max.cpp
// compile with: /EHsc
#include &lt;vector&gt;
#include &lt;set&gt;
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;ostream&gt;

using namespace std;
class CInt;
ostream&amp; operator&lt;&lt;( ostream&amp; osIn, const CInt&amp; rhs );

class CInt
{
public:
   CInt( int n = 0 ) : m_nVal( n ){}
   CInt( const CInt&amp; rhs ) : m_nVal( rhs.m_nVal ){}
   CInt&amp;   operator=( const CInt&amp; rhs ) {m_nVal =
   rhs.m_nVal; return *this;}
   bool operator&lt;( const CInt&amp; rhs ) const
      {return ( m_nVal &lt; rhs.m_nVal );}
   friend ostream&amp; operator&lt;&lt;( ostream&amp; osIn, const CInt&amp; rhs );

private:
   int m_nVal;
};

inline ostream&amp; operator&lt;&lt;( ostream&amp; osIn, const CInt&amp; rhs )
{
   osIn &lt;&lt; &quot;CInt( &quot; &lt;&lt; rhs.m_nVal &lt;&lt; &quot; )&quot;;
   return osIn;
}

// Return whether absolute value of elem1 is greater than
// absolute value of elem2
bool abs_greater ( int elem1, int elem2 )
{
   if ( elem1 &lt; 0 )
      elem1 = -elem1;
   if ( elem2 &lt; 0 )
      elem2 = -elem2;
   return elem1 &lt; elem2;
};

int main()
{
   int a = 6, b = -7;
   // Return the integer with the larger absolute value
   const int&amp; result1 = max(a, b, abs_greater);
   // Return the larger integer
   const int&amp; result2 = max(a, b);

   cout &lt;&lt; &quot;Using integers 6 and -7...&quot; &lt;&lt; endl;
   cout &lt;&lt; &quot;The integer with the greater absolute value is: &quot;
        &lt;&lt; result1 &lt;&lt; &quot;.&quot; &lt;&lt; endl;
   cout &lt;&lt; &quot;The integer with the greater value is: &quot;
        &lt;&lt; result2 &lt;&lt; &quot;.&quot; &lt;&lt; endl;
   cout &lt;&lt; endl;

// Comparing the members of an initializer_list
const int&amp; result3 = max({ a, b });
const int&amp; result4 = max({ a, b }, abs_greater);

cout &lt;&lt; &quot;Comparing the members of an initializer_list...&quot; &lt;&lt; endl;
cout &lt;&lt; &quot;The member with the greater value is: &quot; &lt;&lt; result3 &lt;&lt; endl;
cout &lt;&lt; &quot;The integer with the greater absolute value is: &quot; &lt;&lt; result4 &lt;&lt; endl;

   // Comparing set containers with elements of type CInt
   // using the max algorithm
   CInt c1 = 1, c2 = 2, c3 = 3;
   set&lt;CInt&gt; s1, s2, s3;
   set&lt;CInt&gt;::iterator s1_Iter, s2_Iter, s3_Iter;

   s1.insert ( c1 );
   s1.insert ( c2 );
   s2.insert ( c2 );
   s2.insert ( c3 );

   cout &lt;&lt; &quot;s1 = (&quot;;
   for ( s1_Iter = s1.begin( ); s1_Iter != --s1.end( ); s1_Iter++ )
      cout &lt;&lt; &quot; &quot; &lt;&lt; *s1_Iter &lt;&lt; &quot;,&quot;;
   s1_Iter = --s1.end( );
   cout &lt;&lt; &quot; &quot; &lt;&lt; *s1_Iter &lt;&lt; &quot; ).&quot; &lt;&lt; endl;

   cout &lt;&lt; &quot;s2 = (&quot;;
   for ( s2_Iter = s2.begin( ); s2_Iter != --s2.end( ); s2_Iter++ )
      cout &lt;&lt; &quot; &quot; &lt;&lt; *s2_Iter &lt;&lt; &quot;,&quot;;
   s2_Iter = --s2.end( );
   cout &lt;&lt; &quot; &quot; &lt;&lt; *s2_Iter &lt;&lt; &quot; ).&quot; &lt;&lt; endl;

   s3 = max ( s1, s2 );
   cout &lt;&lt; &quot;s3 = max ( s1, s2 ) = (&quot;;
   for ( s3_Iter = s3.begin( ); s3_Iter != --s3.end( ); s3_Iter++ )
      cout &lt;&lt; &quot; &quot; &lt;&lt; *s3_Iter &lt;&lt; &quot;,&quot;;
   s3_Iter = --s3.end( );
   cout &lt;&lt; &quot; &quot; &lt;&lt; *s3_Iter &lt;&lt; &quot; ).&quot; &lt;&lt; endl &lt;&lt; endl;

   // Comparing vectors with integer elements using the max algorithm
   vector &lt;int&gt; v1, v2, v3, v4, v5;
   vector &lt;int&gt;::iterator Iter1, Iter2, Iter3, Iter4, Iter5;

   int i;
   for ( i = 0 ; i &lt;= 2 ; i++ )
   {
      v1.push_back( i );
   }

   int ii;
   for ( ii = 0 ; ii &lt;= 2 ; ii++ )
   {
      v2.push_back( ii );
   }

   int iii;
   for ( iii = 0 ; iii &lt;= 2 ; iii++ )
   {
      v3.push_back( 2 * iii );
   }

   cout &lt;&lt; &quot;Vector v1 is ( &quot; ;
   for ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ; Iter1++ )
      cout &lt;&lt; *Iter1 &lt;&lt; &quot; &quot;;
   cout &lt;&lt; &quot;).&quot; &lt;&lt; endl;

   cout &lt;&lt; &quot;Vector v2 is ( &quot; ;
   for ( Iter2 = v2.begin( ) ; Iter2 != v2.end( ) ; Iter2++ )
      cout &lt;&lt; *Iter2 &lt;&lt; &quot; &quot;;
   cout &lt;&lt; &quot;).&quot; &lt;&lt; endl;

   cout &lt;&lt; &quot;Vector v3 is ( &quot; ;
   for ( Iter3 = v3.begin( ) ; Iter3 != v3.end( ) ; Iter3++ )
      cout &lt;&lt; *Iter3 &lt;&lt; &quot; &quot;;
   cout &lt;&lt; &quot;).&quot; &lt;&lt; endl;

   v4 = max ( v1, v2 );
   v5 = max ( v1, v3 );

   cout &lt;&lt; &quot;Vector v4 = max (v1,v2) is ( &quot; ;
   for ( Iter4 = v4.begin( ) ; Iter4 != v4.end( ) ; Iter4++ )
      cout &lt;&lt; *Iter4 &lt;&lt; &quot; &quot;;
   cout &lt;&lt; &quot;).&quot; &lt;&lt; endl;

   cout &lt;&lt; &quot;Vector v5 = max (v1,v3) is ( &quot; ;
   for ( Iter5 = v5.begin( ) ; Iter5 != v5.end( ) ; Iter5++ )
      cout &lt;&lt; *Iter5 &lt;&lt; &quot; &quot;;
   cout &lt;&lt; &quot;).&quot; &lt;&lt; endl;
}
"><span class="hljs-comment">// alg_max.cpp</span>
<span class="hljs-comment">// compile with: /EHsc</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;set&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;ostream&gt;</span></span>

<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CInt</span>;</span>
ostream&amp; <span class="hljs-keyword">operator</span>&lt;&lt;( ostream&amp; osIn, <span class="hljs-keyword">const</span> CInt&amp; rhs );

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CInt</span>
{</span>
<span class="hljs-keyword">public</span>:
   CInt( <span class="hljs-keyword">int</span> n = <span class="hljs-number">0</span> ) : m_nVal( n ){}
   CInt( <span class="hljs-keyword">const</span> CInt&amp; rhs ) : m_nVal( rhs.m_nVal ){}
   CInt&amp;   <span class="hljs-keyword">operator</span>=( <span class="hljs-keyword">const</span> CInt&amp; rhs ) {m_nVal =
   rhs.m_nVal; <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;}
   <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>&lt;( <span class="hljs-keyword">const</span> CInt&amp; rhs ) <span class="hljs-keyword">const</span>
      {<span class="hljs-keyword">return</span> ( m_nVal &lt; rhs.m_nVal );}
   <span class="hljs-keyword">friend</span> ostream&amp; <span class="hljs-keyword">operator</span>&lt;&lt;( ostream&amp; osIn, <span class="hljs-keyword">const</span> CInt&amp; rhs );

<span class="hljs-keyword">private</span>:
   <span class="hljs-keyword">int</span> m_nVal;
};

<span class="hljs-keyword">inline</span> ostream&amp; <span class="hljs-keyword">operator</span>&lt;&lt;( ostream&amp; osIn, <span class="hljs-keyword">const</span> CInt&amp; rhs )
{
   osIn &lt;&lt; <span class="hljs-string">"CInt( "</span> &lt;&lt; rhs.m_nVal &lt;&lt; <span class="hljs-string">" )"</span>;
   <span class="hljs-keyword">return</span> osIn;
}

<span class="hljs-comment">// Return whether absolute value of elem1 is greater than</span>
<span class="hljs-comment">// absolute value of elem2</span>
<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">abs_greater</span> <span class="hljs-params">( <span class="hljs-keyword">int</span> elem1, <span class="hljs-keyword">int</span> elem2 )</span>
</span>{
   <span class="hljs-keyword">if</span> ( elem1 &lt; <span class="hljs-number">0</span> )
      elem1 = -elem1;
   <span class="hljs-keyword">if</span> ( elem2 &lt; <span class="hljs-number">0</span> )
      elem2 = -elem2;
   <span class="hljs-keyword">return</span> elem1 &lt; elem2;
};

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
   <span class="hljs-keyword">int</span> a = <span class="hljs-number">6</span>, b = <span class="hljs-number">-7</span>;
   <span class="hljs-comment">// Return the integer with the larger absolute value</span>
   <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span>&amp; result1 = max(a, b, abs_greater);
   <span class="hljs-comment">// Return the larger integer</span>
   <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span>&amp; result2 = max(a, b);

   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Using integers 6 and -7..."</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"The integer with the greater absolute value is: "</span>
        &lt;&lt; result1 &lt;&lt; <span class="hljs-string">"."</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"The integer with the greater value is: "</span>
        &lt;&lt; result2 &lt;&lt; <span class="hljs-string">"."</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">endl</span>;

<span class="hljs-comment">// Comparing the members of an initializer_list</span>
<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span>&amp; result3 = max({ a, b });
<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span>&amp; result4 = max({ a, b }, abs_greater);

<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Comparing the members of an initializer_list..."</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"The member with the greater value is: "</span> &lt;&lt; result3 &lt;&lt; <span class="hljs-built_in">endl</span>;
<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"The integer with the greater absolute value is: "</span> &lt;&lt; result4 &lt;&lt; <span class="hljs-built_in">endl</span>;

   <span class="hljs-comment">// Comparing set containers with elements of type CInt</span>
   <span class="hljs-comment">// using the max algorithm</span>
   CInt c1 = <span class="hljs-number">1</span>, c2 = <span class="hljs-number">2</span>, c3 = <span class="hljs-number">3</span>;
   <span class="hljs-built_in">set</span>&lt;CInt&gt; s1, s2, s3;
   <span class="hljs-built_in">set</span>&lt;CInt&gt;::iterator s1_Iter, s2_Iter, s3_Iter;

   s1.insert ( c1 );
   s1.insert ( c2 );
   s2.insert ( c2 );
   s2.insert ( c3 );

   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"s1 = ("</span>;
   <span class="hljs-keyword">for</span> ( s1_Iter = s1.begin( ); s1_Iter != --s1.end( ); s1_Iter++ )
      <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">" "</span> &lt;&lt; *s1_Iter &lt;&lt; <span class="hljs-string">","</span>;
   s1_Iter = --s1.end( );
   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">" "</span> &lt;&lt; *s1_Iter &lt;&lt; <span class="hljs-string">" )."</span> &lt;&lt; <span class="hljs-built_in">endl</span>;

   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"s2 = ("</span>;
   <span class="hljs-keyword">for</span> ( s2_Iter = s2.begin( ); s2_Iter != --s2.end( ); s2_Iter++ )
      <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">" "</span> &lt;&lt; *s2_Iter &lt;&lt; <span class="hljs-string">","</span>;
   s2_Iter = --s2.end( );
   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">" "</span> &lt;&lt; *s2_Iter &lt;&lt; <span class="hljs-string">" )."</span> &lt;&lt; <span class="hljs-built_in">endl</span>;

   s3 = max ( s1, s2 );
   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"s3 = max ( s1, s2 ) = ("</span>;
   <span class="hljs-keyword">for</span> ( s3_Iter = s3.begin( ); s3_Iter != --s3.end( ); s3_Iter++ )
      <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">" "</span> &lt;&lt; *s3_Iter &lt;&lt; <span class="hljs-string">","</span>;
   s3_Iter = --s3.end( );
   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">" "</span> &lt;&lt; *s3_Iter &lt;&lt; <span class="hljs-string">" )."</span> &lt;&lt; <span class="hljs-built_in">endl</span> &lt;&lt; <span class="hljs-built_in">endl</span>;

   <span class="hljs-comment">// Comparing vectors with integer elements using the max algorithm</span>
   <span class="hljs-built_in">vector</span> &lt;<span class="hljs-keyword">int</span>&gt; v1, v2, v3, v4, v5;
   <span class="hljs-built_in">vector</span> &lt;<span class="hljs-keyword">int</span>&gt;::iterator Iter1, Iter2, Iter3, Iter4, Iter5;

   <span class="hljs-keyword">int</span> i;
   <span class="hljs-keyword">for</span> ( i = <span class="hljs-number">0</span> ; i &lt;= <span class="hljs-number">2</span> ; i++ )
   {
      v1.push_back( i );
   }

   <span class="hljs-keyword">int</span> ii;
   <span class="hljs-keyword">for</span> ( ii = <span class="hljs-number">0</span> ; ii &lt;= <span class="hljs-number">2</span> ; ii++ )
   {
      v2.push_back( ii );
   }

   <span class="hljs-keyword">int</span> iii;
   <span class="hljs-keyword">for</span> ( iii = <span class="hljs-number">0</span> ; iii &lt;= <span class="hljs-number">2</span> ; iii++ )
   {
      v3.push_back( <span class="hljs-number">2</span> * iii );
   }

   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Vector v1 is ( "</span> ;
   <span class="hljs-keyword">for</span> ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ; Iter1++ )
      <span class="hljs-built_in">cout</span> &lt;&lt; *Iter1 &lt;&lt; <span class="hljs-string">" "</span>;
   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">")."</span> &lt;&lt; <span class="hljs-built_in">endl</span>;

   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Vector v2 is ( "</span> ;
   <span class="hljs-keyword">for</span> ( Iter2 = v2.begin( ) ; Iter2 != v2.end( ) ; Iter2++ )
      <span class="hljs-built_in">cout</span> &lt;&lt; *Iter2 &lt;&lt; <span class="hljs-string">" "</span>;
   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">")."</span> &lt;&lt; <span class="hljs-built_in">endl</span>;

   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Vector v3 is ( "</span> ;
   <span class="hljs-keyword">for</span> ( Iter3 = v3.begin( ) ; Iter3 != v3.end( ) ; Iter3++ )
      <span class="hljs-built_in">cout</span> &lt;&lt; *Iter3 &lt;&lt; <span class="hljs-string">" "</span>;
   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">")."</span> &lt;&lt; <span class="hljs-built_in">endl</span>;

   v4 = max ( v1, v2 );
   v5 = max ( v1, v3 );

   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Vector v4 = max (v1,v2) is ( "</span> ;
   <span class="hljs-keyword">for</span> ( Iter4 = v4.begin( ) ; Iter4 != v4.end( ) ; Iter4++ )
      <span class="hljs-built_in">cout</span> &lt;&lt; *Iter4 &lt;&lt; <span class="hljs-string">" "</span>;
   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">")."</span> &lt;&lt; <span class="hljs-built_in">endl</span>;

   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Vector v5 = max (v1,v3) is ( "</span> ;
   <span class="hljs-keyword">for</span> ( Iter5 = v5.begin( ) ; Iter5 != v5.end( ) ; Iter5++ )
      <span class="hljs-built_in">cout</span> &lt;&lt; *Iter5 &lt;&lt; <span class="hljs-string">" "</span>;
   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">")."</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
}
</code></pre>
<div class="codeHeader" id="code-try-72" data-bi-name="code-header"><span class="language">Output</span>
			<button class="action" data-bi-name="copy">
				<span class="docon docon-edit-copy" role="presentation"></span>
				<span>Copy</span>
			</button></div><pre><code class="lang-Output" data-author-content="Using integers 6 and -7...
The integer with the greater absolute value is: -7
The integer with the greater value is: 6.
Comparing the members of an initializer_list...The member with the greater value is: 6The integer wiht the greater absolute value is: -7
s1 = ( CInt( 1 ), CInt( 2 ) ).
s2 = ( CInt( 2 ), CInt( 3 ) ).
s3 = max ( s1, s2 ) = ( CInt( 2 ), CInt( 3 ) ).

Vector v1 is ( 0 1 2 ).
Vector v2 is ( 0 1 2 ).
Vector v3 is ( 0 2 4 ).
Vector v4 = max (v1,v2) is ( 0 1 2 ).
Vector v5 = max (v1,v3) is ( 0 2 4 ).
">Using integers 6 and -7...
The integer with the greater absolute value is: -7
The integer with the greater value is: 6.
Comparing the members of an initializer_list...The member with the greater value is: 6The integer wiht the greater absolute value is: -7
s1 = ( CInt( 1 ), CInt( 2 ) ).
s2 = ( CInt( 2 ), CInt( 3 ) ).
s3 = max ( s1, s2 ) = ( CInt( 2 ), CInt( 3 ) ).

Vector v1 is ( 0 1 2 ).
Vector v2 is ( 0 1 2 ).
Vector v3 is ( 0 2 4 ).
Vector v4 = max (v1,v2) is ( 0 1 2 ).
Vector v5 = max (v1,v3) is ( 0 2 4 ).
</code></pre>
<h2 id="max_element" class="heading-with-anchor">  max_element<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#max_element"></a></h2>
<p>Finds the first occurrence of largest element in a specified range where the ordering criterion may be specified by a binary predicate.</p>
<div class="codeHeader" id="code-try-73" data-bi-name="code-header"><span class="language">C++</span>
			<button class="action" data-bi-name="copy">
				<span class="docon docon-edit-copy" role="presentation"></span>
				<span>Copy</span>
			</button></div><pre><code class="lang-cpp" data-author-content="template&lt;class ForwardIterator&gt;
constexpr ForwardIterator max_element(ForwardIterator first, ForwardIterator last );

template&lt;class ForwardIterator, class BinaryPredicate&gt;
constexpr ForwardIterator max_element(ForwardIterator first, ForwardIterator last, BinaryPredicate comp );
"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ForwardIterator</span>&gt;
<span class="hljs-title">constexpr</span> <span class="hljs-title">ForwardIterator</span> <span class="hljs-title">max_element</span>(<span class="hljs-title">ForwardIterator</span> <span class="hljs-title">first</span>, <span class="hljs-title">ForwardIterator</span> <span class="hljs-title">last</span> );</span>

<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ForwardIterator</span>, <span class="hljs-title">class</span> <span class="hljs-title">BinaryPredicate</span>&gt;
<span class="hljs-title">constexpr</span> <span class="hljs-title">ForwardIterator</span> <span class="hljs-title">max_element</span>(<span class="hljs-title">ForwardIterator</span> <span class="hljs-title">first</span>, <span class="hljs-title">ForwardIterator</span> <span class="hljs-title">last</span>, <span class="hljs-title">BinaryPredicate</span> <span class="hljs-title">comp</span> );</span>
</code></pre>
<h3 id="parameters-35" class="heading-with-anchor">Parameters<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#parameters-35"></a></h3>
<p><em>first</em><br>
A forward iterator addressing the position of the first element in the range to be searched for the largest element.</p>
<p><em>last</em><br>
A forward iterator addressing the position one past the final element in the range to be searched for the largest element.</p>
<p><em>comp</em><br>
User-defined predicate function object that defines the sense in which one element is greater than another. The binary predicate takes two arguments and should return <strong>true</strong> when the first element is less than the second element and <strong>false</strong> otherwise.</p>
<h3 id="return-value-28" class="heading-with-anchor">Return Value<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#return-value-28"></a></h3>
<p>A forward iterator addressing the position of the first occurrence of the largest element in the range searched.</p>
<h3 id="remarks-35" class="heading-with-anchor">Remarks<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#remarks-35"></a></h3>
<p>The range referenced must be valid; all pointers must be dereferenceable and within each sequence the last position is reachable from the first by incrementation.</p>
<p>The complexity is linear: (<code>last</code> - <code>first</code>) - 1 comparisons are required for a nonempty range.</p>
<h3 id="example-24" class="heading-with-anchor">Example<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#example-24"></a></h3>
<div class="codeHeader" id="code-try-74" data-bi-name="code-header"><span class="language">C++</span>
			<button class="action" data-bi-name="copy">
				<span class="docon docon-edit-copy" role="presentation"></span>
				<span>Copy</span>
			</button></div><pre><code class="lang-cpp" data-author-content="// alg_max_element.cpp
// compile with: /EHsc
#include &lt;vector&gt;
#include &lt;set&gt;
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;ostream&gt;

using namespace std;
class CInt;
ostream&amp; operator&lt;&lt;( ostream&amp; osIn, const CInt&amp; rhs );

class CInt
{
public:
   CInt( int n = 0 ) : m_nVal( n ){}
   CInt( const CInt&amp; rhs ) : m_nVal( rhs.m_nVal ){}
   CInt&amp; operator=( const CInt&amp; rhs ) {m_nVal =
   rhs.m_nVal; return *this;}
   bool operator&lt;( const CInt&amp; rhs ) const
      {return ( m_nVal &lt; rhs.m_nVal );}
   friend ostream&amp; operator&lt;&lt;( ostream&amp; osIn, const CInt&amp; rhs );

private:
   int m_nVal;
};

inline ostream&amp; operator&lt;&lt;(ostream&amp; osIn, const CInt&amp; rhs)
{
   osIn &lt;&lt; &quot;CInt( &quot; &lt;&lt; rhs.m_nVal &lt;&lt; &quot; )&quot;;
   return osIn;
}

// Return whether modulus of elem1 is greater than modulus of elem2
bool mod_lesser ( int elem1, int elem2 )
{
   if ( elem1 &lt; 0 )
      elem1 = - elem1;
   if ( elem2 &lt; 0 )
      elem2 = - elem2;
   return elem1 &lt; elem2;
};

int main()
{
   // Searching a set container with elements of type CInt
   // for the maximum element
   CInt c1 = 1, c2 = 2, c3 = -3;
   set&lt;CInt&gt; s1;
   set&lt;CInt&gt;::iterator s1_Iter, s1_R1_Iter, s1_R2_Iter;

   s1.insert ( c1 );
   s1.insert ( c2 );
   s1.insert ( c3 );

   cout &lt;&lt; &quot;s1 = (&quot;;
   for ( s1_Iter = s1.begin( ); s1_Iter != --s1.end( ); s1_Iter++ )
      cout &lt;&lt; &quot; &quot; &lt;&lt; *s1_Iter &lt;&lt; &quot;,&quot;;
   s1_Iter = --s1.end( );
   cout &lt;&lt; &quot; &quot; &lt;&lt; *s1_Iter &lt;&lt; &quot; ).&quot; &lt;&lt; endl;

   s1_R1_Iter = max_element ( s1.begin( ), s1.end( ) );

   cout &lt;&lt; &quot;The largest element in s1 is: &quot; &lt;&lt; *s1_R1_Iter &lt;&lt; endl;
   cout &lt;&lt; endl;

   // Searching a vector with elements of type int for the maximum
   // element under default less than &amp; mod_lesser binary predicates
   vector &lt;int&gt; v1;
   vector &lt;int&gt;::iterator v1_Iter, v1_R1_Iter, v1_R2_Iter;

   int i;
   for ( i = 0 ; i &lt;= 3 ; i++ )
   {
      v1.push_back( i );
   }

   int ii;
   for ( ii = 1 ; ii &lt;= 4 ; ii++ )
   {
      v1.push_back( - 2 * ii );
   }

   cout &lt;&lt; &quot;Vector v1 is ( &quot; ;
   for ( v1_Iter = v1.begin( ) ; v1_Iter != v1.end( ) ; v1_Iter++ )
      cout &lt;&lt; *v1_Iter &lt;&lt; &quot; &quot;;
   cout &lt;&lt; &quot;).&quot; &lt;&lt; endl;

   v1_R1_Iter = max_element ( v1.begin( ), v1.end( ) );
   v1_R2_Iter = max_element ( v1.begin( ), v1.end( ), mod_lesser);

   cout &lt;&lt; &quot;The largest element in v1 is: &quot; &lt;&lt; *v1_R1_Iter &lt;&lt; endl;
   cout &lt;&lt; &quot;The largest element in v1 under the mod_lesser&quot;
        &lt;&lt; &quot;\n binary predicate is: &quot; &lt;&lt; *v1_R2_Iter &lt;&lt; endl;
}
"><span class="hljs-comment">// alg_max_element.cpp</span>
<span class="hljs-comment">// compile with: /EHsc</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;set&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;ostream&gt;</span></span>

<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CInt</span>;</span>
ostream&amp; <span class="hljs-keyword">operator</span>&lt;&lt;( ostream&amp; osIn, <span class="hljs-keyword">const</span> CInt&amp; rhs );

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CInt</span>
{</span>
<span class="hljs-keyword">public</span>:
   CInt( <span class="hljs-keyword">int</span> n = <span class="hljs-number">0</span> ) : m_nVal( n ){}
   CInt( <span class="hljs-keyword">const</span> CInt&amp; rhs ) : m_nVal( rhs.m_nVal ){}
   CInt&amp; <span class="hljs-keyword">operator</span>=( <span class="hljs-keyword">const</span> CInt&amp; rhs ) {m_nVal =
   rhs.m_nVal; <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;}
   <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>&lt;( <span class="hljs-keyword">const</span> CInt&amp; rhs ) <span class="hljs-keyword">const</span>
      {<span class="hljs-keyword">return</span> ( m_nVal &lt; rhs.m_nVal );}
   <span class="hljs-keyword">friend</span> ostream&amp; <span class="hljs-keyword">operator</span>&lt;&lt;( ostream&amp; osIn, <span class="hljs-keyword">const</span> CInt&amp; rhs );

<span class="hljs-keyword">private</span>:
   <span class="hljs-keyword">int</span> m_nVal;
};

<span class="hljs-keyword">inline</span> ostream&amp; <span class="hljs-keyword">operator</span>&lt;&lt;(ostream&amp; osIn, <span class="hljs-keyword">const</span> CInt&amp; rhs)
{
   osIn &lt;&lt; <span class="hljs-string">"CInt( "</span> &lt;&lt; rhs.m_nVal &lt;&lt; <span class="hljs-string">" )"</span>;
   <span class="hljs-keyword">return</span> osIn;
}

<span class="hljs-comment">// Return whether modulus of elem1 is greater than modulus of elem2</span>
<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">mod_lesser</span> <span class="hljs-params">( <span class="hljs-keyword">int</span> elem1, <span class="hljs-keyword">int</span> elem2 )</span>
</span>{
   <span class="hljs-keyword">if</span> ( elem1 &lt; <span class="hljs-number">0</span> )
      elem1 = - elem1;
   <span class="hljs-keyword">if</span> ( elem2 &lt; <span class="hljs-number">0</span> )
      elem2 = - elem2;
   <span class="hljs-keyword">return</span> elem1 &lt; elem2;
};

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
   <span class="hljs-comment">// Searching a set container with elements of type CInt</span>
   <span class="hljs-comment">// for the maximum element</span>
   CInt c1 = <span class="hljs-number">1</span>, c2 = <span class="hljs-number">2</span>, c3 = <span class="hljs-number">-3</span>;
   <span class="hljs-built_in">set</span>&lt;CInt&gt; s1;
   <span class="hljs-built_in">set</span>&lt;CInt&gt;::iterator s1_Iter, s1_R1_Iter, s1_R2_Iter;

   s1.insert ( c1 );
   s1.insert ( c2 );
   s1.insert ( c3 );

   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"s1 = ("</span>;
   <span class="hljs-keyword">for</span> ( s1_Iter = s1.begin( ); s1_Iter != --s1.end( ); s1_Iter++ )
      <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">" "</span> &lt;&lt; *s1_Iter &lt;&lt; <span class="hljs-string">","</span>;
   s1_Iter = --s1.end( );
   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">" "</span> &lt;&lt; *s1_Iter &lt;&lt; <span class="hljs-string">" )."</span> &lt;&lt; <span class="hljs-built_in">endl</span>;

   s1_R1_Iter = max_element ( s1.begin( ), s1.end( ) );

   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"The largest element in s1 is: "</span> &lt;&lt; *s1_R1_Iter &lt;&lt; <span class="hljs-built_in">endl</span>;
   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">endl</span>;

   <span class="hljs-comment">// Searching a vector with elements of type int for the maximum</span>
   <span class="hljs-comment">// element under default less than &amp; mod_lesser binary predicates</span>
   <span class="hljs-built_in">vector</span> &lt;<span class="hljs-keyword">int</span>&gt; v1;
   <span class="hljs-built_in">vector</span> &lt;<span class="hljs-keyword">int</span>&gt;::iterator v1_Iter, v1_R1_Iter, v1_R2_Iter;

   <span class="hljs-keyword">int</span> i;
   <span class="hljs-keyword">for</span> ( i = <span class="hljs-number">0</span> ; i &lt;= <span class="hljs-number">3</span> ; i++ )
   {
      v1.push_back( i );
   }

   <span class="hljs-keyword">int</span> ii;
   <span class="hljs-keyword">for</span> ( ii = <span class="hljs-number">1</span> ; ii &lt;= <span class="hljs-number">4</span> ; ii++ )
   {
      v1.push_back( - <span class="hljs-number">2</span> * ii );
   }

   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Vector v1 is ( "</span> ;
   <span class="hljs-keyword">for</span> ( v1_Iter = v1.begin( ) ; v1_Iter != v1.end( ) ; v1_Iter++ )
      <span class="hljs-built_in">cout</span> &lt;&lt; *v1_Iter &lt;&lt; <span class="hljs-string">" "</span>;
   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">")."</span> &lt;&lt; <span class="hljs-built_in">endl</span>;

   v1_R1_Iter = max_element ( v1.begin( ), v1.end( ) );
   v1_R2_Iter = max_element ( v1.begin( ), v1.end( ), mod_lesser);

   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"The largest element in v1 is: "</span> &lt;&lt; *v1_R1_Iter &lt;&lt; <span class="hljs-built_in">endl</span>;
   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"The largest element in v1 under the mod_lesser"</span>
        &lt;&lt; <span class="hljs-string">"\n binary predicate is: "</span> &lt;&lt; *v1_R2_Iter &lt;&lt; <span class="hljs-built_in">endl</span>;
}
</code></pre>
<h2 id="merge" class="heading-with-anchor">  merge<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#merge"></a></h2>
<p>Combines all of the elements from two sorted source ranges into a single, sorted destination range, where the ordering criterion may be specified by a binary predicate.</p>
<div class="codeHeader" id="code-try-75" data-bi-name="code-header"><span class="language">C++</span>
			<button class="action" data-bi-name="copy">
				<span class="docon docon-edit-copy" role="presentation"></span>
				<span>Copy</span>
			</button></div><pre><code class="lang-cpp" data-author-content="template&lt;class InputIterator1, class InputIterator2, class OutputIterator&gt;
OutputIterator merge(
    InputIterator1 first1,
    InputIterator1 last1,
    InputIterator2 first2,
    InputIterator2 last2,
    OutputIterator result );

template&lt;class InputIterator1, class InputIterator2, class OutputIterator, class BinaryPredicate&gt;
OutputIterator merge(
    InputIterator1 first1,
    InputIterator1 last1,
    InputIterator2 first2,
    InputIterator2 last2,
    OutputIterator result,
    BinaryPredicate comp );
"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InputIterator1</span>, <span class="hljs-title">class</span> <span class="hljs-title">InputIterator2</span>, <span class="hljs-title">class</span> <span class="hljs-title">OutputIterator</span>&gt;
<span class="hljs-title">OutputIterator</span> <span class="hljs-title">merge</span>(
    <span class="hljs-title">InputIterator1</span> <span class="hljs-title">first1</span>,
    <span class="hljs-title">InputIterator1</span> <span class="hljs-title">last1</span>,
    <span class="hljs-title">InputIterator2</span> <span class="hljs-title">first2</span>,
    <span class="hljs-title">InputIterator2</span> <span class="hljs-title">last2</span>,
    <span class="hljs-title">OutputIterator</span> <span class="hljs-title">result</span> );</span>

<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InputIterator1</span>, <span class="hljs-title">class</span> <span class="hljs-title">InputIterator2</span>, <span class="hljs-title">class</span> <span class="hljs-title">OutputIterator</span>, <span class="hljs-title">class</span> <span class="hljs-title">BinaryPredicate</span>&gt;
<span class="hljs-title">OutputIterator</span> <span class="hljs-title">merge</span>(
    <span class="hljs-title">InputIterator1</span> <span class="hljs-title">first1</span>,
    <span class="hljs-title">InputIterator1</span> <span class="hljs-title">last1</span>,
    <span class="hljs-title">InputIterator2</span> <span class="hljs-title">first2</span>,
    <span class="hljs-title">InputIterator2</span> <span class="hljs-title">last2</span>,
    <span class="hljs-title">OutputIterator</span> <span class="hljs-title">result</span>,
    <span class="hljs-title">BinaryPredicate</span> <span class="hljs-title">comp</span> );</span>
</code></pre>
<h3 id="parameters-36" class="heading-with-anchor">Parameters<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#parameters-36"></a></h3>
<p><em>first1</em><br>
An input iterator addressing the position of the first element in the first of two sorted source ranges to be combined and sorted into a single range.</p>
<p><em>last1</em><br>
An input iterator addressing the position one past the last element in the first of two sorted source ranges to be combined and sorted into a single range.</p>
<p><em>first2</em><br>
An input iterator addressing the position of the first element in second of two consecutive sorted source ranges to be combined and sorted into a single range.</p>
<p><em>last2</em><br>
An input iterator addressing the position one past the last element in second of two consecutive sorted source ranges to be combined and sorted into a single range.</p>
<p><em>result</em><br>
An output iterator addressing the position of the first element in the destination range where the two source ranges are to be combined into a single sorted range.</p>
<p><em>comp</em><br>
User-defined predicate function object that defines the sense in which one element is greater than another. The binary predicate takes two arguments and should return <strong>true</strong> when the first element is less than the second element and <strong>false</strong> otherwise.</p>
<h3 id="return-value-29" class="heading-with-anchor">Return Value<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#return-value-29"></a></h3>
<p>An output iterator addressing the position one past the last element in the sorted destination range.</p>
<h3 id="remarks-36" class="heading-with-anchor">Remarks<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#remarks-36"></a></h3>
<p>The sorted source ranges referenced must be valid; all pointers must be dereferenceable and within each sequence the last position must be reachable from the first by incrementation.</p>
<p>The destination range should not overlap either of the source ranges and should be large enough to contain the destination range.</p>
<p>The sorted source ranges must each be arranged as a precondition to the application of the <code>merge</code> algorithm in accordance with the same ordering as is to be used by the algorithm to sort the combined ranges.</p>
<p>The operation is stable as the relative order of elements within each range is preserved in the destination range. The source ranges are not modified by the algorithm <code>merge</code>.</p>
<p>The value types of the input iterators need be less-than comparable to be ordered, so that, given two elements, it may be determined either that they are equivalent (in the sense that neither is less than the other) or that one is less than the other. This results in an ordering between the nonequivalent elements. When there are equivalent elements in both source ranges, the elements in the first range precede the elements from the second source range in the destination range.</p>
<p>The complexity of the algorithm is linear with at most (<em>last1</em> - <em>first1</em>) - (<em>last2</em> - <em>first2</em>) - 1 comparisons.</p>
<p>The <a href="https://docs.microsoft.com/en-us/cpp/standard-library/list-class?view=vs-2019" data-linktype="relative-path">list class</a> provides a member function "merge" to merge the elements of two lists.</p>
<h3 id="example-25" class="heading-with-anchor">Example<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#example-25"></a></h3>
<div class="codeHeader" id="code-try-76" data-bi-name="code-header"><span class="language">C++</span>
			<button class="action" data-bi-name="copy">
				<span class="docon docon-edit-copy" role="presentation"></span>
				<span>Copy</span>
			</button></div><pre><code class="lang-cpp" data-author-content="// alg_merge.cpp
// compile with: /EHsc
#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;functional&gt;   // For greater&lt;int&gt;( )
#include &lt;iostream&gt;

// Return whether modulus of elem1 is less than modulus of elem2
bool mod_lesser ( int elem1, int elem2 ) {
   if (elem1 &lt; 0)
      elem1 = - elem1;
   if (elem2 &lt; 0)
      elem2 = - elem2;
   return elem1 &lt; elem2;
}

int main() {
   using namespace std;
   vector &lt;int&gt; v1a, v1b, v1 ( 12 );
   vector &lt;int&gt;::iterator Iter1a,  Iter1b, Iter1;

   // Constructing vector v1a and v1b with default less than ordering
   int i;
   for ( i = 0 ; i &lt;= 5 ; i++ )
      v1a.push_back(  i );

   int ii;
   for ( ii =-5 ; ii &lt;= 0 ; ii++ )
      v1b.push_back(  ii  );

   cout &lt;&lt; &quot;Original vector v1a with range sorted by the\n &quot;
        &lt;&lt; &quot;binary predicate less than is  v1a = ( &quot; ;
   for ( Iter1a = v1a.begin( ) ; Iter1a != v1a.end( ) ; Iter1a++ )
      cout &lt;&lt; *Iter1a &lt;&lt; &quot; &quot;;
   cout &lt;&lt; &quot;).&quot; &lt;&lt; endl;

   cout &lt;&lt; &quot;Original vector v1b with range sorted by the\n &quot;
        &lt;&lt; &quot;binary predicate less than is  v1b = ( &quot; ;
   for ( Iter1b = v1b.begin( ) ; Iter1b != v1b.end( ) ; Iter1b++ )
      cout &lt;&lt; *Iter1b &lt;&lt; &quot; &quot;;
   cout &lt;&lt; &quot;).&quot; &lt;&lt; endl;

   // Constructing vector v2 with ranges sorted by greater
   vector &lt;int&gt; v2a ( v1a ) , v2b ( v1b ) ,  v2 ( v1 );
   vector &lt;int&gt;::iterator Iter2a,  Iter2b, Iter2;
   sort ( v2a.begin( ), v2a.end( ), greater&lt;int&gt;( ) );
   sort ( v2b.begin( ), v2b.end( ), greater&lt;int&gt;( ) );

   cout &lt;&lt; &quot;Original vector v2a with range sorted by the\n &quot;
        &lt;&lt;  &quot;binary predicate greater is   v2a =  ( &quot; ;
   for ( Iter2a = v2a.begin( ) ; Iter2a != v2a.end( ) ; Iter2a++ )
      cout &lt;&lt; *Iter2a &lt;&lt; &quot; &quot;;
   cout &lt;&lt; &quot;).&quot; &lt;&lt; endl;

   cout &lt;&lt; &quot;Original vector v2b with range sorted by the\n &quot;
        &lt;&lt;  &quot;binary predicate greater is   v2b =  ( &quot; ;
   for ( Iter2b = v2b.begin( ) ; Iter2b != v2b.end( ) ; Iter2b++ )
      cout &lt;&lt; *Iter2b &lt;&lt; &quot; &quot;;
   cout &lt;&lt; &quot;).&quot; &lt;&lt; endl;

   // Constructing vector v3 with ranges sorted by mod_lesser
   vector &lt;int&gt; v3a ( v1a ), v3b ( v1b ) ,  v3 ( v1 );
   vector &lt;int&gt;::iterator Iter3a,  Iter3b, Iter3;
   sort ( v3a.begin( ), v3a.end( ), mod_lesser );
   sort ( v3b.begin( ), v3b.end( ), mod_lesser );

   cout &lt;&lt; &quot;Original vector v3a with range sorted by the\n &quot;
        &lt;&lt; &quot;binary predicate mod_lesser is   v3a =  ( &quot; ;
   for ( Iter3a = v3a.begin( ) ; Iter3a != v3a.end( ) ; Iter3a++ )
      cout &lt;&lt; *Iter3a &lt;&lt; &quot; &quot;;
   cout &lt;&lt; &quot;).&quot; &lt;&lt; endl;

   cout &lt;&lt; &quot;Original vector v3b with range sorted by the\n &quot;
        &lt;&lt; &quot;binary predicate mod_lesser is   v3b =  ( &quot; ;
   for ( Iter3b = v3b.begin( ) ; Iter3b != v3b.end( ) ; Iter3b++ )
      cout &lt;&lt; *Iter3b &lt;&lt; &quot; &quot;;
   cout &lt;&lt; &quot;).&quot; &lt;&lt; endl;

   // To merge inplace in ascending order with default binary
   // predicate less &lt;int&gt;( )
   merge ( v1a.begin( ), v1a.end( ), v1b.begin( ), v1b.end( ), v1.begin( ) );
   cout &lt;&lt; &quot;Merged inplace with default order,\n vector v1mod =  ( &quot; ;
   for ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ; Iter1++ )
      cout &lt;&lt; *Iter1 &lt;&lt; &quot; &quot;;
   cout &lt;&lt; &quot;).&quot; &lt;&lt; endl;

   // To merge inplace in descending order, specify binary
   // predicate greater&lt;int&gt;( )
   merge ( v2a.begin( ), v2a.end( ), v2b.begin( ), v2b.end( ),
       v2.begin( ),  greater &lt;int&gt;( ) );
   cout &lt;&lt; &quot;Merged inplace with binary predicate greater specified,\n &quot;
        &lt;&lt; &quot;vector v2mod  = ( &quot; ;
   for ( Iter2 = v2.begin( ) ; Iter2 != v2.end( ) ; Iter2++ )
      cout &lt;&lt; *Iter2 &lt;&lt; &quot; &quot;;
   cout &lt;&lt; &quot;).&quot; &lt;&lt; endl;

   // Applying A user-defined (UD) binary predicate mod_lesser
   merge ( v3a.begin( ), v3a.end( ), v3b.begin( ), v3b.end( ),
       v3.begin( ),  mod_lesser );
   cout &lt;&lt; &quot;Merged inplace with binary predicate mod_lesser specified,\n &quot;
        &lt;&lt; &quot;vector v3mod  = ( &quot; ; ;
   for ( Iter3 = v3.begin( ) ; Iter3 != v3.end( ) ; Iter3++ )
      cout &lt;&lt; *Iter3 &lt;&lt; &quot; &quot;;
   cout &lt;&lt; &quot;).&quot; &lt;&lt; endl;
}
"><span class="hljs-comment">// alg_merge.cpp</span>
<span class="hljs-comment">// compile with: /EHsc</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;functional&gt;   // For greater&lt;int&gt;( )</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span>

<span class="hljs-comment">// Return whether modulus of elem1 is less than modulus of elem2</span>
<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">mod_lesser</span> <span class="hljs-params">( <span class="hljs-keyword">int</span> elem1, <span class="hljs-keyword">int</span> elem2 )</span> </span>{
   <span class="hljs-keyword">if</span> (elem1 &lt; <span class="hljs-number">0</span>)
      elem1 = - elem1;
   <span class="hljs-keyword">if</span> (elem2 &lt; <span class="hljs-number">0</span>)
      elem2 = - elem2;
   <span class="hljs-keyword">return</span> elem1 &lt; elem2;
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
   <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;
   <span class="hljs-built_in">vector</span> &lt;<span class="hljs-keyword">int</span>&gt; v1a, v1b, v1 ( <span class="hljs-number">12</span> );
   <span class="hljs-built_in">vector</span> &lt;<span class="hljs-keyword">int</span>&gt;::iterator Iter1a,  Iter1b, Iter1;

   <span class="hljs-comment">// Constructing vector v1a and v1b with default less than ordering</span>
   <span class="hljs-keyword">int</span> i;
   <span class="hljs-keyword">for</span> ( i = <span class="hljs-number">0</span> ; i &lt;= <span class="hljs-number">5</span> ; i++ )
      v1a.push_back(  i );

   <span class="hljs-keyword">int</span> ii;
   <span class="hljs-keyword">for</span> ( ii =<span class="hljs-number">-5</span> ; ii &lt;= <span class="hljs-number">0</span> ; ii++ )
      v1b.push_back(  ii  );

   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Original vector v1a with range sorted by the\n "</span>
        &lt;&lt; <span class="hljs-string">"binary predicate less than is  v1a = ( "</span> ;
   <span class="hljs-keyword">for</span> ( Iter1a = v1a.begin( ) ; Iter1a != v1a.end( ) ; Iter1a++ )
      <span class="hljs-built_in">cout</span> &lt;&lt; *Iter1a &lt;&lt; <span class="hljs-string">" "</span>;
   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">")."</span> &lt;&lt; <span class="hljs-built_in">endl</span>;

   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Original vector v1b with range sorted by the\n "</span>
        &lt;&lt; <span class="hljs-string">"binary predicate less than is  v1b = ( "</span> ;
   <span class="hljs-keyword">for</span> ( Iter1b = v1b.begin( ) ; Iter1b != v1b.end( ) ; Iter1b++ )
      <span class="hljs-built_in">cout</span> &lt;&lt; *Iter1b &lt;&lt; <span class="hljs-string">" "</span>;
   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">")."</span> &lt;&lt; <span class="hljs-built_in">endl</span>;

   <span class="hljs-comment">// Constructing vector v2 with ranges sorted by greater</span>
   <span class="hljs-built_in">vector</span> &lt;<span class="hljs-keyword">int</span>&gt; v2a ( v1a ) , v2b ( v1b ) ,  v2 ( v1 );
   <span class="hljs-built_in">vector</span> &lt;<span class="hljs-keyword">int</span>&gt;::iterator Iter2a,  Iter2b, Iter2;
   sort ( v2a.begin( ), v2a.end( ), greater&lt;<span class="hljs-keyword">int</span>&gt;( ) );
   sort ( v2b.begin( ), v2b.end( ), greater&lt;<span class="hljs-keyword">int</span>&gt;( ) );

   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Original vector v2a with range sorted by the\n "</span>
        &lt;&lt;  <span class="hljs-string">"binary predicate greater is   v2a =  ( "</span> ;
   <span class="hljs-keyword">for</span> ( Iter2a = v2a.begin( ) ; Iter2a != v2a.end( ) ; Iter2a++ )
      <span class="hljs-built_in">cout</span> &lt;&lt; *Iter2a &lt;&lt; <span class="hljs-string">" "</span>;
   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">")."</span> &lt;&lt; <span class="hljs-built_in">endl</span>;

   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Original vector v2b with range sorted by the\n "</span>
        &lt;&lt;  <span class="hljs-string">"binary predicate greater is   v2b =  ( "</span> ;
   <span class="hljs-keyword">for</span> ( Iter2b = v2b.begin( ) ; Iter2b != v2b.end( ) ; Iter2b++ )
      <span class="hljs-built_in">cout</span> &lt;&lt; *Iter2b &lt;&lt; <span class="hljs-string">" "</span>;
   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">")."</span> &lt;&lt; <span class="hljs-built_in">endl</span>;

   <span class="hljs-comment">// Constructing vector v3 with ranges sorted by mod_lesser</span>
   <span class="hljs-built_in">vector</span> &lt;<span class="hljs-keyword">int</span>&gt; v3a ( v1a ), v3b ( v1b ) ,  v3 ( v1 );
   <span class="hljs-built_in">vector</span> &lt;<span class="hljs-keyword">int</span>&gt;::iterator Iter3a,  Iter3b, Iter3;
   sort ( v3a.begin( ), v3a.end( ), mod_lesser );
   sort ( v3b.begin( ), v3b.end( ), mod_lesser );

   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Original vector v3a with range sorted by the\n "</span>
        &lt;&lt; <span class="hljs-string">"binary predicate mod_lesser is   v3a =  ( "</span> ;
   <span class="hljs-keyword">for</span> ( Iter3a = v3a.begin( ) ; Iter3a != v3a.end( ) ; Iter3a++ )
      <span class="hljs-built_in">cout</span> &lt;&lt; *Iter3a &lt;&lt; <span class="hljs-string">" "</span>;
   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">")."</span> &lt;&lt; <span class="hljs-built_in">endl</span>;

   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Original vector v3b with range sorted by the\n "</span>
        &lt;&lt; <span class="hljs-string">"binary predicate mod_lesser is   v3b =  ( "</span> ;
   <span class="hljs-keyword">for</span> ( Iter3b = v3b.begin( ) ; Iter3b != v3b.end( ) ; Iter3b++ )
      <span class="hljs-built_in">cout</span> &lt;&lt; *Iter3b &lt;&lt; <span class="hljs-string">" "</span>;
   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">")."</span> &lt;&lt; <span class="hljs-built_in">endl</span>;

   <span class="hljs-comment">// To merge inplace in ascending order with default binary</span>
   <span class="hljs-comment">// predicate less &lt;int&gt;( )</span>
   merge ( v1a.begin( ), v1a.end( ), v1b.begin( ), v1b.end( ), v1.begin( ) );
   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Merged inplace with default order,\n vector v1mod =  ( "</span> ;
   <span class="hljs-keyword">for</span> ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ; Iter1++ )
      <span class="hljs-built_in">cout</span> &lt;&lt; *Iter1 &lt;&lt; <span class="hljs-string">" "</span>;
   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">")."</span> &lt;&lt; <span class="hljs-built_in">endl</span>;

   <span class="hljs-comment">// To merge inplace in descending order, specify binary</span>
   <span class="hljs-comment">// predicate greater&lt;int&gt;( )</span>
   merge ( v2a.begin( ), v2a.end( ), v2b.begin( ), v2b.end( ),
       v2.begin( ),  greater &lt;<span class="hljs-keyword">int</span>&gt;( ) );
   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Merged inplace with binary predicate greater specified,\n "</span>
        &lt;&lt; <span class="hljs-string">"vector v2mod  = ( "</span> ;
   <span class="hljs-keyword">for</span> ( Iter2 = v2.begin( ) ; Iter2 != v2.end( ) ; Iter2++ )
      <span class="hljs-built_in">cout</span> &lt;&lt; *Iter2 &lt;&lt; <span class="hljs-string">" "</span>;
   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">")."</span> &lt;&lt; <span class="hljs-built_in">endl</span>;

   <span class="hljs-comment">// Applying A user-defined (UD) binary predicate mod_lesser</span>
   merge ( v3a.begin( ), v3a.end( ), v3b.begin( ), v3b.end( ),
       v3.begin( ),  mod_lesser );
   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Merged inplace with binary predicate mod_lesser specified,\n "</span>
        &lt;&lt; <span class="hljs-string">"vector v3mod  = ( "</span> ; ;
   <span class="hljs-keyword">for</span> ( Iter3 = v3.begin( ) ; Iter3 != v3.end( ) ; Iter3++ )
      <span class="hljs-built_in">cout</span> &lt;&lt; *Iter3 &lt;&lt; <span class="hljs-string">" "</span>;
   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">")."</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
}
</code></pre>
<h2 id="min" class="heading-with-anchor">  min<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#min"></a></h2>
<p>Compares two objects and returns the lesser of the two, where the ordering criterion may be specified by a binary predicate.</p>
<div class="codeHeader" id="code-try-77" data-bi-name="code-header"><span class="language">C++</span>
			<button class="action" data-bi-name="copy">
				<span class="docon docon-edit-copy" role="presentation"></span>
				<span>Copy</span>
			</button></div><pre><code class="lang-cpp" data-author-content="template&lt;class Type&gt;
constexpr const Type&amp; min(
    const Type&amp; left,
    const Type&amp; right);
template&lt;class Type, class Pr&gt;
constexpr const Type&amp; min(
    const Type&amp; left,
    const Type&amp; right,
    BinaryPredicate comp);
template&lt;class Type&gt;
constexpr Type min(
    initializer_list&lt;Type&gt; );
template&lt;class Type, class Pr&gt;
constexpr Type min(
    initializer_list&lt;Type&gt;,
    BinaryPredicate comp);
"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Type</span>&gt;
<span class="hljs-title">constexpr</span> <span class="hljs-title">const</span> <span class="hljs-title">Type</span>&amp; <span class="hljs-title">min</span>(
    <span class="hljs-title">const</span> <span class="hljs-title">Type</span>&amp; <span class="hljs-title">left</span>,
    <span class="hljs-title">const</span> <span class="hljs-title">Type</span>&amp; <span class="hljs-title">right</span>);</span>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Type</span>, <span class="hljs-title">class</span> <span class="hljs-title">Pr</span>&gt;
<span class="hljs-title">constexpr</span> <span class="hljs-title">const</span> <span class="hljs-title">Type</span>&amp; <span class="hljs-title">min</span>(
    <span class="hljs-title">const</span> <span class="hljs-title">Type</span>&amp; <span class="hljs-title">left</span>,
    <span class="hljs-title">const</span> <span class="hljs-title">Type</span>&amp; <span class="hljs-title">right</span>,
    <span class="hljs-title">BinaryPredicate</span> <span class="hljs-title">comp</span>);</span>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Type</span>&gt;
<span class="hljs-title">constexpr</span> <span class="hljs-title">Type</span> <span class="hljs-title">min</span>(
    <span class="hljs-title">initializer_list</span>&lt;Type&gt; );</span>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Type</span>, <span class="hljs-title">class</span> <span class="hljs-title">Pr</span>&gt;
<span class="hljs-title">constexpr</span> <span class="hljs-title">Type</span> <span class="hljs-title">min</span>(
    <span class="hljs-title">initializer_list</span>&lt;Type&gt;,
    <span class="hljs-title">BinaryPredicate</span> <span class="hljs-title">comp</span>);</span>
</code></pre>
<h3 id="parameters-37" class="heading-with-anchor">Parameters<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#parameters-37"></a></h3>
<p><em>left</em><br>
The first of the two objects being compared.</p>
<p><em>right</em><br>
The second of the two objects being compared.</p>
<p><em>comp</em><br>
A binary predicate used to compare the two objects.</p>
<p><em>_IList</em><br>
The initializer_list that contains the members to be compared.</p>
<h3 id="return-value-30" class="heading-with-anchor">Return Value<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#return-value-30"></a></h3>
<p>The lesser of the two objects, unless neither is lesser; in that case, it returns the first of the two objects. In the case of an initializer_list, it returns the least of the objects in the list.</p>
<h3 id="remarks-37" class="heading-with-anchor">Remarks<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#remarks-37"></a></h3>
<p>The <code>min</code> algorithm is unusual in having objects passed as parameters. Most C++ Standard Library algorithms operate on a range of elements whose position is specified by iterators passed as parameters. If you need a function that uses a range of elements, use <a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#min_element" data-linktype="relative-path">min_element</a>. <a href="https://docs.microsoft.com/en-us/cpp/cpp/constexpr-cpp?view=vs-2019" data-linktype="relative-path">constexpr</a> was enabled on the <code>initializer_list</code> overloads in Visual Studio 2017.</p>
<h3 id="example-26" class="heading-with-anchor">Example<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#example-26"></a></h3>
<div class="codeHeader" id="code-try-78" data-bi-name="code-header"><span class="language">C++</span>
			<button class="action" data-bi-name="copy">
				<span class="docon docon-edit-copy" role="presentation"></span>
				<span>Copy</span>
			</button></div><pre><code class="lang-cpp" data-author-content="// alg_min.cpp
// compile with: /EHsc
#include &lt;vector&gt;
#include &lt;set&gt;
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;ostream&gt;

using namespace std;
class CInt;
ostream&amp; operator&lt;&lt;( ostream&amp; osIn, const CInt&amp; rhs );

class CInt
{
public:
    CInt( int n = 0 ) : m_nVal( n ){}
    CInt( const CInt&amp; rhs ) : m_nVal( rhs.m_nVal ){}
    CInt&amp; operator=( const CInt&amp; rhs ) {m_nVal =
    rhs.m_nVal; return *this;}
    bool operator&lt;( const CInt&amp; rhs ) const
        {return ( m_nVal &lt; rhs.m_nVal );}
    friend ostream&amp; operator&lt;&lt;(ostream&amp; osIn, const CInt&amp; rhs);

private:
    int m_nVal;
};

inline ostream&amp; operator&lt;&lt;( ostream&amp; osIn, const CInt&amp; rhs )
{
    osIn &lt;&lt; &quot;CInt( &quot; &lt;&lt; rhs.m_nVal &lt;&lt; &quot; )&quot;;
       return osIn;
}

// Return whether modulus of elem1 is less than modulus of elem2
bool mod_lesser ( int elem1, int elem2 )
{
    if ( elem1 &lt; 0 )
        elem1 = - elem1;
    if ( elem2 &lt; 0 )
        elem2 = - elem2;
    return elem1 &lt; elem2;
};

int main()
{
    // Comparing integers directly using the min algorithm with
    // binary predicate mod_lesser &amp; with default less than
    int a = 6, b = -7, c = 7 ;
    const int&amp; result1 = min ( a, b, mod_lesser );
    const int&amp; result2 = min ( b, c );

    cout &lt;&lt; &quot;The mod_lesser of the integers 6 &amp; -7 is: &quot;
        &lt;&lt; result1 &lt;&lt; &quot;.&quot; &lt;&lt; endl;
    cout &lt;&lt; &quot;The lesser of the integers -7 &amp; 7 is: &quot;
        &lt;&lt; result2 &lt;&lt; &quot;.&quot; &lt;&lt; endl;
    cout &lt;&lt; endl;

// Comparing the members of an initializer_list
    const int&amp; result3 = min({ a, c });
    const int&amp; result4 = min({ a, b }, mod_lesser);

    cout &lt;&lt; &quot;The lesser of the integers 6 &amp; 7 is: &quot;
        &lt;&lt; result3 &lt;&lt; &quot;.&quot; &lt;&lt; endl;
    cout &lt;&lt; &quot;The mod_lesser of the integers 6 &amp; -7 is: &quot;
        &lt;&lt; result4 &lt;&lt; &quot;.&quot; &lt;&lt; endl;
    cout &lt;&lt; endl;

    // Comparing set containers with elements of type CInt
       // using the min algorithm
    CInt c1 = 1, c2 = 2, c3 = 3;
    set&lt;CInt&gt; s1, s2, s3;
    set&lt;CInt&gt;::iterator s1_Iter, s2_Iter, s3_Iter;

    s1.insert ( c1 );
    s1.insert ( c2 );
    s2.insert ( c2 );
    s2.insert ( c3 );

    cout &lt;&lt; &quot;s1 = (&quot;;
    for ( s1_Iter = s1.begin( ); s1_Iter != --s1.end( ); s1_Iter++ )
        cout &lt;&lt; &quot; &quot; &lt;&lt; *s1_Iter &lt;&lt; &quot;,&quot;;
    s1_Iter = --s1.end( );
        cout &lt;&lt; &quot; &quot; &lt;&lt; *s1_Iter &lt;&lt; &quot; ).&quot; &lt;&lt; endl;

    cout &lt;&lt; &quot;s2 = (&quot;;
    for ( s2_Iter = s2.begin( ); s2_Iter != --s2.end( ); s2_Iter++ )
        cout &lt;&lt; &quot; &quot; &lt;&lt; *s2_Iter &lt;&lt; &quot;,&quot;;
    s2_Iter = --s2.end( );
    cout &lt;&lt; &quot; &quot; &lt;&lt; *s2_Iter &lt;&lt; &quot; ).&quot; &lt;&lt; endl;

    s3 = min ( s1, s2 );
    cout &lt;&lt; &quot;s3 = min ( s1, s2 ) = (&quot;;
    for ( s3_Iter = s3.begin( ); s3_Iter != --s3.end( ); s3_Iter++ )
        cout &lt;&lt; &quot; &quot; &lt;&lt; *s3_Iter &lt;&lt; &quot;,&quot;;
    s3_Iter = --s3.end( );
    cout &lt;&lt; &quot; &quot; &lt;&lt; *s3_Iter &lt;&lt; &quot; ).&quot; &lt;&lt; endl &lt;&lt; endl;

    // Comparing vectors with integer elements using min algorithm
    vector &lt;int&gt; v1, v2, v3, v4, v5;
    vector &lt;int&gt;::iterator Iter1, Iter2, Iter3, Iter4, Iter5;

    int i;
    for ( i = 0 ; i &lt;= 2 ; i++ )
    {
        v1.push_back( i );
    }

    int ii;
    for ( ii = 0 ; ii &lt;= 2 ; ii++ )
    {
        v2.push_back( ii );
    }

    int iii;
    for ( iii = 0 ; iii &lt;= 2 ; iii++ )
    {
        v3.push_back( 2 * iii );
    }

    cout &lt;&lt; &quot;Vector v1 is ( &quot; ;
    for ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ; Iter1++ )
        cout &lt;&lt; *Iter1 &lt;&lt; &quot; &quot;;
    cout &lt;&lt; &quot;).&quot; &lt;&lt; endl;

    cout &lt;&lt; &quot;Vector v2 is ( &quot; ;
    for ( Iter2 = v2.begin( ) ; Iter2 != v2.end( ) ; Iter2++ )
        cout &lt;&lt; *Iter2 &lt;&lt; &quot; &quot;;
    cout &lt;&lt; &quot;).&quot; &lt;&lt; endl;

    cout &lt;&lt; &quot;Vector v3 is ( &quot; ;
    for ( Iter3 = v3.begin( ) ; Iter3 != v3.end( ) ; Iter3++ )
        cout &lt;&lt; *Iter3 &lt;&lt; &quot; &quot;;
    cout &lt;&lt; &quot;).&quot; &lt;&lt; endl;

    v4 = min ( v1, v2 );
    v5 = min ( v1, v3 );

    cout &lt;&lt; &quot;Vector v4 = min ( v1,v2 ) is ( &quot; ;
    for ( Iter4 = v4.begin( ) ; Iter4 != v4.end( ) ; Iter4++ )
        cout &lt;&lt; *Iter4 &lt;&lt; &quot; &quot;;
    cout &lt;&lt; &quot;).&quot; &lt;&lt; endl;

    cout &lt;&lt; &quot;Vector v5 = min ( v1,v3 ) is ( &quot; ;
    for ( Iter5 = v5.begin( ) ; Iter5 != v5.end( ) ; Iter5++ )
        cout &lt;&lt; *Iter5 &lt;&lt; &quot; &quot;;
    cout &lt;&lt; &quot;).&quot; &lt;&lt; endl;
}
"><span class="hljs-comment">// alg_min.cpp</span>
<span class="hljs-comment">// compile with: /EHsc</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;set&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;ostream&gt;</span></span>

<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CInt</span>;</span>
ostream&amp; <span class="hljs-keyword">operator</span>&lt;&lt;( ostream&amp; osIn, <span class="hljs-keyword">const</span> CInt&amp; rhs );

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CInt</span>
{</span>
<span class="hljs-keyword">public</span>:
    CInt( <span class="hljs-keyword">int</span> n = <span class="hljs-number">0</span> ) : m_nVal( n ){}
    CInt( <span class="hljs-keyword">const</span> CInt&amp; rhs ) : m_nVal( rhs.m_nVal ){}
    CInt&amp; <span class="hljs-keyword">operator</span>=( <span class="hljs-keyword">const</span> CInt&amp; rhs ) {m_nVal =
    rhs.m_nVal; <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;}
    <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>&lt;( <span class="hljs-keyword">const</span> CInt&amp; rhs ) <span class="hljs-keyword">const</span>
        {<span class="hljs-keyword">return</span> ( m_nVal &lt; rhs.m_nVal );}
    <span class="hljs-keyword">friend</span> ostream&amp; <span class="hljs-keyword">operator</span>&lt;&lt;(ostream&amp; osIn, <span class="hljs-keyword">const</span> CInt&amp; rhs);

<span class="hljs-keyword">private</span>:
    <span class="hljs-keyword">int</span> m_nVal;
};

<span class="hljs-keyword">inline</span> ostream&amp; <span class="hljs-keyword">operator</span>&lt;&lt;( ostream&amp; osIn, <span class="hljs-keyword">const</span> CInt&amp; rhs )
{
    osIn &lt;&lt; <span class="hljs-string">"CInt( "</span> &lt;&lt; rhs.m_nVal &lt;&lt; <span class="hljs-string">" )"</span>;
       <span class="hljs-keyword">return</span> osIn;
}

<span class="hljs-comment">// Return whether modulus of elem1 is less than modulus of elem2</span>
<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">mod_lesser</span> <span class="hljs-params">( <span class="hljs-keyword">int</span> elem1, <span class="hljs-keyword">int</span> elem2 )</span>
</span>{
    <span class="hljs-keyword">if</span> ( elem1 &lt; <span class="hljs-number">0</span> )
        elem1 = - elem1;
    <span class="hljs-keyword">if</span> ( elem2 &lt; <span class="hljs-number">0</span> )
        elem2 = - elem2;
    <span class="hljs-keyword">return</span> elem1 &lt; elem2;
};

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-comment">// Comparing integers directly using the min algorithm with</span>
    <span class="hljs-comment">// binary predicate mod_lesser &amp; with default less than</span>
    <span class="hljs-keyword">int</span> a = <span class="hljs-number">6</span>, b = <span class="hljs-number">-7</span>, c = <span class="hljs-number">7</span> ;
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span>&amp; result1 = min ( a, b, mod_lesser );
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span>&amp; result2 = min ( b, c );

    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"The mod_lesser of the integers 6 &amp; -7 is: "</span>
        &lt;&lt; result1 &lt;&lt; <span class="hljs-string">"."</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"The lesser of the integers -7 &amp; 7 is: "</span>
        &lt;&lt; result2 &lt;&lt; <span class="hljs-string">"."</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">endl</span>;

<span class="hljs-comment">// Comparing the members of an initializer_list</span>
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span>&amp; result3 = min({ a, c });
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span>&amp; result4 = min({ a, b }, mod_lesser);

    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"The lesser of the integers 6 &amp; 7 is: "</span>
        &lt;&lt; result3 &lt;&lt; <span class="hljs-string">"."</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"The mod_lesser of the integers 6 &amp; -7 is: "</span>
        &lt;&lt; result4 &lt;&lt; <span class="hljs-string">"."</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">endl</span>;

    <span class="hljs-comment">// Comparing set containers with elements of type CInt</span>
       <span class="hljs-comment">// using the min algorithm</span>
    CInt c1 = <span class="hljs-number">1</span>, c2 = <span class="hljs-number">2</span>, c3 = <span class="hljs-number">3</span>;
    <span class="hljs-built_in">set</span>&lt;CInt&gt; s1, s2, s3;
    <span class="hljs-built_in">set</span>&lt;CInt&gt;::iterator s1_Iter, s2_Iter, s3_Iter;

    s1.insert ( c1 );
    s1.insert ( c2 );
    s2.insert ( c2 );
    s2.insert ( c3 );

    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"s1 = ("</span>;
    <span class="hljs-keyword">for</span> ( s1_Iter = s1.begin( ); s1_Iter != --s1.end( ); s1_Iter++ )
        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">" "</span> &lt;&lt; *s1_Iter &lt;&lt; <span class="hljs-string">","</span>;
    s1_Iter = --s1.end( );
        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">" "</span> &lt;&lt; *s1_Iter &lt;&lt; <span class="hljs-string">" )."</span> &lt;&lt; <span class="hljs-built_in">endl</span>;

    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"s2 = ("</span>;
    <span class="hljs-keyword">for</span> ( s2_Iter = s2.begin( ); s2_Iter != --s2.end( ); s2_Iter++ )
        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">" "</span> &lt;&lt; *s2_Iter &lt;&lt; <span class="hljs-string">","</span>;
    s2_Iter = --s2.end( );
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">" "</span> &lt;&lt; *s2_Iter &lt;&lt; <span class="hljs-string">" )."</span> &lt;&lt; <span class="hljs-built_in">endl</span>;

    s3 = min ( s1, s2 );
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"s3 = min ( s1, s2 ) = ("</span>;
    <span class="hljs-keyword">for</span> ( s3_Iter = s3.begin( ); s3_Iter != --s3.end( ); s3_Iter++ )
        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">" "</span> &lt;&lt; *s3_Iter &lt;&lt; <span class="hljs-string">","</span>;
    s3_Iter = --s3.end( );
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">" "</span> &lt;&lt; *s3_Iter &lt;&lt; <span class="hljs-string">" )."</span> &lt;&lt; <span class="hljs-built_in">endl</span> &lt;&lt; <span class="hljs-built_in">endl</span>;

    <span class="hljs-comment">// Comparing vectors with integer elements using min algorithm</span>
    <span class="hljs-built_in">vector</span> &lt;<span class="hljs-keyword">int</span>&gt; v1, v2, v3, v4, v5;
    <span class="hljs-built_in">vector</span> &lt;<span class="hljs-keyword">int</span>&gt;::iterator Iter1, Iter2, Iter3, Iter4, Iter5;

    <span class="hljs-keyword">int</span> i;
    <span class="hljs-keyword">for</span> ( i = <span class="hljs-number">0</span> ; i &lt;= <span class="hljs-number">2</span> ; i++ )
    {
        v1.push_back( i );
    }

    <span class="hljs-keyword">int</span> ii;
    <span class="hljs-keyword">for</span> ( ii = <span class="hljs-number">0</span> ; ii &lt;= <span class="hljs-number">2</span> ; ii++ )
    {
        v2.push_back( ii );
    }

    <span class="hljs-keyword">int</span> iii;
    <span class="hljs-keyword">for</span> ( iii = <span class="hljs-number">0</span> ; iii &lt;= <span class="hljs-number">2</span> ; iii++ )
    {
        v3.push_back( <span class="hljs-number">2</span> * iii );
    }

    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Vector v1 is ( "</span> ;
    <span class="hljs-keyword">for</span> ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ; Iter1++ )
        <span class="hljs-built_in">cout</span> &lt;&lt; *Iter1 &lt;&lt; <span class="hljs-string">" "</span>;
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">")."</span> &lt;&lt; <span class="hljs-built_in">endl</span>;

    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Vector v2 is ( "</span> ;
    <span class="hljs-keyword">for</span> ( Iter2 = v2.begin( ) ; Iter2 != v2.end( ) ; Iter2++ )
        <span class="hljs-built_in">cout</span> &lt;&lt; *Iter2 &lt;&lt; <span class="hljs-string">" "</span>;
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">")."</span> &lt;&lt; <span class="hljs-built_in">endl</span>;

    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Vector v3 is ( "</span> ;
    <span class="hljs-keyword">for</span> ( Iter3 = v3.begin( ) ; Iter3 != v3.end( ) ; Iter3++ )
        <span class="hljs-built_in">cout</span> &lt;&lt; *Iter3 &lt;&lt; <span class="hljs-string">" "</span>;
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">")."</span> &lt;&lt; <span class="hljs-built_in">endl</span>;

    v4 = min ( v1, v2 );
    v5 = min ( v1, v3 );

    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Vector v4 = min ( v1,v2 ) is ( "</span> ;
    <span class="hljs-keyword">for</span> ( Iter4 = v4.begin( ) ; Iter4 != v4.end( ) ; Iter4++ )
        <span class="hljs-built_in">cout</span> &lt;&lt; *Iter4 &lt;&lt; <span class="hljs-string">" "</span>;
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">")."</span> &lt;&lt; <span class="hljs-built_in">endl</span>;

    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Vector v5 = min ( v1,v3 ) is ( "</span> ;
    <span class="hljs-keyword">for</span> ( Iter5 = v5.begin( ) ; Iter5 != v5.end( ) ; Iter5++ )
        <span class="hljs-built_in">cout</span> &lt;&lt; *Iter5 &lt;&lt; <span class="hljs-string">" "</span>;
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">")."</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
}
</code></pre>
<div class="codeHeader" id="code-try-79" data-bi-name="code-header"><span class="language">Output</span>
			<button class="action" data-bi-name="copy">
				<span class="docon docon-edit-copy" role="presentation"></span>
				<span>Copy</span>
			</button></div><pre><code class="lang-Output" data-author-content="The mod_lesser of the integers 6 &amp; -7 is: 6.
The lesser of the integers -7 &amp; 7 is: -7.
The lesser of the integers 6 &amp; 7 is: 6.The mod_lesser of the integers 6 &amp; -7 is: 6.
s1 = ( CInt( 1 ), CInt( 2 ) ).
s2 = ( CInt( 2 ), CInt( 3 ) ).
s3 = min ( s1, s2 ) = ( CInt( 1 ), CInt( 2 ) ).

Vector v1 is ( 0 1 2 ).
Vector v2 is ( 0 1 2 ).
Vector v3 is ( 0 2 4 ).
Vector v4 = min ( v1,v2 ) is ( 0 1 2 ).
Vector v5 = min ( v1,v3 ) is ( 0 1 2 ).
">The mod_lesser of the integers 6 &amp; -7 is: 6.
The lesser of the integers -7 &amp; 7 is: -7.
The lesser of the integers 6 &amp; 7 is: 6.The mod_lesser of the integers 6 &amp; -7 is: 6.
s1 = ( CInt( 1 ), CInt( 2 ) ).
s2 = ( CInt( 2 ), CInt( 3 ) ).
s3 = min ( s1, s2 ) = ( CInt( 1 ), CInt( 2 ) ).

Vector v1 is ( 0 1 2 ).
Vector v2 is ( 0 1 2 ).
Vector v3 is ( 0 2 4 ).
Vector v4 = min ( v1,v2 ) is ( 0 1 2 ).
Vector v5 = min ( v1,v3 ) is ( 0 1 2 ).
</code></pre>
<h2 id="min_element" class="heading-with-anchor">  min_element<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#min_element"></a></h2>
<p>Finds the first occurrence of smallest element in a specified range where the ordering criterion may be specified by a binary predicate.</p>
<div class="codeHeader" id="code-try-80" data-bi-name="code-header"><span class="language">C++</span>
			<button class="action" data-bi-name="copy">
				<span class="docon docon-edit-copy" role="presentation"></span>
				<span>Copy</span>
			</button></div><pre><code class="lang-cpp" data-author-content="template&lt;class ForwardIterator&gt;
constexpr ForwardIterator min_element(ForwardIterator first, ForwardIterator last );

template&lt;class ForwardIterator, class BinaryPredicate&gt;
constexpr ForwardIterator min_element(
    ForwardIterator first,
    ForwardIterator last,
    BinaryPredicate comp);
"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ForwardIterator</span>&gt;
<span class="hljs-title">constexpr</span> <span class="hljs-title">ForwardIterator</span> <span class="hljs-title">min_element</span>(<span class="hljs-title">ForwardIterator</span> <span class="hljs-title">first</span>, <span class="hljs-title">ForwardIterator</span> <span class="hljs-title">last</span> );</span>

<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ForwardIterator</span>, <span class="hljs-title">class</span> <span class="hljs-title">BinaryPredicate</span>&gt;
<span class="hljs-title">constexpr</span> <span class="hljs-title">ForwardIterator</span> <span class="hljs-title">min_element</span>(
    <span class="hljs-title">ForwardIterator</span> <span class="hljs-title">first</span>,
    <span class="hljs-title">ForwardIterator</span> <span class="hljs-title">last</span>,
    <span class="hljs-title">BinaryPredicate</span> <span class="hljs-title">comp</span>);</span>
</code></pre>
<h3 id="parameters-38" class="heading-with-anchor">Parameters<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#parameters-38"></a></h3>
<p><em>first</em><br>
A forward iterator addressing the position of the first element in the range to be searched for the smallest element.</p>
<p><em>last</em><br>
A forward iterator addressing the position one past the final element in the range to be searched for the smallest element.</p>
<p><em>comp</em><br>
User-defined predicate function object that defines the sense in which one element is greater than another. The binary predicate takes two arguments and should return <strong>true</strong> when the first element is less than the second element and <strong>false</strong> otherwise.</p>
<h3 id="return-value-31" class="heading-with-anchor">Return Value<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#return-value-31"></a></h3>
<p>A forward iterator addressing the position of the first occurrence of the smallest element in the range searched.</p>
<h3 id="remarks-38" class="heading-with-anchor">Remarks<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#remarks-38"></a></h3>
<p>The range referenced must be valid; all pointers must be dereferenceable and within each sequence the last position is reachable from the first by incrementation.</p>
<p>The complexity is linear: (<code>last</code> - <code>first</code>) - 1 comparisons are required for a nonempty range.</p>
<h3 id="example-27" class="heading-with-anchor">Example<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#example-27"></a></h3>
<div class="codeHeader" id="code-try-81" data-bi-name="code-header"><span class="language">C++</span>
			<button class="action" data-bi-name="copy">
				<span class="docon docon-edit-copy" role="presentation"></span>
				<span>Copy</span>
			</button></div><pre><code class="lang-cpp" data-author-content="// alg_min_element.cpp
// compile with: /EHsc
#include &lt;vector&gt;
#include &lt;set&gt;
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;ostream&gt;

using namespace std;
class CInt;
ostream&amp; operator&lt;&lt;( ostream&amp; osIn, const CInt&amp; rhs );

class CInt
{
public:
   CInt( int n = 0 ) : m_nVal( n ){}
   CInt( const CInt&amp; rhs ) : m_nVal( rhs.m_nVal ){}
   CInt&amp; operator=( const CInt&amp; rhs ) {m_nVal =
   rhs.m_nVal; return *this;}
   bool operator&lt;( const CInt&amp; rhs ) const
      {return ( m_nVal &lt; rhs.m_nVal );}
   friend ostream&amp; operator&lt;&lt;( ostream&amp; osIn, const CInt&amp; rhs );

private:
   int m_nVal;
};

inline ostream&amp; operator&lt;&lt;( ostream&amp; osIn, const CInt&amp; rhs )
{
   osIn &lt;&lt; &quot;CInt( &quot; &lt;&lt; rhs.m_nVal &lt;&lt; &quot; )&quot;;
   return osIn;
}

// Return whether modulus of elem1 is less than modulus of elem2
bool mod_lesser ( int elem1, int elem2 )
{
   if ( elem1 &lt; 0 )
      elem1 = - elem1;
   if ( elem2 &lt; 0 )
      elem2 = - elem2;
   return elem1 &lt; elem2;
};

int main()
{
   // Searching a set container with elements of type CInt
   // for the minimum element
   CInt c1 = 1, c2 = 2, c3 = -3;
   set&lt;CInt&gt; s1;
   set&lt;CInt&gt;::iterator s1_Iter, s1_R1_Iter, s1_R2_Iter;

   s1.insert ( c1 );
   s1.insert ( c2 );
   s1.insert ( c3 );

   cout &lt;&lt; &quot;s1 = (&quot;;
   for ( s1_Iter = s1.begin( ); s1_Iter != --s1.end( ); s1_Iter++ )
      cout &lt;&lt; &quot; &quot; &lt;&lt; *s1_Iter &lt;&lt; &quot;,&quot;;
   s1_Iter = --s1.end( );
   cout &lt;&lt; &quot; &quot; &lt;&lt; *s1_Iter &lt;&lt; &quot; ).&quot; &lt;&lt; endl;

   s1_R1_Iter = min_element ( s1.begin( ), s1.end( ) );

   cout &lt;&lt; &quot;The smallest element in s1 is: &quot; &lt;&lt; *s1_R1_Iter &lt;&lt; endl;
   cout &lt;&lt; endl;

   // Searching a vector with elements of type int for the maximum
   // element under default less than &amp; mod_lesser binary predicates
   vector &lt;int&gt; v1;
   vector &lt;int&gt;::iterator v1_Iter, v1_R1_Iter, v1_R2_Iter;

   int i;
   for ( i = 0 ; i &lt;= 3 ; i++ )
   {
      v1.push_back( i );
   }

   int ii;
   for ( ii = 1 ; ii &lt;= 4 ; ii++ )
   {
      v1.push_back( - 2 * ii );
   }

   cout &lt;&lt; &quot;Vector v1 is ( &quot; ;
   for ( v1_Iter = v1.begin( ) ; v1_Iter != v1.end( ) ; v1_Iter++ )
      cout &lt;&lt; *v1_Iter &lt;&lt; &quot; &quot;;
   cout &lt;&lt; &quot;).&quot; &lt;&lt; endl;

   v1_R1_Iter = min_element ( v1.begin( ), v1.end( ) );
   v1_R2_Iter = min_element ( v1.begin( ), v1.end( ), mod_lesser);

   cout &lt;&lt; &quot;The smallest element in v1 is: &quot; &lt;&lt; *v1_R1_Iter &lt;&lt; endl;
   cout &lt;&lt; &quot;The smallest element in v1 under the mod_lesser&quot;
        &lt;&lt; &quot;\n binary predicate is: &quot; &lt;&lt; *v1_R2_Iter &lt;&lt; endl;
}
"><span class="hljs-comment">// alg_min_element.cpp</span>
<span class="hljs-comment">// compile with: /EHsc</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;set&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;ostream&gt;</span></span>

<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CInt</span>;</span>
ostream&amp; <span class="hljs-keyword">operator</span>&lt;&lt;( ostream&amp; osIn, <span class="hljs-keyword">const</span> CInt&amp; rhs );

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CInt</span>
{</span>
<span class="hljs-keyword">public</span>:
   CInt( <span class="hljs-keyword">int</span> n = <span class="hljs-number">0</span> ) : m_nVal( n ){}
   CInt( <span class="hljs-keyword">const</span> CInt&amp; rhs ) : m_nVal( rhs.m_nVal ){}
   CInt&amp; <span class="hljs-keyword">operator</span>=( <span class="hljs-keyword">const</span> CInt&amp; rhs ) {m_nVal =
   rhs.m_nVal; <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;}
   <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>&lt;( <span class="hljs-keyword">const</span> CInt&amp; rhs ) <span class="hljs-keyword">const</span>
      {<span class="hljs-keyword">return</span> ( m_nVal &lt; rhs.m_nVal );}
   <span class="hljs-keyword">friend</span> ostream&amp; <span class="hljs-keyword">operator</span>&lt;&lt;( ostream&amp; osIn, <span class="hljs-keyword">const</span> CInt&amp; rhs );

<span class="hljs-keyword">private</span>:
   <span class="hljs-keyword">int</span> m_nVal;
};

<span class="hljs-keyword">inline</span> ostream&amp; <span class="hljs-keyword">operator</span>&lt;&lt;( ostream&amp; osIn, <span class="hljs-keyword">const</span> CInt&amp; rhs )
{
   osIn &lt;&lt; <span class="hljs-string">"CInt( "</span> &lt;&lt; rhs.m_nVal &lt;&lt; <span class="hljs-string">" )"</span>;
   <span class="hljs-keyword">return</span> osIn;
}

<span class="hljs-comment">// Return whether modulus of elem1 is less than modulus of elem2</span>
<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">mod_lesser</span> <span class="hljs-params">( <span class="hljs-keyword">int</span> elem1, <span class="hljs-keyword">int</span> elem2 )</span>
</span>{
   <span class="hljs-keyword">if</span> ( elem1 &lt; <span class="hljs-number">0</span> )
      elem1 = - elem1;
   <span class="hljs-keyword">if</span> ( elem2 &lt; <span class="hljs-number">0</span> )
      elem2 = - elem2;
   <span class="hljs-keyword">return</span> elem1 &lt; elem2;
};

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
   <span class="hljs-comment">// Searching a set container with elements of type CInt</span>
   <span class="hljs-comment">// for the minimum element</span>
   CInt c1 = <span class="hljs-number">1</span>, c2 = <span class="hljs-number">2</span>, c3 = <span class="hljs-number">-3</span>;
   <span class="hljs-built_in">set</span>&lt;CInt&gt; s1;
   <span class="hljs-built_in">set</span>&lt;CInt&gt;::iterator s1_Iter, s1_R1_Iter, s1_R2_Iter;

   s1.insert ( c1 );
   s1.insert ( c2 );
   s1.insert ( c3 );

   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"s1 = ("</span>;
   <span class="hljs-keyword">for</span> ( s1_Iter = s1.begin( ); s1_Iter != --s1.end( ); s1_Iter++ )
      <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">" "</span> &lt;&lt; *s1_Iter &lt;&lt; <span class="hljs-string">","</span>;
   s1_Iter = --s1.end( );
   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">" "</span> &lt;&lt; *s1_Iter &lt;&lt; <span class="hljs-string">" )."</span> &lt;&lt; <span class="hljs-built_in">endl</span>;

   s1_R1_Iter = min_element ( s1.begin( ), s1.end( ) );

   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"The smallest element in s1 is: "</span> &lt;&lt; *s1_R1_Iter &lt;&lt; <span class="hljs-built_in">endl</span>;
   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">endl</span>;

   <span class="hljs-comment">// Searching a vector with elements of type int for the maximum</span>
   <span class="hljs-comment">// element under default less than &amp; mod_lesser binary predicates</span>
   <span class="hljs-built_in">vector</span> &lt;<span class="hljs-keyword">int</span>&gt; v1;
   <span class="hljs-built_in">vector</span> &lt;<span class="hljs-keyword">int</span>&gt;::iterator v1_Iter, v1_R1_Iter, v1_R2_Iter;

   <span class="hljs-keyword">int</span> i;
   <span class="hljs-keyword">for</span> ( i = <span class="hljs-number">0</span> ; i &lt;= <span class="hljs-number">3</span> ; i++ )
   {
      v1.push_back( i );
   }

   <span class="hljs-keyword">int</span> ii;
   <span class="hljs-keyword">for</span> ( ii = <span class="hljs-number">1</span> ; ii &lt;= <span class="hljs-number">4</span> ; ii++ )
   {
      v1.push_back( - <span class="hljs-number">2</span> * ii );
   }

   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Vector v1 is ( "</span> ;
   <span class="hljs-keyword">for</span> ( v1_Iter = v1.begin( ) ; v1_Iter != v1.end( ) ; v1_Iter++ )
      <span class="hljs-built_in">cout</span> &lt;&lt; *v1_Iter &lt;&lt; <span class="hljs-string">" "</span>;
   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">")."</span> &lt;&lt; <span class="hljs-built_in">endl</span>;

   v1_R1_Iter = min_element ( v1.begin( ), v1.end( ) );
   v1_R2_Iter = min_element ( v1.begin( ), v1.end( ), mod_lesser);

   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"The smallest element in v1 is: "</span> &lt;&lt; *v1_R1_Iter &lt;&lt; <span class="hljs-built_in">endl</span>;
   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"The smallest element in v1 under the mod_lesser"</span>
        &lt;&lt; <span class="hljs-string">"\n binary predicate is: "</span> &lt;&lt; *v1_R2_Iter &lt;&lt; <span class="hljs-built_in">endl</span>;
}
</code></pre>
<div class="codeHeader" id="code-try-82" data-bi-name="code-header"><span class="language">Output</span>
			<button class="action" data-bi-name="copy">
				<span class="docon docon-edit-copy" role="presentation"></span>
				<span>Copy</span>
			</button></div><pre><code class="lang-Output" data-author-content="s1 = ( CInt( -3 ), CInt( 1 ), CInt( 2 ) ).
The smallest element in s1 is: CInt( -3 )

Vector v1 is ( 0 1 2 3 -2 -4 -6 -8 ).
The smallest element in v1 is: -8
The smallest element in v1 under the mod_lesser
binary predicate is: 0
">s1 = ( CInt( -3 ), CInt( 1 ), CInt( 2 ) ).
The smallest element in s1 is: CInt( -3 )

Vector v1 is ( 0 1 2 3 -2 -4 -6 -8 ).
The smallest element in v1 is: -8
The smallest element in v1 under the mod_lesser
binary predicate is: 0
</code></pre>
<h2 id="minmax_element" class="heading-with-anchor">  minmax_element<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#minmax_element"></a></h2>
<p>Performs the work performed by <code>min_element</code> and <code>max_element</code> in one call.</p>
<div class="codeHeader" id="code-try-83" data-bi-name="code-header"><span class="language">C++</span>
			<button class="action" data-bi-name="copy">
				<span class="docon docon-edit-copy" role="presentation"></span>
				<span>Copy</span>
			</button></div><pre><code class="lang-cpp" data-author-content="template&lt;class ForwardIterator&gt;
constexpr pair&lt;ForwardIterator, ForwardIterator&gt; minmax_element(
    ForwardIterator first,
    ForwardIterator Last);
template&lt;class ForwardIterator, class BinaryPredicate&gt;
constexpr pair&lt;ForwardIterator, ForwardIterator&gt; minmax_element(
    ForwardIterator  first,
    ForwardIterator Last,
    BinaryPredicate  comp);
"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ForwardIterator</span>&gt;
<span class="hljs-title">constexpr</span> <span class="hljs-title">pair</span>&lt;ForwardIterator, ForwardIterator&gt; <span class="hljs-title">minmax_element</span>(
    <span class="hljs-title">ForwardIterator</span> <span class="hljs-title">first</span>,
    <span class="hljs-title">ForwardIterator</span> <span class="hljs-title">Last</span>);</span>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ForwardIterator</span>, <span class="hljs-title">class</span> <span class="hljs-title">BinaryPredicate</span>&gt;
<span class="hljs-title">constexpr</span> <span class="hljs-title">pair</span>&lt;ForwardIterator, ForwardIterator&gt; <span class="hljs-title">minmax_element</span>(
    <span class="hljs-title">ForwardIterator</span>  <span class="hljs-title">first</span>,
    <span class="hljs-title">ForwardIterator</span> <span class="hljs-title">Last</span>,
    <span class="hljs-title">BinaryPredicate</span>  <span class="hljs-title">comp</span>);</span>
</code></pre>
<h3 id="parameters-39" class="heading-with-anchor">Parameters<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#parameters-39"></a></h3>
<p><em>first</em><br>
A forward iterator that indicates the beginning of a range.</p>
<p><em>last</em><br>
A forward iterator that indicates the end of a range.</p>
<p><em>comp</em><br>
An optional test used to order elements.</p>
<h3 id="return-value-32" class="heading-with-anchor">Return Value<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#return-value-32"></a></h3>
<p>Returns</p>
<p><code>pair&lt;ForwardIterator, ForwardIterator&gt;</code></p>
<p><code>(</code> <a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#min_element" data-linktype="relative-path">min_element</a><code>(first, last),</code><a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#max_element" data-linktype="relative-path">max_element</a><code>(first, last))</code>.</p>
<h3 id="remarks-39" class="heading-with-anchor">Remarks<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#remarks-39"></a></h3>
<p>The first template function returns</p>
<p><code>pair&lt;ForwardIterator,ForwardIterator&gt;</code></p>
<p><code>(min_element(_First,Last), max_element(_First,Last))</code>.</p>
<p>The second template function behaves the same, except that it replaces <code>operator&lt;(X, Y)</code> with <code>comp (X, Y)</code>.</p>
<p>If the sequence is non-empty, the function performs at most <code>3 * (last - first - 1) / 2</code> comparisons.</p>
<h2 id="minmax" class="heading-with-anchor">  minmax<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#minmax"></a></h2>
<p>Compares two input parameters and returns them as a pair, in order of lesser to greater.</p>
<div class="codeHeader" id="code-try-84" data-bi-name="code-header"><span class="language">C++</span>
			<button class="action" data-bi-name="copy">
				<span class="docon docon-edit-copy" role="presentation"></span>
				<span>Copy</span>
			</button></div><pre><code class="lang-cpp" data-author-content="template&lt;class Type&gt;
constexpr pair&lt;const Type&amp;, const Type&amp;&gt; minmax(
    const Type&amp; left,
    const Type&amp; right);
template&lt;class Type, class BinaryPredicate&gt;
constexpr pair&lt;const Type&amp;, const Type&amp;&gt; minmax(
    const Type&amp; left,
    const Type&amp; right,
    BinaryPredicate comp);
template&lt;class Type&gt;
constexpr pair&lt;Type&amp;, Type&amp;&gt; minmax(
    initializer_list&lt;Type&gt; );
template&lt;class Type, class BinaryPredicate&gt;
constexpr pair&lt;Type&amp;, Type&amp;&gt; minmax(
    initializer_list&lt;Type&gt;,
    BinaryPredicate comp);
"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Type</span>&gt;
<span class="hljs-title">constexpr</span> <span class="hljs-title">pair</span>&lt;const Type&amp;, const Type&amp;&gt; <span class="hljs-title">minmax</span>(
    <span class="hljs-title">const</span> <span class="hljs-title">Type</span>&amp; <span class="hljs-title">left</span>,
    <span class="hljs-title">const</span> <span class="hljs-title">Type</span>&amp; <span class="hljs-title">right</span>);</span>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Type</span>, <span class="hljs-title">class</span> <span class="hljs-title">BinaryPredicate</span>&gt;
<span class="hljs-title">constexpr</span> <span class="hljs-title">pair</span>&lt;const Type&amp;, const Type&amp;&gt; <span class="hljs-title">minmax</span>(
    <span class="hljs-title">const</span> <span class="hljs-title">Type</span>&amp; <span class="hljs-title">left</span>,
    <span class="hljs-title">const</span> <span class="hljs-title">Type</span>&amp; <span class="hljs-title">right</span>,
    <span class="hljs-title">BinaryPredicate</span> <span class="hljs-title">comp</span>);</span>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Type</span>&gt;
<span class="hljs-title">constexpr</span> <span class="hljs-title">pair</span>&lt;Type&amp;, Type&amp;&gt; <span class="hljs-title">minmax</span>(
    <span class="hljs-title">initializer_list</span>&lt;Type&gt; );</span>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Type</span>, <span class="hljs-title">class</span> <span class="hljs-title">BinaryPredicate</span>&gt;
<span class="hljs-title">constexpr</span> <span class="hljs-title">pair</span>&lt;Type&amp;, Type&amp;&gt; <span class="hljs-title">minmax</span>(
    <span class="hljs-title">initializer_list</span>&lt;Type&gt;,
    <span class="hljs-title">BinaryPredicate</span> <span class="hljs-title">comp</span>);</span>
</code></pre>
<h3 id="parameters-40" class="heading-with-anchor">Parameters<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#parameters-40"></a></h3>
<p><em>left</em><br>
The first of the two objects being compared.</p>
<p><em>right</em><br>
The second of the two objects being compared.</p>
<p><em>comp</em><br>
A binary predicate used to compare the two objects.</p>
<p><em>_IList</em><br>
The initializer_list that contains the members to be compared.</p>
<h3 id="remarks-40" class="heading-with-anchor">Remarks<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#remarks-40"></a></h3>
<p>The first template function returns <code>pair&lt;const Type&amp;, const Type&amp;&gt;( right , left )</code> if <em>right</em> is less than <em>left</em>. Otherwise, it returns <code>pair&lt;const Type&amp;, const Type&amp;&gt;( left , right )</code>.</p>
<p>The second member function returns a pair where the first element is the lesser and the second is the greater when compared by the predicate <em>comp</em>.</p>
<p>The remaining template functions behave the same, except that they replace the <em>left</em> and <em>right</em> parameters with <em>_IList</em>.</p>
<p>The function performs exactly one comparison.</p>
<h2 id="mismatch" class="heading-with-anchor">  mismatch<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#mismatch"></a></h2>
<p>Compares two ranges element by element and locates the first position where a difference occurs.</p>
<p>Use the dual-range overloads in C++14 code because the overloads that only take a single iterator for the second range will not detect differences if the second range is longer than the first range, and will result in undefined behavior if the second range is shorter than the first range.</p>
<div class="codeHeader" id="code-try-85" data-bi-name="code-header"><span class="language">C++</span>
			<button class="action" data-bi-name="copy">
				<span class="docon docon-edit-copy" role="presentation"></span>
				<span>Copy</span>
			</button></div><pre><code class="lang-cpp" data-author-content="template&lt;class InputIterator1, class InputIterator2&gt;
pair&lt;InputIterator1, InputIterator2&gt;&gt;
mismatch(
    InputIterator1 First1,
    InputIterator1 Last1,
    InputIterator2 First2 );

template&lt;class InputIterator1, class InputIterator2, class BinaryPredicate&gt; pair&lt;InputIterator1, InputIterator2&gt;&gt;
mismatch(
    InputIterator1 First1,
    InputIterator1 Last1,
    InputIterator2 First2,
    BinaryPredicate Comp );

//C++14
template&lt;class InputIterator1, class InputIterator2&gt;
pair&lt;InputIterator1, InputIterator2&gt;&gt;
mismatch(
    InputIterator1 First1,
    InputIterator1 Last1,
    InputIterator2 First2,
    InputIterator2 Last2 );

template&lt;class InputIterator1, class InputIterator2, class BinaryPredicate&gt; pair&lt;InputIterator1, InputIterator2&gt;&gt;
mismatch(
    InputIterator1 First1,
    InputIterator1 Last1,
    InputIterator2 First2,
    InputIterator2 Last2,
    BinaryPredicate Comp);
"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InputIterator1</span>, <span class="hljs-title">class</span> <span class="hljs-title">InputIterator2</span>&gt;
<span class="hljs-title">pair</span>&lt;InputIterator1, InputIterator2&gt;&gt;
<span class="hljs-title">mismatch</span>(
    <span class="hljs-title">InputIterator1</span> <span class="hljs-title">First1</span>,
    <span class="hljs-title">InputIterator1</span> <span class="hljs-title">Last1</span>,
    <span class="hljs-title">InputIterator2</span> <span class="hljs-title">First2</span> );</span>

<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InputIterator1</span>, <span class="hljs-title">class</span> <span class="hljs-title">InputIterator2</span>, <span class="hljs-title">class</span> <span class="hljs-title">BinaryPredicate</span>&gt; <span class="hljs-title">pair</span>&lt;InputIterator1, InputIterator2&gt;&gt;
<span class="hljs-title">mismatch</span>(
    <span class="hljs-title">InputIterator1</span> <span class="hljs-title">First1</span>,
    <span class="hljs-title">InputIterator1</span> <span class="hljs-title">Last1</span>,
    <span class="hljs-title">InputIterator2</span> <span class="hljs-title">First2</span>,
    <span class="hljs-title">BinaryPredicate</span> <span class="hljs-title">Comp</span> );</span>

<span class="hljs-comment">//C++14</span>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InputIterator1</span>, <span class="hljs-title">class</span> <span class="hljs-title">InputIterator2</span>&gt;
<span class="hljs-title">pair</span>&lt;InputIterator1, InputIterator2&gt;&gt;
<span class="hljs-title">mismatch</span>(
    <span class="hljs-title">InputIterator1</span> <span class="hljs-title">First1</span>,
    <span class="hljs-title">InputIterator1</span> <span class="hljs-title">Last1</span>,
    <span class="hljs-title">InputIterator2</span> <span class="hljs-title">First2</span>,
    <span class="hljs-title">InputIterator2</span> <span class="hljs-title">Last2</span> );</span>

<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InputIterator1</span>, <span class="hljs-title">class</span> <span class="hljs-title">InputIterator2</span>, <span class="hljs-title">class</span> <span class="hljs-title">BinaryPredicate</span>&gt; <span class="hljs-title">pair</span>&lt;InputIterator1, InputIterator2&gt;&gt;
<span class="hljs-title">mismatch</span>(
    <span class="hljs-title">InputIterator1</span> <span class="hljs-title">First1</span>,
    <span class="hljs-title">InputIterator1</span> <span class="hljs-title">Last1</span>,
    <span class="hljs-title">InputIterator2</span> <span class="hljs-title">First2</span>,
    <span class="hljs-title">InputIterator2</span> <span class="hljs-title">Last2</span>,
    <span class="hljs-title">BinaryPredicate</span> <span class="hljs-title">Comp</span>);</span>
</code></pre>
<h3 id="parameters-41" class="heading-with-anchor">Parameters<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#parameters-41"></a></h3>
<p><em>First1</em><br>
An input iterator addressing the position of the first element in the first range to be tested.</p>
<p><em>Last1</em><br>
An input iterator addressing the position one past the last element in the first range to be tested.</p>
<p><em>First2</em><br>
An input iterator addressing the position of the first element in the second range to be tested.</p>
<p><em>Last2</em><br>
An input iterator addressing the position of one past the last element in the second range to be tested.</p>
<p><em>Comp</em><br>
User-defined predicate function object that compares the current elements in each range and determines whether they are equivalent. It returns <strong>true</strong> when satisfied and <strong>false</strong> when not satisfied.</p>
<h3 id="return-value-33" class="heading-with-anchor">Return Value<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#return-value-33"></a></h3>
<p>A pair of iterators addressing the positions of the mismatch in the two ranges, the first component iterator to the position in the first range and the second component iterator to the position in the second range. If there is no difference between the elements in the ranges compared or if the binary predicate in the second version is satisfied by all element pairs from the two ranges, then the first component iterator points to the position one past the final element in the first range and the second component iterator to position one past the final element tested in the second range.</p>
<h3 id="remarks-41" class="heading-with-anchor">Remarks<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#remarks-41"></a></h3>
<p>The first template function assumes that there are as many elements in the range beginning at first2 as there are in the range designated by [first1, last1). If there are more in the second range, they are ignored; if there are less then undefined behavior will result.</p>
<p>The range to be searched must be valid; all iterators must be dereferenceable and the last position is reachable from the first by incrementation.</p>
<p>The time complexity of the algorithm is linear in the number of elements contained in the shorter range.</p>
<p>The user-defined predicate is not required to impose an equivalence relation that symmetric, reflexive and transitive between its operands.</p>
<h3 id="example-28" class="heading-with-anchor">Example<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#example-28"></a></h3>
<p>The following example demonstrates how to use mismatch. The C++03 overload is shown only in order to demonstrate how it can produce an unexpected result.</p>
<div class="codeHeader" id="code-try-86" data-bi-name="code-header"><span class="language">C++</span>
			<button class="action" data-bi-name="copy">
				<span class="docon docon-edit-copy" role="presentation"></span>
				<span>Copy</span>
			</button></div><pre><code class="lang-cpp" data-author-content="#include &lt;vector&gt;
#include &lt;list&gt;
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;utility&gt;

using namespace std;

// Return whether first element is twice the second
// Note that this is not a symmetric, reflexive and transitive equivalence.
// mismatch and equal accept such predicates, but is_permutation does not.
bool twice(int elem1, int elem2)
{
    return elem1 == elem2 * 2;
}

void PrintResult(const string&amp; msg, const pair&lt;vector&lt;int&gt;::iterator, vector&lt;int&gt;::iterator&gt;&amp; result,
    const vector&lt;int&gt;&amp; left, const vector&lt;int&gt;&amp; right)
{
    // If either iterator stops before reaching the end of its container,
    // it means a mismatch was detected.
    if (result.first != left.end() || result.second != right.end())
    {
        string leftpos(result.first == left.end() ? &quot;end&quot; : to_string(*result.first));
        string rightpos(result.second == right.end() ? &quot;end&quot; : to_string(*result.second));
        cout &lt;&lt; msg &lt;&lt; &quot;mismatch. Left iterator at &quot; &lt;&lt; leftpos
            &lt;&lt; &quot; right iterator at &quot; &lt;&lt; rightpos &lt;&lt; endl;
    }
    else
    {
        cout &lt;&lt; msg &lt;&lt; &quot; match.&quot; &lt;&lt; endl;
    }
}

int main()
{

    vector&lt;int&gt; vec_1{ 0, 5, 10, 15, 20, 25 };
    vector&lt;int&gt; vec_2{ 0, 5, 10, 15, 20, 25, 30 };

    // Testing different length vectors for mismatch (C++03)
    auto match_vecs = mismatch(vec_1.begin(), vec_1.end(), vec_2.begin());
    bool is_mismatch = match_vecs.first != vec_1.end();
    cout &lt;&lt; &quot;C++03: vec_1 and vec_2 are a mismatch: &quot; &lt;&lt; boolalpha &lt;&lt; is_mismatch &lt;&lt; endl;

    // Using dual-range overloads:

    // Testing different length vectors for mismatch (C++14)
    match_vecs = mismatch(vec_1.begin(), vec_1.end(), vec_2.begin(), vec_2.end());
    PrintResult(&quot;C++14: vec_1 and vec_2: &quot;, match_vecs, vec_1, vec_2);

    // Identify point of mismatch between vec_1 and modified vec_2.
    vec_2[3] = 42;
    match_vecs = mismatch(vec_1.begin(), vec_1.end(), vec_2.begin(), vec_2.end());
    PrintResult(&quot;C++14 vec_1 v. vec_2 modified: &quot;, match_vecs, vec_1, vec_2);

    // Test vec_3 and vec_4 for mismatch under the binary predicate twice (C++14)
    vector&lt;int&gt; vec_3{ 10, 20, 30, 40, 50, 60 };
    vector&lt;int&gt; vec_4{ 5, 10, 15, 20, 25, 30 };
    match_vecs = mismatch(vec_3.begin(), vec_3.end(), vec_4.begin(), vec_4.end(), twice);
    PrintResult(&quot;vec_3 v. vec_4 with pred: &quot;, match_vecs, vec_3, vec_4);

    vec_4[5] = 31;
    match_vecs = mismatch(vec_3.begin(), vec_3.end(), vec_4.begin(), vec_4.end(), twice);
    PrintResult(&quot;vec_3 v. modified vec_4 with pred: &quot;, match_vecs, vec_3, vec_4);

    // Compare a vector&lt;int&gt; to a list&lt;int&gt;
    list&lt;int&gt; list_1{ 0, 5, 10, 15, 20, 25 };
    auto match_vec_list = mismatch(vec_1.begin(), vec_1.end(), list_1.begin(), list_1.end());
    is_mismatch = match_vec_list.first != vec_1.end() || match_vec_list.second != list_1.end();
    cout &lt;&lt; &quot;vec_1 and list_1 are a mismatch: &quot; &lt;&lt; boolalpha &lt;&lt; is_mismatch &lt;&lt; endl;

    char c;
    cout &lt;&lt; &quot;Press a key&quot; &lt;&lt; endl;
    cin &gt;&gt; c;

}

/*
Output:
C++03: vec_1 and vec_2 are a mismatch: false
C++14: vec_1 and vec_2: mismatch. Left iterator at end right iterator at 30
C++14 vec_1 v. vec_2 modified: mismatch. Left iterator at 15 right iterator at 42
C++14 vec_3 v. vec_4 with pred:  match.
C++14 vec_3 v. modified vec_4 with pred: mismatch. Left iterator at 60 right iterator at 31
C++14: vec_1 and list_1 are a mismatch: false
Press a key
*/
"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;list&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;utility&gt;</span></span>

<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;

<span class="hljs-comment">// Return whether first element is twice the second</span>
<span class="hljs-comment">// Note that this is not a symmetric, reflexive and transitive equivalence.</span>
<span class="hljs-comment">// mismatch and equal accept such predicates, but is_permutation does not.</span>
<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">twice</span><span class="hljs-params">(<span class="hljs-keyword">int</span> elem1, <span class="hljs-keyword">int</span> elem2)</span>
</span>{
    <span class="hljs-keyword">return</span> elem1 == elem2 * <span class="hljs-number">2</span>;
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">PrintResult</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span>&amp; msg, <span class="hljs-keyword">const</span> pair&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;::iterator, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;::iterator&gt;&amp; result,
    <span class="hljs-keyword">const</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; left, <span class="hljs-keyword">const</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; right)</span>
</span>{
    <span class="hljs-comment">// If either iterator stops before reaching the end of its container,</span>
    <span class="hljs-comment">// it means a mismatch was detected.</span>
    <span class="hljs-keyword">if</span> (result.first != left.end() || result.second != right.end())
    {
        <span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">leftpos</span><span class="hljs-params">(result.first == left.end()</span> ? "end" : <span class="hljs-title">to_string</span><span class="hljs-params">(*result.first)</span>)</span>;
        <span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">rightpos</span><span class="hljs-params">(result.second == right.end()</span> ? "end" : <span class="hljs-title">to_string</span><span class="hljs-params">(*result.second)</span>)</span>;
        <span class="hljs-built_in">cout</span> &lt;&lt; msg &lt;&lt; <span class="hljs-string">"mismatch. Left iterator at "</span> &lt;&lt; leftpos
            &lt;&lt; <span class="hljs-string">" right iterator at "</span> &lt;&lt; rightpos &lt;&lt; <span class="hljs-built_in">endl</span>;
    }
    <span class="hljs-keyword">else</span>
    {
        <span class="hljs-built_in">cout</span> &lt;&lt; msg &lt;&lt; <span class="hljs-string">" match."</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
    }
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{

    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; vec_1{ <span class="hljs-number">0</span>, <span class="hljs-number">5</span>, <span class="hljs-number">10</span>, <span class="hljs-number">15</span>, <span class="hljs-number">20</span>, <span class="hljs-number">25</span> };
    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; vec_2{ <span class="hljs-number">0</span>, <span class="hljs-number">5</span>, <span class="hljs-number">10</span>, <span class="hljs-number">15</span>, <span class="hljs-number">20</span>, <span class="hljs-number">25</span>, <span class="hljs-number">30</span> };

    <span class="hljs-comment">// Testing different length vectors for mismatch (C++03)</span>
    <span class="hljs-keyword">auto</span> match_vecs = mismatch(vec_1.begin(), vec_1.end(), vec_2.begin());
    <span class="hljs-keyword">bool</span> is_mismatch = match_vecs.first != vec_1.end();
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"C++03: vec_1 and vec_2 are a mismatch: "</span> &lt;&lt; boolalpha &lt;&lt; is_mismatch &lt;&lt; <span class="hljs-built_in">endl</span>;

    <span class="hljs-comment">// Using dual-range overloads:</span>

    <span class="hljs-comment">// Testing different length vectors for mismatch (C++14)</span>
    match_vecs = mismatch(vec_1.begin(), vec_1.end(), vec_2.begin(), vec_2.end());
    PrintResult(<span class="hljs-string">"C++14: vec_1 and vec_2: "</span>, match_vecs, vec_1, vec_2);

    <span class="hljs-comment">// Identify point of mismatch between vec_1 and modified vec_2.</span>
    vec_2[<span class="hljs-number">3</span>] = <span class="hljs-number">42</span>;
    match_vecs = mismatch(vec_1.begin(), vec_1.end(), vec_2.begin(), vec_2.end());
    PrintResult(<span class="hljs-string">"C++14 vec_1 v. vec_2 modified: "</span>, match_vecs, vec_1, vec_2);

    <span class="hljs-comment">// Test vec_3 and vec_4 for mismatch under the binary predicate twice (C++14)</span>
    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; vec_3{ <span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>, <span class="hljs-number">40</span>, <span class="hljs-number">50</span>, <span class="hljs-number">60</span> };
    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; vec_4{ <span class="hljs-number">5</span>, <span class="hljs-number">10</span>, <span class="hljs-number">15</span>, <span class="hljs-number">20</span>, <span class="hljs-number">25</span>, <span class="hljs-number">30</span> };
    match_vecs = mismatch(vec_3.begin(), vec_3.end(), vec_4.begin(), vec_4.end(), twice);
    PrintResult(<span class="hljs-string">"vec_3 v. vec_4 with pred: "</span>, match_vecs, vec_3, vec_4);

    vec_4[<span class="hljs-number">5</span>] = <span class="hljs-number">31</span>;
    match_vecs = mismatch(vec_3.begin(), vec_3.end(), vec_4.begin(), vec_4.end(), twice);
    PrintResult(<span class="hljs-string">"vec_3 v. modified vec_4 with pred: "</span>, match_vecs, vec_3, vec_4);

    <span class="hljs-comment">// Compare a vector&lt;int&gt; to a list&lt;int&gt;</span>
    <span class="hljs-built_in">list</span>&lt;<span class="hljs-keyword">int</span>&gt; list_1{ <span class="hljs-number">0</span>, <span class="hljs-number">5</span>, <span class="hljs-number">10</span>, <span class="hljs-number">15</span>, <span class="hljs-number">20</span>, <span class="hljs-number">25</span> };
    <span class="hljs-keyword">auto</span> match_vec_list = mismatch(vec_1.begin(), vec_1.end(), list_1.begin(), list_1.end());
    is_mismatch = match_vec_list.first != vec_1.end() || match_vec_list.second != list_1.end();
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"vec_1 and list_1 are a mismatch: "</span> &lt;&lt; boolalpha &lt;&lt; is_mismatch &lt;&lt; <span class="hljs-built_in">endl</span>;

    <span class="hljs-keyword">char</span> c;
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Press a key"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
    <span class="hljs-built_in">cin</span> &gt;&gt; c;

}

<span class="hljs-comment">/*
Output:
C++03: vec_1 and vec_2 are a mismatch: false
C++14: vec_1 and vec_2: mismatch. Left iterator at end right iterator at 30
C++14 vec_1 v. vec_2 modified: mismatch. Left iterator at 15 right iterator at 42
C++14 vec_3 v. vec_4 with pred:  match.
C++14 vec_3 v. modified vec_4 with pred: mismatch. Left iterator at 60 right iterator at 31
C++14: vec_1 and list_1 are a mismatch: false
Press a key
*/</span>
</code></pre>
<h2 id="alg_move" class="heading-with-anchor">  &lt;alg&gt; move<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#alg_move"></a></h2>
<p>Move elements associated with a specified range.</p>
<div class="codeHeader" id="code-try-87" data-bi-name="code-header"><span class="language">C++</span>
			<button class="action" data-bi-name="copy">
				<span class="docon docon-edit-copy" role="presentation"></span>
				<span>Copy</span>
			</button></div><pre><code class="lang-cpp" data-author-content="template&lt;class InputIterator, class OutputIterator&gt;
OutputIterator move(
    InputIterator first,
    InputIterator last,
    OutputIterator dest);
"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InputIterator</span>, <span class="hljs-title">class</span> <span class="hljs-title">OutputIterator</span>&gt;
<span class="hljs-title">OutputIterator</span> <span class="hljs-title">move</span>(
    <span class="hljs-title">InputIterator</span> <span class="hljs-title">first</span>,
    <span class="hljs-title">InputIterator</span> <span class="hljs-title">last</span>,
    <span class="hljs-title">OutputIterator</span> <span class="hljs-title">dest</span>);</span>
</code></pre>
<h3 id="parameters-42" class="heading-with-anchor">Parameters<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#parameters-42"></a></h3>
<p><em>first</em><br>
An input iterator that indicates where to start the range of elements to move.</p>
<p><em>last</em><br>
An input iterator that indicates the end of a range of elements to move.</p>
<p><em>dest</em><br>
The output iterator that is to contain the moved elements.</p>
<h3 id="remarks-42" class="heading-with-anchor">Remarks<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#remarks-42"></a></h3>
<p>The template function evaluates <code>*(dest + N) = move(*(first + N))</code> once for each <code>N</code> in the range <code>[0, last - first)</code>, for strictly increasing values of <code>N</code> starting with the lowest value. It then returns <code>dest + N</code>. If <code>dest</code> and <em>first</em> designate regions of storage, <em>dest</em> must not be in the range <code>[first, last)</code>.</p>
<h2 id="move_backward" class="heading-with-anchor">  move_backward<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#move_backward"></a></h2>
<p>Moves the elements of one iterator to another. The move starts with the last element in a specified range, and ends with the first element in that range.</p>
<div class="codeHeader" id="code-try-88" data-bi-name="code-header"><span class="language">C++</span>
			<button class="action" data-bi-name="copy">
				<span class="docon docon-edit-copy" role="presentation"></span>
				<span>Copy</span>
			</button></div><pre><code class="lang-cpp" data-author-content="template&lt;class BidirectionalIterator1, class BidirectionalIterator2&gt;
   BidirectionalIterator2 move_backward(
       BidirectionalIterator1 first,
       BidirectionalIterator1 last,
       BidirectionalIterator2 destEnd);
"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BidirectionalIterator1</span>, <span class="hljs-title">class</span> <span class="hljs-title">BidirectionalIterator2</span>&gt;
   <span class="hljs-title">BidirectionalIterator2</span> <span class="hljs-title">move_backward</span>(
       <span class="hljs-title">BidirectionalIterator1</span> <span class="hljs-title">first</span>,
       <span class="hljs-title">BidirectionalIterator1</span> <span class="hljs-title">last</span>,
       <span class="hljs-title">BidirectionalIterator2</span> <span class="hljs-title">destEnd</span>);</span>
</code></pre>
<h3 id="parameters-43" class="heading-with-anchor">Parameters<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#parameters-43"></a></h3>
<p><em>first</em><br>
An iterator that indicates the start of a range to move elements from.</p>
<p><em>last</em><br>
An iterator that indicates the end of a range to move elements from. This element is not moved.</p>
<p><em>destEnd</em><br>
A bidirectional iterator addressing the position of one past the final element in the destination range.</p>
<h3 id="remarks-43" class="heading-with-anchor">Remarks<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#remarks-43"></a></h3>
<p>The template function evaluates <code>*(destEnd - N - 1) = move(*(last - N - 1))</code> once for each <code>N</code> in the range <code>[0, last - first)</code>, for strictly increasing values of <code>N</code> starting with the lowest value. It then returns <code>destEnd - (last - first)</code>. If <em>destEnd</em> and  <em>first</em> designate regions of storage, <em>destEnd</em> must not be in the range <code>[first, last)</code>.</p>
<p><code>move</code> and <code>move_backward</code> are functionally equivalent to using <code>copy</code> and <code>copy_backward</code> with a move iterator.</p>
<h2 id="next_permutation" class="heading-with-anchor">  next_permutation<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#next_permutation"></a></h2>
<p>Reorders the elements in a range so that the original ordering is replaced by the lexicographically next greater permutation if it exists, where the sense of next may be specified with a binary predicate.</p>
<div class="codeHeader" id="code-try-89" data-bi-name="code-header"><span class="language">C++</span>
			<button class="action" data-bi-name="copy">
				<span class="docon docon-edit-copy" role="presentation"></span>
				<span>Copy</span>
			</button></div><pre><code class="lang-cpp" data-author-content="template&lt;class BidirectionalIterator&gt;
bool next_permutation(BidirectionalIterator first, BidirectionalIterator last);

template&lt;class BidirectionalIterator, class BinaryPredicate&gt;
bool next_permutation(BidirectionalIterator first, BidirectionalIterator last, BinaryPredicate comp);
"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BidirectionalIterator</span>&gt;
<span class="hljs-title">bool</span> <span class="hljs-title">next_permutation</span>(<span class="hljs-title">BidirectionalIterator</span> <span class="hljs-title">first</span>, <span class="hljs-title">BidirectionalIterator</span> <span class="hljs-title">last</span>);</span>

<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BidirectionalIterator</span>, <span class="hljs-title">class</span> <span class="hljs-title">BinaryPredicate</span>&gt;
<span class="hljs-title">bool</span> <span class="hljs-title">next_permutation</span>(<span class="hljs-title">BidirectionalIterator</span> <span class="hljs-title">first</span>, <span class="hljs-title">BidirectionalIterator</span> <span class="hljs-title">last</span>, <span class="hljs-title">BinaryPredicate</span> <span class="hljs-title">comp</span>);</span>
</code></pre>
<h3 id="parameters-44" class="heading-with-anchor">Parameters<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#parameters-44"></a></h3>
<p><em>first</em><br>
A bidirectional iterator pointing to the position of the first element in the range to be permuted.</p>
<p><em>last</em><br>
A bidirectional iterator pointing to the position one past the final element in the range to be permuted.</p>
<p><em>comp</em><br>
User-defined predicate function object that defines the comparison criterion to be satisfied by successive elements in the ordering. A binary predicate takes two arguments and returns <strong>true</strong> when satisfied and <strong>false</strong> when not satisfied.</p>
<h3 id="return-value-34" class="heading-with-anchor">Return Value<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#return-value-34"></a></h3>
<p><strong>true</strong> if the lexicographically next permutation exists and has replaced the original ordering of the range; otherwise <strong>false</strong>, in which case the ordering is transformed into the lexicographically smallest permutation.</p>
<h3 id="remarks-44" class="heading-with-anchor">Remarks<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#remarks-44"></a></h3>
<p>The range referenced must be valid; all pointers must be dereferenceable and within the sequence the last position is reachable from the first by incrementation.</p>
<p>The default binary predicate is less than and the elements in the range must be less than comparable to insure that the next permutation is well defined.</p>
<p>The complexity is linear with at most ( * last - first*)/2 swaps.</p>
<h3 id="example-29" class="heading-with-anchor">Example<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#example-29"></a></h3>
<div class="codeHeader" id="code-try-90" data-bi-name="code-header"><span class="language">C++</span>
			<button class="action" data-bi-name="copy">
				<span class="docon docon-edit-copy" role="presentation"></span>
				<span>Copy</span>
			</button></div><pre><code class="lang-cpp" data-author-content="// alg_next_perm.cpp
// compile with: /EHsc
#include &lt;vector&gt;
#include &lt;deque&gt;
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;ostream&gt;

using namespace std;
class CInt;
ostream&amp; operator&lt;&lt;( ostream&amp; osIn, const CInt&amp; rhs );

class CInt
{
public:
   CInt( int n = 0 ) : m_nVal( n ){}
   CInt( const CInt&amp; rhs ) : m_nVal( rhs.m_nVal ){}
   CInt&amp;   operator=( const CInt&amp; rhs ) {m_nVal =
   rhs.m_nVal; return *this;}
   bool operator&lt;( const CInt&amp; rhs ) const
      { return ( m_nVal &lt; rhs.m_nVal );}
   friend   ostream&amp; operator&lt;&lt;( ostream&amp; osIn, const CInt&amp; rhs );

private:
   int m_nVal;
};

inline ostream&amp; operator&lt;&lt;( ostream&amp; osIn, const CInt&amp; rhs )
{
   osIn &lt;&lt; &quot;CInt( &quot; &lt;&lt; rhs.m_nVal &lt;&lt; &quot; )&quot;;
   return osIn;
}

// Return whether modulus of elem1 is less than modulus of elem2
bool mod_lesser ( int elem1, int elem2 )
{
   if ( elem1 &lt; 0 )
      elem1 = - elem1;
   if ( elem2 &lt; 0 )
      elem2 = - elem2;
   return elem1 &lt; elem2;
};

int main()
{
   // Reordering the elements of type CInt in a deque
   // using the prev_permutation algorithm
   CInt c1 = 5, c2 = 1, c3 = 10;
   bool deq1Result;
   deque&lt;CInt&gt; deq1, deq2, deq3;
   deque&lt;CInt&gt;::iterator d1_Iter;

   deq1.push_back ( c1 );
   deq1.push_back ( c2 );
   deq1.push_back ( c3 );

   cout &lt;&lt; &quot;The original deque of CInts is deq1 = (&quot;;
   for ( d1_Iter = deq1.begin( ); d1_Iter != --deq1.end( ); d1_Iter++ )
      cout &lt;&lt; &quot; &quot; &lt;&lt; *d1_Iter &lt;&lt; &quot;,&quot;;
   d1_Iter = --deq1.end( );
   cout &lt;&lt; &quot; &quot; &lt;&lt; *d1_Iter &lt;&lt; &quot; ).&quot; &lt;&lt; endl;

   deq1Result = next_permutation ( deq1.begin( ), deq1.end( ) );

   if ( deq1Result )
      cout &lt;&lt; &quot;The lexicographically next permutation &quot;
           &lt;&lt; &quot;exists and has\nreplaced the original &quot;
           &lt;&lt; &quot;ordering of the sequence in deq1.&quot; &lt;&lt; endl;
   else
      cout &lt;&lt; &quot;The lexicographically next permutation doesn&#39;t &quot;
           &lt;&lt; &quot;exist\n and the lexicographically &quot;
           &lt;&lt; &quot;smallest permutation\n has replaced the &quot;
           &lt;&lt; &quot;original ordering of the sequence in deq1.&quot; &lt;&lt; endl;

   cout &lt;&lt; &quot;After one application of next_permutation,\n deq1 = (&quot;;
   for ( d1_Iter = deq1.begin( ); d1_Iter != --deq1.end( ); d1_Iter++ )
      cout &lt;&lt; &quot; &quot; &lt;&lt; *d1_Iter &lt;&lt; &quot;,&quot;;
   d1_Iter = --deq1.end( );
   cout &lt;&lt; &quot; &quot; &lt;&lt; *d1_Iter &lt;&lt; &quot; ).&quot; &lt;&lt; endl &lt;&lt; endl;

   // Permuting vector elements with binary function mod_lesser
   vector &lt;int&gt; v1;
   vector &lt;int&gt;::iterator Iter1;

   int i;
   for ( i = -3 ; i &lt;= 3 ; i++ )
   {
      v1.push_back( i );
   }

   cout &lt;&lt; &quot;Vector v1 is ( &quot; ;
   for ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ; Iter1++ )
      cout &lt;&lt; *Iter1 &lt;&lt; &quot; &quot;;
   cout &lt;&lt; &quot;).&quot; &lt;&lt; endl;

   next_permutation ( v1.begin( ), v1.end( ), mod_lesser );

   cout &lt;&lt; &quot;After the first next_permutation, vector v1 is:\n v1 = ( &quot; ;
   for ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ; Iter1++ )
      cout &lt;&lt; *Iter1 &lt;&lt; &quot; &quot;;
   cout &lt;&lt; &quot;).&quot; &lt;&lt; endl;

   int iii = 1;
   while ( iii &lt;= 5 ) {
      next_permutation ( v1.begin( ), v1.end( ), mod_lesser );
      cout &lt;&lt; &quot;After another next_permutation of vector v1,\n v1 =   ( &quot; ;
      for ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ;Iter1 ++ )
         cout &lt;&lt; *Iter1  &lt;&lt; &quot; &quot;;
      cout &lt;&lt; &quot;).&quot; &lt;&lt; endl;
      iii++;
   }
}
"><span class="hljs-comment">// alg_next_perm.cpp</span>
<span class="hljs-comment">// compile with: /EHsc</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;deque&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;ostream&gt;</span></span>

<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CInt</span>;</span>
ostream&amp; <span class="hljs-keyword">operator</span>&lt;&lt;( ostream&amp; osIn, <span class="hljs-keyword">const</span> CInt&amp; rhs );

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CInt</span>
{</span>
<span class="hljs-keyword">public</span>:
   CInt( <span class="hljs-keyword">int</span> n = <span class="hljs-number">0</span> ) : m_nVal( n ){}
   CInt( <span class="hljs-keyword">const</span> CInt&amp; rhs ) : m_nVal( rhs.m_nVal ){}
   CInt&amp;   <span class="hljs-keyword">operator</span>=( <span class="hljs-keyword">const</span> CInt&amp; rhs ) {m_nVal =
   rhs.m_nVal; <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;}
   <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>&lt;( <span class="hljs-keyword">const</span> CInt&amp; rhs ) <span class="hljs-keyword">const</span>
      { <span class="hljs-keyword">return</span> ( m_nVal &lt; rhs.m_nVal );}
   <span class="hljs-keyword">friend</span>   ostream&amp; <span class="hljs-keyword">operator</span>&lt;&lt;( ostream&amp; osIn, <span class="hljs-keyword">const</span> CInt&amp; rhs );

<span class="hljs-keyword">private</span>:
   <span class="hljs-keyword">int</span> m_nVal;
};

<span class="hljs-keyword">inline</span> ostream&amp; <span class="hljs-keyword">operator</span>&lt;&lt;( ostream&amp; osIn, <span class="hljs-keyword">const</span> CInt&amp; rhs )
{
   osIn &lt;&lt; <span class="hljs-string">"CInt( "</span> &lt;&lt; rhs.m_nVal &lt;&lt; <span class="hljs-string">" )"</span>;
   <span class="hljs-keyword">return</span> osIn;
}

<span class="hljs-comment">// Return whether modulus of elem1 is less than modulus of elem2</span>
<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">mod_lesser</span> <span class="hljs-params">( <span class="hljs-keyword">int</span> elem1, <span class="hljs-keyword">int</span> elem2 )</span>
</span>{
   <span class="hljs-keyword">if</span> ( elem1 &lt; <span class="hljs-number">0</span> )
      elem1 = - elem1;
   <span class="hljs-keyword">if</span> ( elem2 &lt; <span class="hljs-number">0</span> )
      elem2 = - elem2;
   <span class="hljs-keyword">return</span> elem1 &lt; elem2;
};

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
   <span class="hljs-comment">// Reordering the elements of type CInt in a deque</span>
   <span class="hljs-comment">// using the prev_permutation algorithm</span>
   CInt c1 = <span class="hljs-number">5</span>, c2 = <span class="hljs-number">1</span>, c3 = <span class="hljs-number">10</span>;
   <span class="hljs-keyword">bool</span> deq1Result;
   <span class="hljs-built_in">deque</span>&lt;CInt&gt; deq1, deq2, deq3;
   <span class="hljs-built_in">deque</span>&lt;CInt&gt;::iterator d1_Iter;

   deq1.push_back ( c1 );
   deq1.push_back ( c2 );
   deq1.push_back ( c3 );

   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"The original deque of CInts is deq1 = ("</span>;
   <span class="hljs-keyword">for</span> ( d1_Iter = deq1.begin( ); d1_Iter != --deq1.end( ); d1_Iter++ )
      <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">" "</span> &lt;&lt; *d1_Iter &lt;&lt; <span class="hljs-string">","</span>;
   d1_Iter = --deq1.end( );
   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">" "</span> &lt;&lt; *d1_Iter &lt;&lt; <span class="hljs-string">" )."</span> &lt;&lt; <span class="hljs-built_in">endl</span>;

   deq1Result = next_permutation ( deq1.begin( ), deq1.end( ) );

   <span class="hljs-keyword">if</span> ( deq1Result )
      <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"The lexicographically next permutation "</span>
           &lt;&lt; <span class="hljs-string">"exists and has\nreplaced the original "</span>
           &lt;&lt; <span class="hljs-string">"ordering of the sequence in deq1."</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
   <span class="hljs-keyword">else</span>
      <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"The lexicographically next permutation doesn't "</span>
           &lt;&lt; <span class="hljs-string">"exist\n and the lexicographically "</span>
           &lt;&lt; <span class="hljs-string">"smallest permutation\n has replaced the "</span>
           &lt;&lt; <span class="hljs-string">"original ordering of the sequence in deq1."</span> &lt;&lt; <span class="hljs-built_in">endl</span>;

   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"After one application of next_permutation,\n deq1 = ("</span>;
   <span class="hljs-keyword">for</span> ( d1_Iter = deq1.begin( ); d1_Iter != --deq1.end( ); d1_Iter++ )
      <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">" "</span> &lt;&lt; *d1_Iter &lt;&lt; <span class="hljs-string">","</span>;
   d1_Iter = --deq1.end( );
   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">" "</span> &lt;&lt; *d1_Iter &lt;&lt; <span class="hljs-string">" )."</span> &lt;&lt; <span class="hljs-built_in">endl</span> &lt;&lt; <span class="hljs-built_in">endl</span>;

   <span class="hljs-comment">// Permuting vector elements with binary function mod_lesser</span>
   <span class="hljs-built_in">vector</span> &lt;<span class="hljs-keyword">int</span>&gt; v1;
   <span class="hljs-built_in">vector</span> &lt;<span class="hljs-keyword">int</span>&gt;::iterator Iter1;

   <span class="hljs-keyword">int</span> i;
   <span class="hljs-keyword">for</span> ( i = <span class="hljs-number">-3</span> ; i &lt;= <span class="hljs-number">3</span> ; i++ )
   {
      v1.push_back( i );
   }

   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Vector v1 is ( "</span> ;
   <span class="hljs-keyword">for</span> ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ; Iter1++ )
      <span class="hljs-built_in">cout</span> &lt;&lt; *Iter1 &lt;&lt; <span class="hljs-string">" "</span>;
   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">")."</span> &lt;&lt; <span class="hljs-built_in">endl</span>;

   next_permutation ( v1.begin( ), v1.end( ), mod_lesser );

   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"After the first next_permutation, vector v1 is:\n v1 = ( "</span> ;
   <span class="hljs-keyword">for</span> ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ; Iter1++ )
      <span class="hljs-built_in">cout</span> &lt;&lt; *Iter1 &lt;&lt; <span class="hljs-string">" "</span>;
   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">")."</span> &lt;&lt; <span class="hljs-built_in">endl</span>;

   <span class="hljs-keyword">int</span> iii = <span class="hljs-number">1</span>;
   <span class="hljs-keyword">while</span> ( iii &lt;= <span class="hljs-number">5</span> ) {
      next_permutation ( v1.begin( ), v1.end( ), mod_lesser );
      <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"After another next_permutation of vector v1,\n v1 =   ( "</span> ;
      <span class="hljs-keyword">for</span> ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ;Iter1 ++ )
         <span class="hljs-built_in">cout</span> &lt;&lt; *Iter1  &lt;&lt; <span class="hljs-string">" "</span>;
      <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">")."</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
      iii++;
   }
}
</code></pre>
<div class="codeHeader" id="code-try-91" data-bi-name="code-header"><span class="language">Output</span>
			<button class="action" data-bi-name="copy">
				<span class="docon docon-edit-copy" role="presentation"></span>
				<span>Copy</span>
			</button></div><pre><code class="lang-Output" data-author-content="The original deque of CInts is deq1 = ( CInt( 5 ), CInt( 1 ), CInt( 10 ) ).
The lexicographically next permutation exists and has
replaced the original ordering of the sequence in deq1.
After one application of next_permutation,
deq1 = ( CInt( 5 ), CInt( 10 ), CInt( 1 ) ).

Vector v1 is ( -3 -2 -1 0 1 2 3 ).
After the first next_permutation, vector v1 is:
v1 = ( -3 -2 -1 0 1 3 2 ).
After another next_permutation of vector v1,
v1 =   ( -3 -2 -1 0 2 1 3 ).
After another next_permutation of vector v1,
v1 =   ( -3 -2 -1 0 2 3 1 ).
After another next_permutation of vector v1,
v1 =   ( -3 -2 -1 0 3 1 2 ).
After another next_permutation of vector v1,
v1 =   ( -3 -2 -1 0 3 2 1 ).
After another next_permutation of vector v1,
v1 =   ( -3 -2 -1 1 0 2 3 ).
">The original deque of CInts is deq1 = ( CInt( 5 ), CInt( 1 ), CInt( 10 ) ).
The lexicographically next permutation exists and has
replaced the original ordering of the sequence in deq1.
After one application of next_permutation,
deq1 = ( CInt( 5 ), CInt( 10 ), CInt( 1 ) ).

Vector v1 is ( -3 -2 -1 0 1 2 3 ).
After the first next_permutation, vector v1 is:
v1 = ( -3 -2 -1 0 1 3 2 ).
After another next_permutation of vector v1,
v1 =   ( -3 -2 -1 0 2 1 3 ).
After another next_permutation of vector v1,
v1 =   ( -3 -2 -1 0 2 3 1 ).
After another next_permutation of vector v1,
v1 =   ( -3 -2 -1 0 3 1 2 ).
After another next_permutation of vector v1,
v1 =   ( -3 -2 -1 0 3 2 1 ).
After another next_permutation of vector v1,
v1 =   ( -3 -2 -1 1 0 2 3 ).
</code></pre>
<h2 id="nth_element" class="heading-with-anchor">  nth_element<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#nth_element"></a></h2>
<p>Partitions a range of elements, correctly locating the                 <em>n</em>th element of the sequence in the range so that all the elements in front of it are less than or equal to it and all the elements that follow it in the sequence are greater than or equal to it.</p>
<div class="codeHeader" id="code-try-92" data-bi-name="code-header"><span class="language">C++</span>
			<button class="action" data-bi-name="copy">
				<span class="docon docon-edit-copy" role="presentation"></span>
				<span>Copy</span>
			</button></div><pre><code class="lang-cpp" data-author-content="template&lt;class RandomAccessIterator&gt;
void nth_element( RandomAccessIterator first, RandomAccessIterator _Nth, RandomAccessIterator last);

template&lt;class RandomAccessIterator, class BinaryPredicate&gt;
void nth_element( RandomAccessIterator first, RandomAccessIterator _Nth, RandomAccessIterator last, BinaryPredicate comp);
"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RandomAccessIterator</span>&gt;
<span class="hljs-title">void</span> <span class="hljs-title">nth_element</span>( <span class="hljs-title">RandomAccessIterator</span> <span class="hljs-title">first</span>, <span class="hljs-title">RandomAccessIterator</span> _<span class="hljs-title">Nth</span>, <span class="hljs-title">RandomAccessIterator</span> <span class="hljs-title">last</span>);</span>

<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RandomAccessIterator</span>, <span class="hljs-title">class</span> <span class="hljs-title">BinaryPredicate</span>&gt;
<span class="hljs-title">void</span> <span class="hljs-title">nth_element</span>( <span class="hljs-title">RandomAccessIterator</span> <span class="hljs-title">first</span>, <span class="hljs-title">RandomAccessIterator</span> _<span class="hljs-title">Nth</span>, <span class="hljs-title">RandomAccessIterator</span> <span class="hljs-title">last</span>, <span class="hljs-title">BinaryPredicate</span> <span class="hljs-title">comp</span>);</span>
</code></pre>
<h3 id="parameters-45" class="heading-with-anchor">Parameters<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#parameters-45"></a></h3>
<p><em>first</em><br>
A random-access iterator addressing the position of the first element in the range to be partitioned.</p>
<p><em>_Nth</em><br>
A random-access iterator addressing the position of element to be correctly ordered on the boundary of the partition.</p>
<p><em>last</em><br>
A random-access iterator addressing the position one past the final element in the range to be partitioned.</p>
<p><em>comp</em><br>
User-defined predicate function object that defines the comparison criterion to be satisfied by successive elements in the ordering. A binary predicate takes two arguments and returns <strong>true</strong> when satisfied and <strong>false</strong> when not satisfied.</p>
<h3 id="remarks-45" class="heading-with-anchor">Remarks<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#remarks-45"></a></h3>
<p>The range referenced must be valid; all pointers must be dereferenceable and within the sequence the last position is reachable from the first by incrementation.</p>
<p>The <code>nth_element</code> algorithm does not guarantee that elements in the sub-ranges either side of the  <em>n</em>th element are sorted. It thus makes fewer guarantees than <code>partial_sort</code>, which orders the elements in the range below some chosen element, and may be used as a faster alternative to <code>partial_sort</code> when the ordering of the lower range is not required.</p>
<p>Elements are equivalent, but not necessarily equal, if neither is less than the other.</p>
<p>The average of a sort complexity is linear with respect to  * last - first*.</p>
<h3 id="example-30" class="heading-with-anchor">Example<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#example-30"></a></h3>
<div class="codeHeader" id="code-try-93" data-bi-name="code-header"><span class="language">C++</span>
			<button class="action" data-bi-name="copy">
				<span class="docon docon-edit-copy" role="presentation"></span>
				<span>Copy</span>
			</button></div><pre><code class="lang-cpp" data-author-content="// alg_nth_elem.cpp
// compile with: /EHsc
#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;functional&gt;      // For greater&lt;int&gt;( )
#include &lt;iostream&gt;

// Return whether first element is greater than the second
bool UDgreater ( int elem1, int elem2 ) {
   return elem1 &gt; elem2;
}

int main() {
   using namespace std;
   vector &lt;int&gt; v1;
   vector &lt;int&gt;::iterator Iter1;

   int i;
   for ( i = 0 ; i &lt;= 5 ; i++ )
      v1.push_back( 3 * i );

   int ii;
   for ( ii = 0 ; ii &lt;= 5 ; ii++ )
      v1.push_back( 3 * ii + 1 );

   int iii;
   for ( iii = 0 ; iii &lt;= 5 ; iii++ )
      v1.push_back( 3 * iii +2 );

   cout &lt;&lt; &quot;Original vector:\n v1 = ( &quot; ;
   for ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ; Iter1++ )
      cout &lt;&lt; *Iter1 &lt;&lt; &quot; &quot;;
   cout &lt;&lt; &quot;)&quot; &lt;&lt; endl;

   nth_element(v1.begin( ), v1.begin( ) + 3, v1.end( ) );
   cout &lt;&lt; &quot;Position 3 partitioned vector:\n v1 = ( &quot; ;
   for ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ; Iter1++ )
      cout &lt;&lt; *Iter1 &lt;&lt; &quot; &quot;;
   cout &lt;&lt; &quot;)&quot; &lt;&lt; endl;

   // To sort in descending order, specify binary predicate
   nth_element( v1.begin( ), v1.begin( ) + 4, v1.end( ),
          greater&lt;int&gt;( ) );
   cout &lt;&lt; &quot;Position 4 partitioned (greater) vector:\n v1 = ( &quot; ;
   for ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ; Iter1++ )
      cout &lt;&lt; *Iter1 &lt;&lt; &quot; &quot;;
   cout &lt;&lt; &quot;)&quot; &lt;&lt; endl;

   random_shuffle( v1.begin( ), v1.end( ) );
   cout &lt;&lt; &quot;Shuffled vector:\n v1 = ( &quot; ;
   for ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ; Iter1++ )
      cout &lt;&lt; *Iter1 &lt;&lt; &quot; &quot;;
   cout &lt;&lt; &quot;)&quot; &lt;&lt; endl;

   // A user-defined (UD) binary predicate can also be used
   nth_element( v1.begin( ), v1.begin( ) + 5, v1.end( ), UDgreater );
   cout &lt;&lt; &quot;Position 5 partitioned (UDgreater) vector:\n v1 = ( &quot; ;
   for ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ; Iter1++ )
      cout &lt;&lt; *Iter1 &lt;&lt; &quot; &quot;;
   cout &lt;&lt; &quot;)&quot; &lt;&lt; endl;
}
"><span class="hljs-comment">// alg_nth_elem.cpp</span>
<span class="hljs-comment">// compile with: /EHsc</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;functional&gt;      // For greater&lt;int&gt;( )</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span>

<span class="hljs-comment">// Return whether first element is greater than the second</span>
<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">UDgreater</span> <span class="hljs-params">( <span class="hljs-keyword">int</span> elem1, <span class="hljs-keyword">int</span> elem2 )</span> </span>{
   <span class="hljs-keyword">return</span> elem1 &gt; elem2;
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
   <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;
   <span class="hljs-built_in">vector</span> &lt;<span class="hljs-keyword">int</span>&gt; v1;
   <span class="hljs-built_in">vector</span> &lt;<span class="hljs-keyword">int</span>&gt;::iterator Iter1;

   <span class="hljs-keyword">int</span> i;
   <span class="hljs-keyword">for</span> ( i = <span class="hljs-number">0</span> ; i &lt;= <span class="hljs-number">5</span> ; i++ )
      v1.push_back( <span class="hljs-number">3</span> * i );

   <span class="hljs-keyword">int</span> ii;
   <span class="hljs-keyword">for</span> ( ii = <span class="hljs-number">0</span> ; ii &lt;= <span class="hljs-number">5</span> ; ii++ )
      v1.push_back( <span class="hljs-number">3</span> * ii + <span class="hljs-number">1</span> );

   <span class="hljs-keyword">int</span> iii;
   <span class="hljs-keyword">for</span> ( iii = <span class="hljs-number">0</span> ; iii &lt;= <span class="hljs-number">5</span> ; iii++ )
      v1.push_back( <span class="hljs-number">3</span> * iii +<span class="hljs-number">2</span> );

   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Original vector:\n v1 = ( "</span> ;
   <span class="hljs-keyword">for</span> ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ; Iter1++ )
      <span class="hljs-built_in">cout</span> &lt;&lt; *Iter1 &lt;&lt; <span class="hljs-string">" "</span>;
   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">")"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;

   nth_element(v1.begin( ), v1.begin( ) + <span class="hljs-number">3</span>, v1.end( ) );
   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Position 3 partitioned vector:\n v1 = ( "</span> ;
   <span class="hljs-keyword">for</span> ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ; Iter1++ )
      <span class="hljs-built_in">cout</span> &lt;&lt; *Iter1 &lt;&lt; <span class="hljs-string">" "</span>;
   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">")"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;

   <span class="hljs-comment">// To sort in descending order, specify binary predicate</span>
   nth_element( v1.begin( ), v1.begin( ) + <span class="hljs-number">4</span>, v1.end( ),
          greater&lt;<span class="hljs-keyword">int</span>&gt;( ) );
   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Position 4 partitioned (greater) vector:\n v1 = ( "</span> ;
   <span class="hljs-keyword">for</span> ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ; Iter1++ )
      <span class="hljs-built_in">cout</span> &lt;&lt; *Iter1 &lt;&lt; <span class="hljs-string">" "</span>;
   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">")"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;

   random_shuffle( v1.begin( ), v1.end( ) );
   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Shuffled vector:\n v1 = ( "</span> ;
   <span class="hljs-keyword">for</span> ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ; Iter1++ )
      <span class="hljs-built_in">cout</span> &lt;&lt; *Iter1 &lt;&lt; <span class="hljs-string">" "</span>;
   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">")"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;

   <span class="hljs-comment">// A user-defined (UD) binary predicate can also be used</span>
   nth_element( v1.begin( ), v1.begin( ) + <span class="hljs-number">5</span>, v1.end( ), UDgreater );
   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Position 5 partitioned (UDgreater) vector:\n v1 = ( "</span> ;
   <span class="hljs-keyword">for</span> ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ; Iter1++ )
      <span class="hljs-built_in">cout</span> &lt;&lt; *Iter1 &lt;&lt; <span class="hljs-string">" "</span>;
   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">")"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
}
</code></pre>
<h2 id="none_of" class="heading-with-anchor">  none_of<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#none_of"></a></h2>
<p>Returns <strong>true</strong> when a condition is never present among elements in the given range.</p>
<div class="codeHeader" id="code-try-94" data-bi-name="code-header"><span class="language">C++</span>
			<button class="action" data-bi-name="copy">
				<span class="docon docon-edit-copy" role="presentation"></span>
				<span>Copy</span>
			</button></div><pre><code class="lang-cpp" data-author-content="template&lt;class InputIterator, class BinaryPredicate&gt;
bool none_of(InputIterator first, InputIterator last, BinaryPredicate comp);
"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InputIterator</span>, <span class="hljs-title">class</span> <span class="hljs-title">BinaryPredicate</span>&gt;
<span class="hljs-title">bool</span> <span class="hljs-title">none_of</span>(<span class="hljs-title">InputIterator</span> <span class="hljs-title">first</span>, <span class="hljs-title">InputIterator</span> <span class="hljs-title">last</span>, <span class="hljs-title">BinaryPredicate</span> <span class="hljs-title">comp</span>);</span>
</code></pre>
<h3 id="parameters-46" class="heading-with-anchor">Parameters<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#parameters-46"></a></h3>
<p><em>first</em><br>
An input iterator that indicates where to start to check a range of elements for a condition.</p>
<p><em>last</em><br>
An input iterator that indicates the end of a range of elements.</p>
<p><em>comp</em><br>
The condition to test for. This is provided by a user-defined predicate function object that defines the condition. A predicate takes a single argument and returns <strong>true</strong> or <strong>false</strong>.</p>
<h3 id="return-value-35" class="heading-with-anchor">Return Value<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#return-value-35"></a></h3>
<p>Returns <strong>true</strong> if the condition is not detected at least once in the indicated range, and <strong>false</strong> if the condition is detected.</p>
<h3 id="remarks-46" class="heading-with-anchor">Remarks<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#remarks-46"></a></h3>
<p>The template function returns <strong>true</strong> only if, for some <code>N</code> in the range <code>[0, last - first)</code>, the predicate <code>comp(*(first + N))</code> is always <strong>false</strong>.</p>
<h2 id="partial_sort" class="heading-with-anchor">  partial_sort<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#partial_sort"></a></h2>
<p>Arranges a specified number of the smaller elements in a range into a nondescending order or according to an ordering criterion specified by a binary predicate.</p>
<div class="codeHeader" id="code-try-95" data-bi-name="code-header"><span class="language">C++</span>
			<button class="action" data-bi-name="copy">
				<span class="docon docon-edit-copy" role="presentation"></span>
				<span>Copy</span>
			</button></div><pre><code class="lang-cpp" data-author-content="template&lt;class RandomAccessIterator&gt;
void partial_sort(
    RandomAccessIterator first,
    RandomAccessIterator sortEnd,
    RandomAccessIterator last);

template&lt;class RandomAccessIterator, class BinaryPredicate&gt;
void partial_sort(
    RandomAccessIterator first,
    RandomAccessIterator sortEnd,
    RandomAccessIterator last
    BinaryPredicate comp);
"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RandomAccessIterator</span>&gt;
<span class="hljs-title">void</span> <span class="hljs-title">partial_sort</span>(
    <span class="hljs-title">RandomAccessIterator</span> <span class="hljs-title">first</span>,
    <span class="hljs-title">RandomAccessIterator</span> <span class="hljs-title">sortEnd</span>,
    <span class="hljs-title">RandomAccessIterator</span> <span class="hljs-title">last</span>);</span>

<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RandomAccessIterator</span>, <span class="hljs-title">class</span> <span class="hljs-title">BinaryPredicate</span>&gt;
<span class="hljs-title">void</span> <span class="hljs-title">partial_sort</span>(
    <span class="hljs-title">RandomAccessIterator</span> <span class="hljs-title">first</span>,
    <span class="hljs-title">RandomAccessIterator</span> <span class="hljs-title">sortEnd</span>,
    <span class="hljs-title">RandomAccessIterator</span> <span class="hljs-title">last</span>
    <span class="hljs-title">BinaryPredicate</span> <span class="hljs-title">comp</span>);</span>
</code></pre>
<h3 id="parameters-47" class="heading-with-anchor">Parameters<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#parameters-47"></a></h3>
<p><em>first</em><br>
A random-access iterator addressing the position of the first element in the range to be sorted.</p>
<p><em>sortEnd</em><br>
A random-access iterator addressing the position one past the final element in the subrange to be sorted.</p>
<p><em>last</em><br>
A random-access iterator addressing the position one past the final element in the range to be partially sorted.</p>
<p><em>comp</em><br>
User-defined predicate function object that defines the comparison criterion to be satisfied by successive elements in the ordering. A binary predicate takes two arguments and returns <strong>true</strong> when satisfied and <strong>false</strong> when not satisfied.</p>
<h3 id="remarks-47" class="heading-with-anchor">Remarks<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#remarks-47"></a></h3>
<p>The range referenced must be valid; all pointers must be dereferenceable and within the sequence the last position is reachable from the first by incrementation.</p>
<p>Elements are equivalent, but not necessarily equal, if neither is less than the other. The <code>sort</code> algorithm is not stable and does not guarantee that the relative ordering of equivalent elements will be preserved. The algorithm <code>stable_sort</code> does preserve this original ordering.</p>
<p>The average partial sort complexity is  <em>O</em>((<code>last</code>- <code>first</code>) log (<code>sortEnd</code>- <code>first</code>)).</p>
<h3 id="example-31" class="heading-with-anchor">Example<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#example-31"></a></h3>
<div class="codeHeader" id="code-try-96" data-bi-name="code-header"><span class="language">C++</span>
			<button class="action" data-bi-name="copy">
				<span class="docon docon-edit-copy" role="presentation"></span>
				<span>Copy</span>
			</button></div><pre><code class="lang-cpp" data-author-content="// alg_partial_sort.cpp
// compile with: /EHsc
#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;functional&gt;      // For greater&lt;int&gt;( )
#include &lt;iostream&gt;

// Return whether first element is greater than the second
bool UDgreater ( int elem1, int elem2 )
{
   return elem1 &gt; elem2;
}

int main()
{
   using namespace std;
   vector &lt;int&gt; v1;
   vector &lt;int&gt;::iterator Iter1;

   int i;
   for ( i = 0 ; i &lt;= 5 ; i++ )
   {
      v1.push_back( 2 * i );
   }

   int ii;
   for ( ii = 0 ; ii &lt;= 5 ; ii++ )
   {
      v1.push_back( 2 * ii +1 );
   }

   cout &lt;&lt; &quot;Original vector:\n v1 = ( &quot; ;
   for ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ; Iter1++ )
      cout &lt;&lt; *Iter1 &lt;&lt; &quot; &quot;;
   cout &lt;&lt; &quot;)&quot; &lt;&lt; endl;

   partial_sort(v1.begin( ), v1.begin( ) + 6, v1.end( ) );
   cout &lt;&lt; &quot;Partially sorted vector:\n v1 = ( &quot; ;
   for ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ; Iter1++ )
      cout &lt;&lt; *Iter1 &lt;&lt; &quot; &quot;;
   cout &lt;&lt; &quot;)&quot; &lt;&lt; endl;

   // To partially sort in descending order, specify binary predicate
   partial_sort(v1.begin( ), v1.begin( ) + 4, v1.end( ), greater&lt;int&gt;( ) );
   cout &lt;&lt; &quot;Partially resorted (greater) vector:\n v1 = ( &quot; ;
   for ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ; Iter1++ )
      cout &lt;&lt; *Iter1 &lt;&lt; &quot; &quot;;
   cout &lt;&lt; &quot;)&quot; &lt;&lt; endl;

   // A user-defined (UD) binary predicate can also be used
   partial_sort(v1.begin( ), v1.begin( ) + 8, v1.end( ),
UDgreater );
   cout &lt;&lt; &quot;Partially resorted (UDgreater) vector:\n v1 = ( &quot; ;
   for ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ; Iter1++ )
      cout &lt;&lt; *Iter1 &lt;&lt; &quot; &quot;;
   cout &lt;&lt; &quot;)&quot; &lt;&lt; endl;
}
"><span class="hljs-comment">// alg_partial_sort.cpp</span>
<span class="hljs-comment">// compile with: /EHsc</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;functional&gt;      // For greater&lt;int&gt;( )</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span>

<span class="hljs-comment">// Return whether first element is greater than the second</span>
<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">UDgreater</span> <span class="hljs-params">( <span class="hljs-keyword">int</span> elem1, <span class="hljs-keyword">int</span> elem2 )</span>
</span>{
   <span class="hljs-keyword">return</span> elem1 &gt; elem2;
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
   <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;
   <span class="hljs-built_in">vector</span> &lt;<span class="hljs-keyword">int</span>&gt; v1;
   <span class="hljs-built_in">vector</span> &lt;<span class="hljs-keyword">int</span>&gt;::iterator Iter1;

   <span class="hljs-keyword">int</span> i;
   <span class="hljs-keyword">for</span> ( i = <span class="hljs-number">0</span> ; i &lt;= <span class="hljs-number">5</span> ; i++ )
   {
      v1.push_back( <span class="hljs-number">2</span> * i );
   }

   <span class="hljs-keyword">int</span> ii;
   <span class="hljs-keyword">for</span> ( ii = <span class="hljs-number">0</span> ; ii &lt;= <span class="hljs-number">5</span> ; ii++ )
   {
      v1.push_back( <span class="hljs-number">2</span> * ii +<span class="hljs-number">1</span> );
   }

   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Original vector:\n v1 = ( "</span> ;
   <span class="hljs-keyword">for</span> ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ; Iter1++ )
      <span class="hljs-built_in">cout</span> &lt;&lt; *Iter1 &lt;&lt; <span class="hljs-string">" "</span>;
   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">")"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;

   partial_sort(v1.begin( ), v1.begin( ) + <span class="hljs-number">6</span>, v1.end( ) );
   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Partially sorted vector:\n v1 = ( "</span> ;
   <span class="hljs-keyword">for</span> ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ; Iter1++ )
      <span class="hljs-built_in">cout</span> &lt;&lt; *Iter1 &lt;&lt; <span class="hljs-string">" "</span>;
   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">")"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;

   <span class="hljs-comment">// To partially sort in descending order, specify binary predicate</span>
   partial_sort(v1.begin( ), v1.begin( ) + <span class="hljs-number">4</span>, v1.end( ), greater&lt;<span class="hljs-keyword">int</span>&gt;( ) );
   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Partially resorted (greater) vector:\n v1 = ( "</span> ;
   <span class="hljs-keyword">for</span> ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ; Iter1++ )
      <span class="hljs-built_in">cout</span> &lt;&lt; *Iter1 &lt;&lt; <span class="hljs-string">" "</span>;
   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">")"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;

   <span class="hljs-comment">// A user-defined (UD) binary predicate can also be used</span>
   partial_sort(v1.begin( ), v1.begin( ) + <span class="hljs-number">8</span>, v1.end( ),
UDgreater );
   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Partially resorted (UDgreater) vector:\n v1 = ( "</span> ;
   <span class="hljs-keyword">for</span> ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ; Iter1++ )
      <span class="hljs-built_in">cout</span> &lt;&lt; *Iter1 &lt;&lt; <span class="hljs-string">" "</span>;
   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">")"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
}
</code></pre>
<div class="codeHeader" id="code-try-97" data-bi-name="code-header"><span class="language">Output</span>
			<button class="action" data-bi-name="copy">
				<span class="docon docon-edit-copy" role="presentation"></span>
				<span>Copy</span>
			</button></div><pre><code class="lang-Output" data-author-content="Original vector:
v1 = ( 0 2 4 6 8 10 1 3 5 7 9 11 )
Partially sorted vector:
v1 = ( 0 1 2 3 4 5 10 8 6 7 9 11 )
Partially resorted (greater) vector:
v1 = ( 11 10 9 8 0 1 2 3 4 5 6 7 )
Partially resorted (UDgreater) vector:
v1 = ( 11 10 9 8 7 6 5 4 0 1 2 3 )
">Original vector:
v1 = ( 0 2 4 6 8 10 1 3 5 7 9 11 )
Partially sorted vector:
v1 = ( 0 1 2 3 4 5 10 8 6 7 9 11 )
Partially resorted (greater) vector:
v1 = ( 11 10 9 8 0 1 2 3 4 5 6 7 )
Partially resorted (UDgreater) vector:
v1 = ( 11 10 9 8 7 6 5 4 0 1 2 3 )
</code></pre>
<h2 id="partial_sort_copy" class="heading-with-anchor">  partial_sort_copy<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#partial_sort_copy"></a></h2>
<p>Copies elements from a source range into a destination range where the source elements are ordered by either less than or another specified binary predicate.</p>
<div class="codeHeader" id="code-try-98" data-bi-name="code-header"><span class="language">C++</span>
			<button class="action" data-bi-name="copy">
				<span class="docon docon-edit-copy" role="presentation"></span>
				<span>Copy</span>
			</button></div><pre><code class="lang-cpp" data-author-content="template&lt;class InputIterator, class RandomAccessIterator&gt;
RandomAccessIterator partial_sort_copy(
    InputIterator first1,
    InputIterator last1,
    RandomAccessIterator first2,
    RandomAccessIterator last2 );

template&lt;class InputIterator, class RandomAccessIterator, class BinaryPredicate&gt;
RandomAccessIterator partial_sort_copy(
    InputIterator first1,
    InputIterator last1,
    RandomAccessIterator first2,
    RandomAccessIterator last2,
    BinaryPredicate comp);
"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InputIterator</span>, <span class="hljs-title">class</span> <span class="hljs-title">RandomAccessIterator</span>&gt;
<span class="hljs-title">RandomAccessIterator</span> <span class="hljs-title">partial_sort_copy</span>(
    <span class="hljs-title">InputIterator</span> <span class="hljs-title">first1</span>,
    <span class="hljs-title">InputIterator</span> <span class="hljs-title">last1</span>,
    <span class="hljs-title">RandomAccessIterator</span> <span class="hljs-title">first2</span>,
    <span class="hljs-title">RandomAccessIterator</span> <span class="hljs-title">last2</span> );</span>

<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InputIterator</span>, <span class="hljs-title">class</span> <span class="hljs-title">RandomAccessIterator</span>, <span class="hljs-title">class</span> <span class="hljs-title">BinaryPredicate</span>&gt;
<span class="hljs-title">RandomAccessIterator</span> <span class="hljs-title">partial_sort_copy</span>(
    <span class="hljs-title">InputIterator</span> <span class="hljs-title">first1</span>,
    <span class="hljs-title">InputIterator</span> <span class="hljs-title">last1</span>,
    <span class="hljs-title">RandomAccessIterator</span> <span class="hljs-title">first2</span>,
    <span class="hljs-title">RandomAccessIterator</span> <span class="hljs-title">last2</span>,
    <span class="hljs-title">BinaryPredicate</span> <span class="hljs-title">comp</span>);</span>
</code></pre>
<h3 id="parameters-48" class="heading-with-anchor">Parameters<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#parameters-48"></a></h3>
<p><em>first1</em><br>
An input iterator addressing the position of the first element in the source range.</p>
<p><em>last1</em><br>
An input iterator addressing the position one past the final element in the source range.</p>
<p><em>first2</em><br>
A random-access iterator addressing the position of the first element in the sorted destination range.</p>
<p><em>last2</em><br>
A random-access iterator addressing the position one past the final element in the sorted destination range.</p>
<p><em>comp</em><br>
User-defined predicate function object that defines the condition to be satisfied if two elements are to be taken as equivalent. A binary predicate takes two arguments and returns <strong>true</strong> when satisfied and <strong>false</strong> when not satisfied.</p>
<h3 id="return-value-36" class="heading-with-anchor">Return Value<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#return-value-36"></a></h3>
<p>A random-access iterator addressing the element in the destination range one position beyond the last element inserted from the source range.</p>
<h3 id="remarks-48" class="heading-with-anchor">Remarks<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#remarks-48"></a></h3>
<p>The source and destination ranges must not overlap and must be valid; all pointers must be dereferenceable and within each sequence the last position must be reachable from the first by incrementation.</p>
<p>The binary predicate must provide a strict weak ordering so that elements that are not equivalent are ordered, but elements that are equivalent are not. Two elements are equivalent under less than, but not necessarily equal, if neither is less than the other.</p>
<h3 id="example-32" class="heading-with-anchor">Example<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#example-32"></a></h3>
<div class="codeHeader" id="code-try-99" data-bi-name="code-header"><span class="language">C++</span>
			<button class="action" data-bi-name="copy">
				<span class="docon docon-edit-copy" role="presentation"></span>
				<span>Copy</span>
			</button></div><pre><code class="lang-cpp" data-author-content="// alg_partial_sort_copy.cpp
// compile with: /EHsc
#include &lt;vector&gt;
#include &lt;list&gt;
#include &lt;algorithm&gt;
#include &lt;functional&gt;
#include &lt;iostream&gt;

int main() {
    using namespace std;
    vector&lt;int&gt; v1, v2;
    list&lt;int&gt; list1;
    vector&lt;int&gt;::iterator iter1, iter2;
    list&lt;int&gt;::iterator list1_Iter, list1_inIter;

    int i;
    for (i = 0; i &lt;= 9; i++)
        v1.push_back(i);

    random_shuffle(v1.begin(), v1.end());

    list1.push_back(60);
    list1.push_back(50);
    list1.push_back(20);
    list1.push_back(30);
    list1.push_back(40);
    list1.push_back(10);

    cout &lt;&lt; &quot;Vector v1 = ( &quot; ;
    for (iter1 = v1.begin(); iter1 != v1.end(); iter1++)
        cout &lt;&lt; *iter1 &lt;&lt; &quot; &quot;;
    cout &lt;&lt; &quot;)&quot; &lt;&lt; endl;

    cout &lt;&lt; &quot;List list1 = ( &quot; ;
    for (list1_Iter = list1.begin();
         list1_Iter!= list1.end();
         list1_Iter++)
        cout &lt;&lt; *list1_Iter &lt;&lt; &quot; &quot;;
    cout &lt;&lt; &quot;)&quot; &lt;&lt; endl;

    // Copying a partially sorted copy of list1 into v1
    vector&lt;int&gt;::iterator result1;
    result1 = partial_sort_copy(list1.begin(), list1.end(),
             v1.begin(), v1.begin() + 3);

    cout &lt;&lt; &quot;List list1 Vector v1 = ( &quot; ;
    for (iter1 = v1.begin() ; iter1 != v1.end() ; iter1++)
        cout &lt;&lt; *iter1 &lt;&lt; &quot; &quot;;
    cout &lt;&lt; &quot;)&quot; &lt;&lt; endl;
    cout &lt;&lt; &quot;The first v1 element one position beyond&quot;
         &lt;&lt; &quot;\n the last L 1 element inserted was &quot; &lt;&lt; *result1
         &lt;&lt; &quot;.&quot; &lt;&lt; endl;

    // Copying a partially sorted copy of list1 into v2
    int ii;
    for (ii = 0; ii &lt;= 9; ii++)
        v2.push_back(ii);

    random_shuffle(v2.begin(), v2.end());
    vector&lt;int&gt;::iterator result2;
    result2 = partial_sort_copy(list1.begin(), list1.end(),
             v2.begin(), v2.begin() + 6);

    cout &lt;&lt; &quot;List list1 into Vector v2 = ( &quot; ;
    for (iter2 = v2.begin() ; iter2 != v2.end(); iter2++)
        cout &lt;&lt; *iter2 &lt;&lt; &quot; &quot;;
    cout &lt;&lt; &quot;)&quot; &lt;&lt; endl;
    cout &lt;&lt; &quot;The first v2 element one position beyond&quot;
         &lt;&lt; &quot;\n the last L 1 element inserted was &quot; &lt;&lt; *result2
         &lt;&lt; &quot;.&quot; &lt;&lt; endl;
}
"><span class="hljs-comment">// alg_partial_sort_copy.cpp</span>
<span class="hljs-comment">// compile with: /EHsc</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;list&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;functional&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span>

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;
    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; v1, v2;
    <span class="hljs-built_in">list</span>&lt;<span class="hljs-keyword">int</span>&gt; list1;
    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;::iterator iter1, iter2;
    <span class="hljs-built_in">list</span>&lt;<span class="hljs-keyword">int</span>&gt;::iterator list1_Iter, list1_inIter;

    <span class="hljs-keyword">int</span> i;
    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">9</span>; i++)
        v1.push_back(i);

    random_shuffle(v1.begin(), v1.end());

    list1.push_back(<span class="hljs-number">60</span>);
    list1.push_back(<span class="hljs-number">50</span>);
    list1.push_back(<span class="hljs-number">20</span>);
    list1.push_back(<span class="hljs-number">30</span>);
    list1.push_back(<span class="hljs-number">40</span>);
    list1.push_back(<span class="hljs-number">10</span>);

    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Vector v1 = ( "</span> ;
    <span class="hljs-keyword">for</span> (iter1 = v1.begin(); iter1 != v1.end(); iter1++)
        <span class="hljs-built_in">cout</span> &lt;&lt; *iter1 &lt;&lt; <span class="hljs-string">" "</span>;
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">")"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;

    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"List list1 = ( "</span> ;
    <span class="hljs-keyword">for</span> (list1_Iter = list1.begin();
         list1_Iter!= list1.end();
         list1_Iter++)
        <span class="hljs-built_in">cout</span> &lt;&lt; *list1_Iter &lt;&lt; <span class="hljs-string">" "</span>;
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">")"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;

    <span class="hljs-comment">// Copying a partially sorted copy of list1 into v1</span>
    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;::iterator result1;
    result1 = partial_sort_copy(list1.begin(), list1.end(),
             v1.begin(), v1.begin() + <span class="hljs-number">3</span>);

    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"List list1 Vector v1 = ( "</span> ;
    <span class="hljs-keyword">for</span> (iter1 = v1.begin() ; iter1 != v1.end() ; iter1++)
        <span class="hljs-built_in">cout</span> &lt;&lt; *iter1 &lt;&lt; <span class="hljs-string">" "</span>;
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">")"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"The first v1 element one position beyond"</span>
         &lt;&lt; <span class="hljs-string">"\n the last L 1 element inserted was "</span> &lt;&lt; *result1
         &lt;&lt; <span class="hljs-string">"."</span> &lt;&lt; <span class="hljs-built_in">endl</span>;

    <span class="hljs-comment">// Copying a partially sorted copy of list1 into v2</span>
    <span class="hljs-keyword">int</span> ii;
    <span class="hljs-keyword">for</span> (ii = <span class="hljs-number">0</span>; ii &lt;= <span class="hljs-number">9</span>; ii++)
        v2.push_back(ii);

    random_shuffle(v2.begin(), v2.end());
    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;::iterator result2;
    result2 = partial_sort_copy(list1.begin(), list1.end(),
             v2.begin(), v2.begin() + <span class="hljs-number">6</span>);

    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"List list1 into Vector v2 = ( "</span> ;
    <span class="hljs-keyword">for</span> (iter2 = v2.begin() ; iter2 != v2.end(); iter2++)
        <span class="hljs-built_in">cout</span> &lt;&lt; *iter2 &lt;&lt; <span class="hljs-string">" "</span>;
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">")"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"The first v2 element one position beyond"</span>
         &lt;&lt; <span class="hljs-string">"\n the last L 1 element inserted was "</span> &lt;&lt; *result2
         &lt;&lt; <span class="hljs-string">"."</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
}
</code></pre>
<h2 id="partition" class="heading-with-anchor">  partition<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#partition"></a></h2>
<p>Classifies elements in a range into two disjoint sets, with those elements satisfying a unary predicate preceding those that fail to satisfy it.</p>
<div class="codeHeader" id="code-try-100" data-bi-name="code-header"><span class="language">C++</span>
			<button class="action" data-bi-name="copy">
				<span class="docon docon-edit-copy" role="presentation"></span>
				<span>Copy</span>
			</button></div><pre><code class="lang-cpp" data-author-content="template&lt;class BidirectionalIterator, class Predicate&gt;
BidirectionalIterator partition(
    BidirectionalIterator first,
    BidirectionalIterator last,
    Predicate comp);
"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BidirectionalIterator</span>, <span class="hljs-title">class</span> <span class="hljs-title">Predicate</span>&gt;
<span class="hljs-title">BidirectionalIterator</span> <span class="hljs-title">partition</span>(
    <span class="hljs-title">BidirectionalIterator</span> <span class="hljs-title">first</span>,
    <span class="hljs-title">BidirectionalIterator</span> <span class="hljs-title">last</span>,
    <span class="hljs-title">Predicate</span> <span class="hljs-title">comp</span>);</span>
</code></pre>
<h3 id="parameters-49" class="heading-with-anchor">Parameters<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#parameters-49"></a></h3>
<p><em>first</em><br>
A bidirectional iterator addressing the position of the first element in the range to be partitioned.</p>
<p><em>last</em><br>
A bidirectional iterator addressing the position one past the final element in the range to be partitioned.</p>
<p><em>comp</em><br>
User-defined predicate function object that defines the condition to be satisfied if an element is to be classified. A predicate takes a single argument and returns <strong>true</strong> or <strong>false</strong>.</p>
<h3 id="return-value-37" class="heading-with-anchor">Return Value<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#return-value-37"></a></h3>
<p>A bidirectional iterator addressing the position of the first element in the range to not satisfy the predicate condition.</p>
<h3 id="remarks-49" class="heading-with-anchor">Remarks<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#remarks-49"></a></h3>
<p>The range referenced must be valid; all pointers must be dereferenceable and within the sequence the last position is reachable from the first by incrementation.</p>
<p>Elements  <em>a</em> and  <em>b</em> are equivalent, but not necessarily equal, if both  <em>Pr</em> ( <em>a</em>,  <em>b</em>) is false and  <em>Pr</em> ( <em>b</em>,  <em>a</em>) if false, where  <em>Pr</em> is the parameter-specified predicate. The <code>partition</code> algorithm is not stable and does not guarantee that the relative ordering of equivalent elements will be preserved. The algorithm <code>stable_ partition</code> does preserve this original ordering.</p>
<p>The complexity is linear: there are (<code>last</code> - <code>first</code>) applications of <em>comp</em> and at most (<code>last</code> - <code>first</code>)/2 swaps.</p>
<h3 id="example-33" class="heading-with-anchor">Example<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#example-33"></a></h3>
<div class="codeHeader" id="code-try-101" data-bi-name="code-header"><span class="language">C++</span>
			<button class="action" data-bi-name="copy">
				<span class="docon docon-edit-copy" role="presentation"></span>
				<span>Copy</span>
			</button></div><pre><code class="lang-cpp" data-author-content="// alg_partition.cpp
// compile with: /EHsc
#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;iostream&gt;

bool greater5 ( int value ) {
   return value &gt; 5;
}

int main() {
   using namespace std;
   vector &lt;int&gt; v1, v2;
   vector &lt;int&gt;::iterator Iter1, Iter2;

   int i;
   for ( i = 0 ; i &lt;= 10 ; i++ )
   {
      v1.push_back( i );
   }
   random_shuffle( v1.begin( ), v1.end( ) );

   cout &lt;&lt; &quot;Vector v1 is ( &quot; ;
   for ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ; Iter1++ )
      cout &lt;&lt; *Iter1 &lt;&lt; &quot; &quot;;
   cout &lt;&lt; &quot;).&quot; &lt;&lt; endl;

   // Partition the range with predicate greater10
   partition ( v1.begin( ), v1.end( ), greater5 );
   cout &lt;&lt; &quot;The partitioned set of elements in v1 is: ( &quot; ;
   for ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ; Iter1++ )
      cout &lt;&lt; *Iter1 &lt;&lt; &quot; &quot;;
   cout &lt;&lt; &quot;).&quot; &lt;&lt; endl;
}
"><span class="hljs-comment">// alg_partition.cpp</span>
<span class="hljs-comment">// compile with: /EHsc</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span>

<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">greater5</span> <span class="hljs-params">( <span class="hljs-keyword">int</span> value )</span> </span>{
   <span class="hljs-keyword">return</span> value &gt; <span class="hljs-number">5</span>;
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
   <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;
   <span class="hljs-built_in">vector</span> &lt;<span class="hljs-keyword">int</span>&gt; v1, v2;
   <span class="hljs-built_in">vector</span> &lt;<span class="hljs-keyword">int</span>&gt;::iterator Iter1, Iter2;

   <span class="hljs-keyword">int</span> i;
   <span class="hljs-keyword">for</span> ( i = <span class="hljs-number">0</span> ; i &lt;= <span class="hljs-number">10</span> ; i++ )
   {
      v1.push_back( i );
   }
   random_shuffle( v1.begin( ), v1.end( ) );

   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Vector v1 is ( "</span> ;
   <span class="hljs-keyword">for</span> ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ; Iter1++ )
      <span class="hljs-built_in">cout</span> &lt;&lt; *Iter1 &lt;&lt; <span class="hljs-string">" "</span>;
   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">")."</span> &lt;&lt; <span class="hljs-built_in">endl</span>;

   <span class="hljs-comment">// Partition the range with predicate greater10</span>
   partition ( v1.begin( ), v1.end( ), greater5 );
   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"The partitioned set of elements in v1 is: ( "</span> ;
   <span class="hljs-keyword">for</span> ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ; Iter1++ )
      <span class="hljs-built_in">cout</span> &lt;&lt; *Iter1 &lt;&lt; <span class="hljs-string">" "</span>;
   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">")."</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
}
</code></pre>
<h2 id="partition_copy" class="heading-with-anchor">  partition_copy<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#partition_copy"></a></h2>
<p>Copies elements for which a condition is <strong>true</strong> to one destination, and for which the condition is <strong>false</strong> to another. The elements must come from a specified range.</p>
<div class="codeHeader" id="code-try-102" data-bi-name="code-header"><span class="language">C++</span>
			<button class="action" data-bi-name="copy">
				<span class="docon docon-edit-copy" role="presentation"></span>
				<span>Copy</span>
			</button></div><pre><code class="lang-cpp" data-author-content="template&lt;class InputIterator, class OutputIterator1, class OutputIterator2, class Predicate&gt;
pair&lt;OutputIterator1, OutputIterator2&gt;
    partition_copy(
    InputIterator first,
    InputIterator last,
    OutputIterator1 dest1,
    OutputIterator2 dest2,
    Predicate pred);
"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InputIterator</span>, <span class="hljs-title">class</span> <span class="hljs-title">OutputIterator1</span>, <span class="hljs-title">class</span> <span class="hljs-title">OutputIterator2</span>, <span class="hljs-title">class</span> <span class="hljs-title">Predicate</span>&gt;
<span class="hljs-title">pair</span>&lt;OutputIterator1, OutputIterator2&gt;
    <span class="hljs-title">partition_copy</span>(
    <span class="hljs-title">InputIterator</span> <span class="hljs-title">first</span>,
    <span class="hljs-title">InputIterator</span> <span class="hljs-title">last</span>,
    <span class="hljs-title">OutputIterator1</span> <span class="hljs-title">dest1</span>,
    <span class="hljs-title">OutputIterator2</span> <span class="hljs-title">dest2</span>,
    <span class="hljs-title">Predicate</span> <span class="hljs-title">pred</span>);</span>
</code></pre>
<h3 id="parameters-50" class="heading-with-anchor">Parameters<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#parameters-50"></a></h3>
<p><em>first</em><br>
An input iterator that indicates the beginning of a range to check for a condition.</p>
<p><em>last</em><br>
An input iterator that indicates the end of a range.</p>
<p><em>dest1</em><br>
An output iterator used to copy elements that return true for a condition tested by using <em>_Pred</em>.</p>
<p><em>dest2</em><br>
An output iterator used to copy elements that return false for a condition tested by using <em>_Pred</em>.</p>
<p><em>_Pred</em><br>
The condition to test for. This is provided by a user-defined predicate function object that defines the condition to be tested. A predicate takes a single argument and returns <strong>true</strong> or <strong>false</strong>.</p>
<h3 id="remarks-50" class="heading-with-anchor">Remarks<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#remarks-50"></a></h3>
<p>The template function copies each element <code>X</code> in <code>[first,last)</code> to <code>*dest1++</code> if <code>_Pred(X)</code> is true, or to <code>*dest2++</code> if not. It returns <code>pair&lt;OutputIterator1, OutputIterator2&gt;(dest1, dest2)</code>.</p>
<h2 id="partition_point" class="heading-with-anchor">  partition_point<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#partition_point"></a></h2>
<p>Returns the first element in the given range that does not satisfy the condition. The elements are sorted so that those that satisfy the condition come before those that do not.</p>
<div class="codeHeader" id="code-try-103" data-bi-name="code-header"><span class="language">C++</span>
			<button class="action" data-bi-name="copy">
				<span class="docon docon-edit-copy" role="presentation"></span>
				<span>Copy</span>
			</button></div><pre><code class="lang-cpp" data-author-content="template&lt;class ForwardIterator, class Predicate&gt;
ForwardIterator partition_point(
    ForwardIterator first,
    ForwardIterator last,
    Predicate comp);
"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ForwardIterator</span>, <span class="hljs-title">class</span> <span class="hljs-title">Predicate</span>&gt;
<span class="hljs-title">ForwardIterator</span> <span class="hljs-title">partition_point</span>(
    <span class="hljs-title">ForwardIterator</span> <span class="hljs-title">first</span>,
    <span class="hljs-title">ForwardIterator</span> <span class="hljs-title">last</span>,
    <span class="hljs-title">Predicate</span> <span class="hljs-title">comp</span>);</span>
</code></pre>
<h3 id="parameters-51" class="heading-with-anchor">Parameters<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#parameters-51"></a></h3>
<p><em>first</em><br>
A <code>ForwardIterator</code> that indicates the start of a range to check for a condition.</p>
<p><em>last</em><br>
A <code>ForwardIterator</code> that indicates the end of a range.</p>
<p><em>comp</em><br>
The condition to test for. This is provided by a user-defined predicate function object that defines the condition to be satisfied by the element being searched for. A predicate takes a single argument and returns <strong>true</strong> or <strong>false</strong>.</p>
<h3 id="return-value-38" class="heading-with-anchor">Return Value<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#return-value-38"></a></h3>
<p>Returns a <code>ForwardIterator</code> that refers to the first element that does not fulfill the condition tested for by <em>comp</em>, or returns <em>last</em> if one is not found.</p>
<h3 id="remarks-51" class="heading-with-anchor">Remarks<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#remarks-51"></a></h3>
<p>The template function finds the first iterator <code>it</code> in <code>[first, last)</code> for which <code>comp(*it)</code> is <strong>false</strong>. The sequence must be ordered by <em>comp</em>.</p>
<h2 id="pop_heap" class="heading-with-anchor">  pop_heap<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#pop_heap"></a></h2>
<p>Removes the largest element from the front of a heap to the next-to-last position in the range and then forms a new heap from the remaining elements.</p>
<div class="codeHeader" id="code-try-104" data-bi-name="code-header"><span class="language">C++</span>
			<button class="action" data-bi-name="copy">
				<span class="docon docon-edit-copy" role="presentation"></span>
				<span>Copy</span>
			</button></div><pre><code class="lang-cpp" data-author-content="template&lt;class RandomAccessIterator&gt;
void pop_heap( RandomAccessIterator first, RandomAccessIterator last);

template&lt;class RandomAccessIterator, class BinaryPredicate&gt;
void pop_heap(RandomAccessIterator first, RandomAccessIterator last, BinaryPredicate comp);
"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RandomAccessIterator</span>&gt;
<span class="hljs-title">void</span> <span class="hljs-title">pop_heap</span>( <span class="hljs-title">RandomAccessIterator</span> <span class="hljs-title">first</span>, <span class="hljs-title">RandomAccessIterator</span> <span class="hljs-title">last</span>);</span>

<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RandomAccessIterator</span>, <span class="hljs-title">class</span> <span class="hljs-title">BinaryPredicate</span>&gt;
<span class="hljs-title">void</span> <span class="hljs-title">pop_heap</span>(<span class="hljs-title">RandomAccessIterator</span> <span class="hljs-title">first</span>, <span class="hljs-title">RandomAccessIterator</span> <span class="hljs-title">last</span>, <span class="hljs-title">BinaryPredicate</span> <span class="hljs-title">comp</span>);</span>
</code></pre>
<h3 id="parameters-52" class="heading-with-anchor">Parameters<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#parameters-52"></a></h3>
<p><em>first</em><br>
A random-access iterator addressing the position of the first element in the heap.</p>
<p><em>last</em><br>
A random-access iterator addressing the position one past the final element in the heap.</p>
<p><em>comp</em><br>
User-defined predicate function object that defines sense in which one element is less than another. A binary predicate takes two arguments and returns <strong>true</strong> when satisfied and <strong>false</strong> when not satisfied.</p>
<h3 id="remarks-52" class="heading-with-anchor">Remarks<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#remarks-52"></a></h3>
<p>The <code>pop_heap</code> algorithm is the inverse of the operation performed by the push_heap algorithm, in which an element at the next-to-last position of a range is added to a heap consisting of the prior elements in the range, in the case when the element being added to the heap is larger than any of the elements already in the heap.</p>
<p>Heaps have two properties:</p>
<ul>
<li><p>The first element is always the largest.</p>
</li>
<li><p>Elements may be added or removed in logarithmic time.</p>
</li>
</ul>
<p>Heaps are an ideal way to implement priority queues and they are used in the implementation of the C++ Standard Library container adaptor <a href="https://docs.microsoft.com/en-us/cpp/standard-library/priority-queue-class?view=vs-2019" data-linktype="relative-path">priority_queue Class</a>.</p>
<p>The range referenced must be valid; all pointers must be dereferenceable and within the sequence the last position is reachable from the first by incrementation.</p>
<p>The range excluding the newly added element at the end must be a heap.</p>
<p>The complexity is logarithmic, requiring at most log ( * last - first*) comparisons.</p>
<h3 id="example-34" class="heading-with-anchor">Example<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#example-34"></a></h3>
<div class="codeHeader" id="code-try-105" data-bi-name="code-header"><span class="language">C++</span>
			<button class="action" data-bi-name="copy">
				<span class="docon docon-edit-copy" role="presentation"></span>
				<span>Copy</span>
			</button></div><pre><code class="lang-cpp" data-author-content="// alg_pop_heap.cpp
// compile with: /EHsc
#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;functional&gt;
#include &lt;iostream&gt;

int main()  {
   using namespace std;
   vector &lt;int&gt; v1;
   vector &lt;int&gt;::iterator Iter1, Iter2;

   int i;
   for ( i = 1 ; i &lt;= 9 ; i++ )
      v1.push_back( i );

   // Make v1 a heap with default less than ordering
   random_shuffle( v1.begin( ), v1.end( ) );
   make_heap ( v1.begin( ), v1.end( ) );
   cout &lt;&lt; &quot;The heaped version of vector v1 is ( &quot; ;
   for ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ; Iter1++ )
      cout &lt;&lt; *Iter1 &lt;&lt; &quot; &quot;;
   cout &lt;&lt; &quot;).&quot; &lt;&lt; endl;

   // Add an element to the back of the heap
   v1.push_back( 10 );
   push_heap( v1.begin( ), v1.end( ) );
   cout &lt;&lt; &quot;The reheaped v1 with 10 added is ( &quot; ;
   for ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ; Iter1++ )
      cout &lt;&lt; *Iter1 &lt;&lt; &quot; &quot;;
   cout &lt;&lt; &quot;).&quot; &lt;&lt; endl;

   // Remove the largest element from the heap
   pop_heap( v1.begin( ), v1.end( ) );
   cout &lt;&lt; &quot;The heap v1 with 10 removed is ( &quot; ;
   for ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ; Iter1++ )
      cout &lt;&lt; *Iter1 &lt;&lt; &quot; &quot;;
   cout &lt;&lt; &quot;).&quot; &lt;&lt; endl &lt;&lt; endl;

   // Make v1 a heap with greater-than ordering with a 0 element
   make_heap ( v1.begin( ), v1.end( ), greater&lt;int&gt;( ) );
   v1.push_back( 0 );
   push_heap( v1.begin( ), v1.end( ), greater&lt;int&gt;( ) );
   cout &lt;&lt; &quot;The &#39;greater than&#39; reheaped v1 puts the smallest &quot;
        &lt;&lt; &quot;element first:\n ( &quot; ;
   for ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ; Iter1++ )
      cout &lt;&lt; *Iter1 &lt;&lt; &quot; &quot;;
   cout &lt;&lt; &quot;).&quot; &lt;&lt; endl;

   // Application of pop_heap to remove the smallest element
   pop_heap( v1.begin( ), v1.end( ), greater&lt;int&gt;( ) );
   cout &lt;&lt; &quot;The &#39;greater than&#39; heaped v1 with the smallest element\n &quot;
        &lt;&lt; &quot;removed from the heap is: ( &quot; ;
   for ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ; Iter1++ )
      cout &lt;&lt; *Iter1 &lt;&lt; &quot; &quot;;
   cout &lt;&lt; &quot;).&quot; &lt;&lt; endl;
}
"><span class="hljs-comment">// alg_pop_heap.cpp</span>
<span class="hljs-comment">// compile with: /EHsc</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;functional&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span>

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>  </span>{
   <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;
   <span class="hljs-built_in">vector</span> &lt;<span class="hljs-keyword">int</span>&gt; v1;
   <span class="hljs-built_in">vector</span> &lt;<span class="hljs-keyword">int</span>&gt;::iterator Iter1, Iter2;

   <span class="hljs-keyword">int</span> i;
   <span class="hljs-keyword">for</span> ( i = <span class="hljs-number">1</span> ; i &lt;= <span class="hljs-number">9</span> ; i++ )
      v1.push_back( i );

   <span class="hljs-comment">// Make v1 a heap with default less than ordering</span>
   random_shuffle( v1.begin( ), v1.end( ) );
   make_heap ( v1.begin( ), v1.end( ) );
   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"The heaped version of vector v1 is ( "</span> ;
   <span class="hljs-keyword">for</span> ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ; Iter1++ )
      <span class="hljs-built_in">cout</span> &lt;&lt; *Iter1 &lt;&lt; <span class="hljs-string">" "</span>;
   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">")."</span> &lt;&lt; <span class="hljs-built_in">endl</span>;

   <span class="hljs-comment">// Add an element to the back of the heap</span>
   v1.push_back( <span class="hljs-number">10</span> );
   push_heap( v1.begin( ), v1.end( ) );
   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"The reheaped v1 with 10 added is ( "</span> ;
   <span class="hljs-keyword">for</span> ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ; Iter1++ )
      <span class="hljs-built_in">cout</span> &lt;&lt; *Iter1 &lt;&lt; <span class="hljs-string">" "</span>;
   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">")."</span> &lt;&lt; <span class="hljs-built_in">endl</span>;

   <span class="hljs-comment">// Remove the largest element from the heap</span>
   pop_heap( v1.begin( ), v1.end( ) );
   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"The heap v1 with 10 removed is ( "</span> ;
   <span class="hljs-keyword">for</span> ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ; Iter1++ )
      <span class="hljs-built_in">cout</span> &lt;&lt; *Iter1 &lt;&lt; <span class="hljs-string">" "</span>;
   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">")."</span> &lt;&lt; <span class="hljs-built_in">endl</span> &lt;&lt; <span class="hljs-built_in">endl</span>;

   <span class="hljs-comment">// Make v1 a heap with greater-than ordering with a 0 element</span>
   make_heap ( v1.begin( ), v1.end( ), greater&lt;<span class="hljs-keyword">int</span>&gt;( ) );
   v1.push_back( <span class="hljs-number">0</span> );
   push_heap( v1.begin( ), v1.end( ), greater&lt;<span class="hljs-keyword">int</span>&gt;( ) );
   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"The 'greater than' reheaped v1 puts the smallest "</span>
        &lt;&lt; <span class="hljs-string">"element first:\n ( "</span> ;
   <span class="hljs-keyword">for</span> ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ; Iter1++ )
      <span class="hljs-built_in">cout</span> &lt;&lt; *Iter1 &lt;&lt; <span class="hljs-string">" "</span>;
   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">")."</span> &lt;&lt; <span class="hljs-built_in">endl</span>;

   <span class="hljs-comment">// Application of pop_heap to remove the smallest element</span>
   pop_heap( v1.begin( ), v1.end( ), greater&lt;<span class="hljs-keyword">int</span>&gt;( ) );
   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"The 'greater than' heaped v1 with the smallest element\n "</span>
        &lt;&lt; <span class="hljs-string">"removed from the heap is: ( "</span> ;
   <span class="hljs-keyword">for</span> ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ; Iter1++ )
      <span class="hljs-built_in">cout</span> &lt;&lt; *Iter1 &lt;&lt; <span class="hljs-string">" "</span>;
   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">")."</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
}
</code></pre>
<h2 id="prev_permutation" class="heading-with-anchor">  prev_permutation<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#prev_permutation"></a></h2>
<p>Reorders the elements in a range so that the original ordering is replaced by the lexicographically previous greater permutation if it exists, where the sense of previous may be specified with a binary predicate.</p>
<div class="codeHeader" id="code-try-106" data-bi-name="code-header"><span class="language">C++</span>
			<button class="action" data-bi-name="copy">
				<span class="docon docon-edit-copy" role="presentation"></span>
				<span>Copy</span>
			</button></div><pre><code class="lang-cpp" data-author-content="template&lt;class BidirectionalIterator&gt;
bool prev_permutation(
    BidirectionalIterator first,
    BidirectionalIterator last);

template&lt;class BidirectionalIterator, class BinaryPredicate&gt;
bool prev_permutation(
    BidirectionalIterator first,
    BidirectionalIterator last,
    BinaryPredicate comp);
"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BidirectionalIterator</span>&gt;
<span class="hljs-title">bool</span> <span class="hljs-title">prev_permutation</span>(
    <span class="hljs-title">BidirectionalIterator</span> <span class="hljs-title">first</span>,
    <span class="hljs-title">BidirectionalIterator</span> <span class="hljs-title">last</span>);</span>

<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BidirectionalIterator</span>, <span class="hljs-title">class</span> <span class="hljs-title">BinaryPredicate</span>&gt;
<span class="hljs-title">bool</span> <span class="hljs-title">prev_permutation</span>(
    <span class="hljs-title">BidirectionalIterator</span> <span class="hljs-title">first</span>,
    <span class="hljs-title">BidirectionalIterator</span> <span class="hljs-title">last</span>,
    <span class="hljs-title">BinaryPredicate</span> <span class="hljs-title">comp</span>);</span>
</code></pre>
<h3 id="parameters-53" class="heading-with-anchor">Parameters<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#parameters-53"></a></h3>
<p><em>first</em><br>
A bidirectional iterator pointing to the position of the first element in the range to be permuted.</p>
<p><em>last</em><br>
A bidirectional iterator pointing to the position one past the final element in the range to be permuted.</p>
<p><em>comp</em><br>
User-defined predicate function object that defines the comparison criterion to be satisfied by successive elements in the ordering. A binary predicate takes two arguments and returns <strong>true</strong> when satisfied and <strong>false</strong> when not satisfied.</p>
<h3 id="return-value-39" class="heading-with-anchor">Return Value<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#return-value-39"></a></h3>
<p><strong>true</strong> if the lexicographically previous permutation exists and has replaced the original ordering of the range; otherwise <strong>false</strong>, in which case the ordering is transformed into the lexicographically largest permutation.</p>
<h3 id="remarks-53" class="heading-with-anchor">Remarks<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#remarks-53"></a></h3>
<p>The range referenced must be valid; all pointers must be dereferenceable and within the sequence the last position is reachable from the first by incrementation.</p>
<p>The default binary predicate is less than and the elements in the range must be less-than comparable to ensure that the previous permutation is well defined.</p>
<p>The complexity is linear, with at most (<code>last</code> -  <code>first</code>)/2 swaps.</p>
<h3 id="example-35" class="heading-with-anchor">Example<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#example-35"></a></h3>
<div class="codeHeader" id="code-try-107" data-bi-name="code-header"><span class="language">C++</span>
			<button class="action" data-bi-name="copy">
				<span class="docon docon-edit-copy" role="presentation"></span>
				<span>Copy</span>
			</button></div><pre><code class="lang-cpp" data-author-content="// alg_prev_perm.cpp
// compile with: /EHsc
#include &lt;vector&gt;
#include &lt;deque&gt;
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;ostream&gt;

using namespace std;
class CInt;
ostream&amp; operator&lt;&lt;( ostream&amp; osIn, const CInt&amp; rhs );

class CInt {
public:
   CInt( int n = 0 ) : m_nVal( n ){}
   CInt( const CInt&amp; rhs ) : m_nVal( rhs.m_nVal ){}
   CInt&amp;   operator=( const CInt&amp; rhs ) {m_nVal =
   rhs.m_nVal; return *this;}
   bool operator&lt;( const CInt&amp; rhs ) const
      {return ( m_nVal &lt; rhs.m_nVal );}
   friend ostream&amp; operator&lt;&lt;( ostream&amp; osIn, const CInt&amp; rhs );

private:
   int m_nVal;
};

inline ostream&amp; operator&lt;&lt;( ostream&amp; osIn, const CInt&amp; rhs ) {
   osIn &lt;&lt; &quot;CInt( &quot; &lt;&lt; rhs.m_nVal &lt;&lt; &quot; )&quot;;
   return osIn;
}

// Return whether modulus of elem1 is less than modulus of elem2
bool mod_lesser (int elem1, int elem2 ) {
   if ( elem1 &lt; 0 )
      elem1 = - elem1;
   if ( elem2 &lt; 0 )
      elem2 = - elem2;
   return elem1 &lt; elem2;
};

int main() {
   // Reordering the elements of type CInt in a deque
   // using the prev_permutation algorithm
   CInt c1 = 1, c2 = 5, c3 = 10;
   bool deq1Result;
   deque&lt;CInt&gt; deq1, deq2, deq3;
   deque&lt;CInt&gt;::iterator d1_Iter;

   deq1.push_back ( c1 );
   deq1.push_back ( c2 );
   deq1.push_back ( c3 );

   cout &lt;&lt; &quot;The original deque of CInts is deq1 = (&quot;;
   for ( d1_Iter = deq1.begin( ); d1_Iter != --deq1.end( ); d1_Iter++ )
      cout &lt;&lt; &quot; &quot; &lt;&lt; *d1_Iter &lt;&lt; &quot;,&quot;;
   d1_Iter = --deq1.end( );
   cout &lt;&lt; &quot; &quot; &lt;&lt; *d1_Iter &lt;&lt; &quot; ).&quot; &lt;&lt; endl;

   deq1Result = prev_permutation ( deq1.begin( ), deq1.end( ) );

   if ( deq1Result )
      cout &lt;&lt; &quot;The lexicographically previous permutation &quot;
           &lt;&lt; &quot;exists and has \nreplaced the original &quot;
           &lt;&lt; &quot;ordering of the sequence in deq1.&quot; &lt;&lt; endl;
   else
      cout &lt;&lt; &quot;The lexicographically previous permutation doesn&#39;t &quot;
           &lt;&lt; &quot;exist\n and the lexicographically &quot;
           &lt;&lt; &quot;smallest permutation\n has replaced the &quot;
           &lt;&lt; &quot;original ordering of the sequence in deq1.&quot; &lt;&lt; endl;

   cout &lt;&lt; &quot;After one application of prev_permutation,\n deq1 = (&quot;;
   for ( d1_Iter = deq1.begin( ); d1_Iter != --deq1.end( ); d1_Iter++ )
      cout &lt;&lt; &quot; &quot; &lt;&lt; *d1_Iter &lt;&lt; &quot;,&quot;;
   d1_Iter = --deq1.end( );
   cout &lt;&lt; &quot; &quot; &lt;&lt; *d1_Iter &lt;&lt; &quot; ).&quot; &lt;&lt; endl &lt;&lt; endl;

   // Permutating vector elements with binary function mod_lesser
   vector &lt;int&gt; v1;
   vector &lt;int&gt;::iterator Iter1;

   int i;
   for ( i = -3 ; i &lt;= 3 ; i++ )
      v1.push_back( i );

   cout &lt;&lt; &quot;Vector v1 is ( &quot; ;
   for ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ; Iter1++ )
      cout &lt;&lt; *Iter1 &lt;&lt; &quot; &quot;;
   cout &lt;&lt; &quot;).&quot; &lt;&lt; endl;

   prev_permutation ( v1.begin( ), v1.end( ), mod_lesser );

   cout &lt;&lt; &quot;After the first prev_permutation, vector v1 is:\n v1 = ( &quot; ;
   for ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ; Iter1++ )
      cout &lt;&lt; *Iter1 &lt;&lt; &quot; &quot;;
   cout &lt;&lt; &quot;).&quot; &lt;&lt; endl;

   int iii = 1;
   while ( iii &lt;= 5 ) {
      prev_permutation ( v1.begin( ), v1.end( ), mod_lesser );
      cout &lt;&lt; &quot;After another prev_permutation of vector v1,\n v1 =   ( &quot; ;
      for ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ;Iter1 ++ )
         cout &lt;&lt; *Iter1  &lt;&lt; &quot; &quot;;
      cout &lt;&lt; &quot;).&quot; &lt;&lt; endl;
      iii++;
   }
}
"><span class="hljs-comment">// alg_prev_perm.cpp</span>
<span class="hljs-comment">// compile with: /EHsc</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;deque&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;ostream&gt;</span></span>

<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CInt</span>;</span>
ostream&amp; <span class="hljs-keyword">operator</span>&lt;&lt;( ostream&amp; osIn, <span class="hljs-keyword">const</span> CInt&amp; rhs );

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CInt</span> {</span>
<span class="hljs-keyword">public</span>:
   CInt( <span class="hljs-keyword">int</span> n = <span class="hljs-number">0</span> ) : m_nVal( n ){}
   CInt( <span class="hljs-keyword">const</span> CInt&amp; rhs ) : m_nVal( rhs.m_nVal ){}
   CInt&amp;   <span class="hljs-keyword">operator</span>=( <span class="hljs-keyword">const</span> CInt&amp; rhs ) {m_nVal =
   rhs.m_nVal; <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;}
   <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>&lt;( <span class="hljs-keyword">const</span> CInt&amp; rhs ) <span class="hljs-keyword">const</span>
      {<span class="hljs-keyword">return</span> ( m_nVal &lt; rhs.m_nVal );}
   <span class="hljs-keyword">friend</span> ostream&amp; <span class="hljs-keyword">operator</span>&lt;&lt;( ostream&amp; osIn, <span class="hljs-keyword">const</span> CInt&amp; rhs );

<span class="hljs-keyword">private</span>:
   <span class="hljs-keyword">int</span> m_nVal;
};

<span class="hljs-keyword">inline</span> ostream&amp; <span class="hljs-keyword">operator</span>&lt;&lt;( ostream&amp; osIn, <span class="hljs-keyword">const</span> CInt&amp; rhs ) {
   osIn &lt;&lt; <span class="hljs-string">"CInt( "</span> &lt;&lt; rhs.m_nVal &lt;&lt; <span class="hljs-string">" )"</span>;
   <span class="hljs-keyword">return</span> osIn;
}

<span class="hljs-comment">// Return whether modulus of elem1 is less than modulus of elem2</span>
<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">mod_lesser</span> <span class="hljs-params">(<span class="hljs-keyword">int</span> elem1, <span class="hljs-keyword">int</span> elem2 )</span> </span>{
   <span class="hljs-keyword">if</span> ( elem1 &lt; <span class="hljs-number">0</span> )
      elem1 = - elem1;
   <span class="hljs-keyword">if</span> ( elem2 &lt; <span class="hljs-number">0</span> )
      elem2 = - elem2;
   <span class="hljs-keyword">return</span> elem1 &lt; elem2;
};

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
   <span class="hljs-comment">// Reordering the elements of type CInt in a deque</span>
   <span class="hljs-comment">// using the prev_permutation algorithm</span>
   CInt c1 = <span class="hljs-number">1</span>, c2 = <span class="hljs-number">5</span>, c3 = <span class="hljs-number">10</span>;
   <span class="hljs-keyword">bool</span> deq1Result;
   <span class="hljs-built_in">deque</span>&lt;CInt&gt; deq1, deq2, deq3;
   <span class="hljs-built_in">deque</span>&lt;CInt&gt;::iterator d1_Iter;

   deq1.push_back ( c1 );
   deq1.push_back ( c2 );
   deq1.push_back ( c3 );

   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"The original deque of CInts is deq1 = ("</span>;
   <span class="hljs-keyword">for</span> ( d1_Iter = deq1.begin( ); d1_Iter != --deq1.end( ); d1_Iter++ )
      <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">" "</span> &lt;&lt; *d1_Iter &lt;&lt; <span class="hljs-string">","</span>;
   d1_Iter = --deq1.end( );
   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">" "</span> &lt;&lt; *d1_Iter &lt;&lt; <span class="hljs-string">" )."</span> &lt;&lt; <span class="hljs-built_in">endl</span>;

   deq1Result = prev_permutation ( deq1.begin( ), deq1.end( ) );

   <span class="hljs-keyword">if</span> ( deq1Result )
      <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"The lexicographically previous permutation "</span>
           &lt;&lt; <span class="hljs-string">"exists and has \nreplaced the original "</span>
           &lt;&lt; <span class="hljs-string">"ordering of the sequence in deq1."</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
   <span class="hljs-keyword">else</span>
      <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"The lexicographically previous permutation doesn't "</span>
           &lt;&lt; <span class="hljs-string">"exist\n and the lexicographically "</span>
           &lt;&lt; <span class="hljs-string">"smallest permutation\n has replaced the "</span>
           &lt;&lt; <span class="hljs-string">"original ordering of the sequence in deq1."</span> &lt;&lt; <span class="hljs-built_in">endl</span>;

   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"After one application of prev_permutation,\n deq1 = ("</span>;
   <span class="hljs-keyword">for</span> ( d1_Iter = deq1.begin( ); d1_Iter != --deq1.end( ); d1_Iter++ )
      <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">" "</span> &lt;&lt; *d1_Iter &lt;&lt; <span class="hljs-string">","</span>;
   d1_Iter = --deq1.end( );
   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">" "</span> &lt;&lt; *d1_Iter &lt;&lt; <span class="hljs-string">" )."</span> &lt;&lt; <span class="hljs-built_in">endl</span> &lt;&lt; <span class="hljs-built_in">endl</span>;

   <span class="hljs-comment">// Permutating vector elements with binary function mod_lesser</span>
   <span class="hljs-built_in">vector</span> &lt;<span class="hljs-keyword">int</span>&gt; v1;
   <span class="hljs-built_in">vector</span> &lt;<span class="hljs-keyword">int</span>&gt;::iterator Iter1;

   <span class="hljs-keyword">int</span> i;
   <span class="hljs-keyword">for</span> ( i = <span class="hljs-number">-3</span> ; i &lt;= <span class="hljs-number">3</span> ; i++ )
      v1.push_back( i );

   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Vector v1 is ( "</span> ;
   <span class="hljs-keyword">for</span> ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ; Iter1++ )
      <span class="hljs-built_in">cout</span> &lt;&lt; *Iter1 &lt;&lt; <span class="hljs-string">" "</span>;
   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">")."</span> &lt;&lt; <span class="hljs-built_in">endl</span>;

   prev_permutation ( v1.begin( ), v1.end( ), mod_lesser );

   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"After the first prev_permutation, vector v1 is:\n v1 = ( "</span> ;
   <span class="hljs-keyword">for</span> ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ; Iter1++ )
      <span class="hljs-built_in">cout</span> &lt;&lt; *Iter1 &lt;&lt; <span class="hljs-string">" "</span>;
   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">")."</span> &lt;&lt; <span class="hljs-built_in">endl</span>;

   <span class="hljs-keyword">int</span> iii = <span class="hljs-number">1</span>;
   <span class="hljs-keyword">while</span> ( iii &lt;= <span class="hljs-number">5</span> ) {
      prev_permutation ( v1.begin( ), v1.end( ), mod_lesser );
      <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"After another prev_permutation of vector v1,\n v1 =   ( "</span> ;
      <span class="hljs-keyword">for</span> ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ;Iter1 ++ )
         <span class="hljs-built_in">cout</span> &lt;&lt; *Iter1  &lt;&lt; <span class="hljs-string">" "</span>;
      <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">")."</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
      iii++;
   }
}
</code></pre>
<div class="codeHeader" id="code-try-108" data-bi-name="code-header"><span class="language">Output</span>
			<button class="action" data-bi-name="copy">
				<span class="docon docon-edit-copy" role="presentation"></span>
				<span>Copy</span>
			</button></div><pre><code class="lang-Output" data-author-content="The original deque of CInts is deq1 = ( CInt( 1 ), CInt( 5 ), CInt( 10 ) ).
The lexicographically previous permutation doesn&#39;t exist
and the lexicographically smallest permutation
has replaced the original ordering of the sequence in deq1.
After one application of prev_permutation,
deq1 = ( CInt( 10 ), CInt( 5 ), CInt( 1 ) ).

Vector v1 is ( -3 -2 -1 0 1 2 3 ).
After the first prev_permutation, vector v1 is:
v1 = ( -3 -2 0 3 2 1 -1 ).
After another prev_permutation of vector v1,
v1 =   ( -3 -2 0 3 -1 2 1 ).
After another prev_permutation of vector v1,
v1 =   ( -3 -2 0 3 -1 1 2 ).
After another prev_permutation of vector v1,
v1 =   ( -3 -2 0 2 3 1 -1 ).
After another prev_permutation of vector v1,
v1 =   ( -3 -2 0 2 -1 3 1 ).
After another prev_permutation of vector v1,
v1 =   ( -3 -2 0 2 -1 1 3 ).
">The original deque of CInts is deq1 = ( CInt( 1 ), CInt( 5 ), CInt( 10 ) ).
The lexicographically previous permutation doesn't exist
and the lexicographically smallest permutation
has replaced the original ordering of the sequence in deq1.
After one application of prev_permutation,
deq1 = ( CInt( 10 ), CInt( 5 ), CInt( 1 ) ).

Vector v1 is ( -3 -2 -1 0 1 2 3 ).
After the first prev_permutation, vector v1 is:
v1 = ( -3 -2 0 3 2 1 -1 ).
After another prev_permutation of vector v1,
v1 =   ( -3 -2 0 3 -1 2 1 ).
After another prev_permutation of vector v1,
v1 =   ( -3 -2 0 3 -1 1 2 ).
After another prev_permutation of vector v1,
v1 =   ( -3 -2 0 2 3 1 -1 ).
After another prev_permutation of vector v1,
v1 =   ( -3 -2 0 2 -1 3 1 ).
After another prev_permutation of vector v1,
v1 =   ( -3 -2 0 2 -1 1 3 ).
</code></pre>
<h2 id="push_heap" class="heading-with-anchor">  push_heap<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#push_heap"></a></h2>
<p>Adds an element that is at the end of a range to an existing heap consisting of the prior elements in the range.</p>
<div class="codeHeader" id="code-try-109" data-bi-name="code-header"><span class="language">C++</span>
			<button class="action" data-bi-name="copy">
				<span class="docon docon-edit-copy" role="presentation"></span>
				<span>Copy</span>
			</button></div><pre><code class="lang-cpp" data-author-content="template&lt;class RandomAccessIterator&gt;
void push_heap( RandomAccessIterator first, RandomAccessIterator last );

template&lt;class RandomAccessIterator, class BinaryPredicate&gt;
void push_heap( RandomAccessIterator first, RandomAccessIterator last, BinaryPredicate comp);
"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RandomAccessIterator</span>&gt;
<span class="hljs-title">void</span> <span class="hljs-title">push_heap</span>( <span class="hljs-title">RandomAccessIterator</span> <span class="hljs-title">first</span>, <span class="hljs-title">RandomAccessIterator</span> <span class="hljs-title">last</span> );</span>

<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RandomAccessIterator</span>, <span class="hljs-title">class</span> <span class="hljs-title">BinaryPredicate</span>&gt;
<span class="hljs-title">void</span> <span class="hljs-title">push_heap</span>( <span class="hljs-title">RandomAccessIterator</span> <span class="hljs-title">first</span>, <span class="hljs-title">RandomAccessIterator</span> <span class="hljs-title">last</span>, <span class="hljs-title">BinaryPredicate</span> <span class="hljs-title">comp</span>);</span>
</code></pre>
<h3 id="parameters-54" class="heading-with-anchor">Parameters<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#parameters-54"></a></h3>
<p><em>first</em><br>
A random-access iterator addressing the position of the first element in the heap.</p>
<p><em>last</em><br>
A random-access iterator addressing the position one past the final element in the range to be converted into a heap.</p>
<p><em>comp</em><br>
User-defined predicate function object that defines sense in which one element is less than another. A binary predicate takes two arguments and returns <strong>true</strong> when satisfied and <strong>false</strong> when not satisfied.</p>
<h3 id="remarks-54" class="heading-with-anchor">Remarks<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#remarks-54"></a></h3>
<p>The element must first be pushed back to the end of an existing heap and then the algorithm is used to add this element to the existing heap.</p>
<p>Heaps have two properties:</p>
<ul>
<li><p>The first element is always the largest.</p>
</li>
<li><p>Elements may be added or removed in logarithmic time.</p>
</li>
</ul>
<p>Heaps are an ideal way to implement priority queues and they are used in the implementation of the C++ Standard Library container adaptor <a href="https://docs.microsoft.com/en-us/cpp/standard-library/priority-queue-class?view=vs-2019" data-linktype="relative-path">priority_queue Class</a>.</p>
<p>The range referenced must be valid; all pointers must be dereferenceable and within the sequence the last position is reachable from the first by incrementation.</p>
<p>The range excluding the newly added element at the end must be a heap.</p>
<p>The complexity is logarithmic, requiring at most log ( <em>last - first</em>) comparisons.</p>
<h3 id="example-36" class="heading-with-anchor">Example<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#example-36"></a></h3>
<div class="codeHeader" id="code-try-110" data-bi-name="code-header"><span class="language">C++</span>
			<button class="action" data-bi-name="copy">
				<span class="docon docon-edit-copy" role="presentation"></span>
				<span>Copy</span>
			</button></div><pre><code class="lang-cpp" data-author-content="// alg_push_heap.cpp
// compile with: /EHsc
#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;functional&gt;
#include &lt;iostream&gt;

int main() {
   using namespace std;
   vector &lt;int&gt; v1, v2;
   vector &lt;int&gt;::iterator Iter1, Iter2;

   int i;
   for ( i = 1 ; i &lt;= 9 ; i++ )
      v1.push_back( i );

   random_shuffle( v1.begin( ), v1.end( ) );

   cout &lt;&lt; &quot;Vector v1 is ( &quot; ;
   for ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ; Iter1++ )
      cout &lt;&lt; *Iter1 &lt;&lt; &quot; &quot;;
   cout &lt;&lt; &quot;).&quot; &lt;&lt; endl;

   // Make v1 a heap with default less than ordering
   make_heap ( v1.begin( ), v1.end( ) );
   cout &lt;&lt; &quot;The heaped version of vector v1 is ( &quot; ;
   for ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ; Iter1++ )
      cout &lt;&lt; *Iter1 &lt;&lt; &quot; &quot;;
   cout &lt;&lt; &quot;).&quot; &lt;&lt; endl;

   // Add an element to the heap
   v1.push_back( 10 );
   cout &lt;&lt; &quot;The heap v1 with 10 pushed back is ( &quot; ;
   for ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ; Iter1++ )
      cout &lt;&lt; *Iter1 &lt;&lt; &quot; &quot;;
   cout &lt;&lt; &quot;).&quot; &lt;&lt; endl;

   push_heap( v1.begin( ), v1.end( ) );
   cout &lt;&lt; &quot;The reheaped v1 with 10 added is ( &quot; ;
   for ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ; Iter1++ )
      cout &lt;&lt; *Iter1 &lt;&lt; &quot; &quot;;
   cout &lt;&lt; &quot;).&quot; &lt;&lt; endl &lt;&lt; endl;

   // Make v1 a heap with greater than ordering
   make_heap ( v1.begin( ), v1.end( ), greater&lt;int&gt;( ) );
   cout &lt;&lt; &quot;The greater-than heaped version of v1 is\n ( &quot; ;
   for ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ; Iter1++ )
      cout &lt;&lt; *Iter1 &lt;&lt; &quot; &quot;;
   cout &lt;&lt; &quot;).&quot; &lt;&lt; endl;

   v1.push_back(0);
   cout &lt;&lt; &quot;The greater-than heap v1 with 11 pushed back is\n ( &quot; ;
   for ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ; Iter1++ )
      cout &lt;&lt; *Iter1 &lt;&lt; &quot; &quot;;
   cout &lt;&lt; &quot;).&quot; &lt;&lt; endl;

   push_heap( v1.begin( ), v1.end( ), greater&lt;int&gt;( ) );
   cout &lt;&lt; &quot;The greater than reheaped v1 with 11 added is\n ( &quot; ;
   for ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ; Iter1++ )
      cout &lt;&lt; *Iter1 &lt;&lt; &quot; &quot;;
   cout &lt;&lt; &quot;).&quot; &lt;&lt; endl;
}
"><span class="hljs-comment">// alg_push_heap.cpp</span>
<span class="hljs-comment">// compile with: /EHsc</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;functional&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span>

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
   <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;
   <span class="hljs-built_in">vector</span> &lt;<span class="hljs-keyword">int</span>&gt; v1, v2;
   <span class="hljs-built_in">vector</span> &lt;<span class="hljs-keyword">int</span>&gt;::iterator Iter1, Iter2;

   <span class="hljs-keyword">int</span> i;
   <span class="hljs-keyword">for</span> ( i = <span class="hljs-number">1</span> ; i &lt;= <span class="hljs-number">9</span> ; i++ )
      v1.push_back( i );

   random_shuffle( v1.begin( ), v1.end( ) );

   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Vector v1 is ( "</span> ;
   <span class="hljs-keyword">for</span> ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ; Iter1++ )
      <span class="hljs-built_in">cout</span> &lt;&lt; *Iter1 &lt;&lt; <span class="hljs-string">" "</span>;
   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">")."</span> &lt;&lt; <span class="hljs-built_in">endl</span>;

   <span class="hljs-comment">// Make v1 a heap with default less than ordering</span>
   make_heap ( v1.begin( ), v1.end( ) );
   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"The heaped version of vector v1 is ( "</span> ;
   <span class="hljs-keyword">for</span> ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ; Iter1++ )
      <span class="hljs-built_in">cout</span> &lt;&lt; *Iter1 &lt;&lt; <span class="hljs-string">" "</span>;
   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">")."</span> &lt;&lt; <span class="hljs-built_in">endl</span>;

   <span class="hljs-comment">// Add an element to the heap</span>
   v1.push_back( <span class="hljs-number">10</span> );
   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"The heap v1 with 10 pushed back is ( "</span> ;
   <span class="hljs-keyword">for</span> ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ; Iter1++ )
      <span class="hljs-built_in">cout</span> &lt;&lt; *Iter1 &lt;&lt; <span class="hljs-string">" "</span>;
   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">")."</span> &lt;&lt; <span class="hljs-built_in">endl</span>;

   push_heap( v1.begin( ), v1.end( ) );
   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"The reheaped v1 with 10 added is ( "</span> ;
   <span class="hljs-keyword">for</span> ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ; Iter1++ )
      <span class="hljs-built_in">cout</span> &lt;&lt; *Iter1 &lt;&lt; <span class="hljs-string">" "</span>;
   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">")."</span> &lt;&lt; <span class="hljs-built_in">endl</span> &lt;&lt; <span class="hljs-built_in">endl</span>;

   <span class="hljs-comment">// Make v1 a heap with greater than ordering</span>
   make_heap ( v1.begin( ), v1.end( ), greater&lt;<span class="hljs-keyword">int</span>&gt;( ) );
   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"The greater-than heaped version of v1 is\n ( "</span> ;
   <span class="hljs-keyword">for</span> ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ; Iter1++ )
      <span class="hljs-built_in">cout</span> &lt;&lt; *Iter1 &lt;&lt; <span class="hljs-string">" "</span>;
   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">")."</span> &lt;&lt; <span class="hljs-built_in">endl</span>;

   v1.push_back(<span class="hljs-number">0</span>);
   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"The greater-than heap v1 with 11 pushed back is\n ( "</span> ;
   <span class="hljs-keyword">for</span> ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ; Iter1++ )
      <span class="hljs-built_in">cout</span> &lt;&lt; *Iter1 &lt;&lt; <span class="hljs-string">" "</span>;
   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">")."</span> &lt;&lt; <span class="hljs-built_in">endl</span>;

   push_heap( v1.begin( ), v1.end( ), greater&lt;<span class="hljs-keyword">int</span>&gt;( ) );
   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"The greater than reheaped v1 with 11 added is\n ( "</span> ;
   <span class="hljs-keyword">for</span> ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ; Iter1++ )
      <span class="hljs-built_in">cout</span> &lt;&lt; *Iter1 &lt;&lt; <span class="hljs-string">" "</span>;
   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">")."</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
}
</code></pre>
<h2 id="random_shuffle" class="heading-with-anchor">  random_shuffle<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#random_shuffle"></a></h2>
<p>The std::random_shuffle() function is deprecated, replaced by <a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#shuffle" data-linktype="relative-path">std::shuffle</a>. For a code example and more information, see <a href="https://docs.microsoft.com/en-us/cpp/standard-library/random?view=vs-2019" data-linktype="relative-path">&lt;random&gt;</a> and the Stack Overflow post <a href="http://go.microsoft.com/fwlink/p/?linkid=397954" data-linktype="external">Why are std::random_shuffle methods being deprecated in C++14?</a>.</p>
<h2 id="remove" class="heading-with-anchor">  remove<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#remove"></a></h2>
<p>Eliminates a specified value from a given range without disturbing the order of the remaining elements and returning the end of a new range free of the specified value.</p>
<div class="codeHeader" id="code-try-111" data-bi-name="code-header"><span class="language">C++</span>
			<button class="action" data-bi-name="copy">
				<span class="docon docon-edit-copy" role="presentation"></span>
				<span>Copy</span>
			</button></div><pre><code class="lang-cpp" data-author-content="template&lt;class ForwardIterator, class Type&gt;
ForwardIterator remove(ForwardIterator first, ForwardIterator last, const Type&amp; val);
"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ForwardIterator</span>, <span class="hljs-title">class</span> <span class="hljs-title">Type</span>&gt;
<span class="hljs-title">ForwardIterator</span> <span class="hljs-title">remove</span>(<span class="hljs-title">ForwardIterator</span> <span class="hljs-title">first</span>, <span class="hljs-title">ForwardIterator</span> <span class="hljs-title">last</span>, <span class="hljs-title">const</span> <span class="hljs-title">Type</span>&amp; <span class="hljs-title">val</span>);</span>
</code></pre>
<h3 id="parameters-55" class="heading-with-anchor">Parameters<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#parameters-55"></a></h3>
<p><em>first</em><br>
A forward iterator addressing the position of the first element in the range from which elements are being removed.</p>
<p><em>last</em><br>
A forward iterator addressing the position one past the final element in the range from which elements are being removed.</p>
<p><em>val</em><br>
The value that is to be removed from the range.</p>
<h3 id="return-value-40" class="heading-with-anchor">Return Value<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#return-value-40"></a></h3>
<p>A forward iterator addressing the new end position of the modified range, one past the final element of the remnant sequence free of the specified value.</p>
<h3 id="remarks-55" class="heading-with-anchor">Remarks<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#remarks-55"></a></h3>
<p>The range referenced must be valid; all pointers must be dereferenceable and within the sequence the last position is reachable from the first by incrementation.</p>
<p>The order of the elements not removed remains stable.</p>
<p>The <code>operator==</code> used to determine the equality between elements must impose an equivalence relation between its operands.</p>
<p>The complexity is linear; there are (<code>last</code> - <code>first</code>) comparisons for equality.</p>
<p>The <a href="https://docs.microsoft.com/en-us/cpp/standard-library/list-class?view=vs-2019" data-linktype="relative-path">list class</a> has a more efficient member function version of <code>remove</code>, which also relinks pointers.</p>
<h3 id="example-37" class="heading-with-anchor">Example<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#example-37"></a></h3>
<div class="codeHeader" id="code-try-112" data-bi-name="code-header"><span class="language">C++</span>
			<button class="action" data-bi-name="copy">
				<span class="docon docon-edit-copy" role="presentation"></span>
				<span>Copy</span>
			</button></div><pre><code class="lang-cpp" data-author-content="// alg_remove.cpp
// compile with: /EHsc
#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;iostream&gt;

int main() {
   using namespace std;
   vector &lt;int&gt; v1;
   vector &lt;int&gt;::iterator Iter1, Iter2, new_end;

   int i;
   for ( i = 0 ; i &lt;= 9 ; i++ )
      v1.push_back( i );

   int ii;
   for ( ii = 0 ; ii &lt;= 3 ; ii++ )
      v1.push_back( 7 );

   random_shuffle ( v1.begin( ), v1.end( ) );
   cout &lt;&lt; &quot;Vector v1 is ( &quot; ;
   for ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ; Iter1++ )
      cout &lt;&lt; *Iter1 &lt;&lt; &quot; &quot;;
   cout &lt;&lt; &quot;).&quot; &lt;&lt; endl;

   // Remove elements with a value of 7
   new_end = remove ( v1.begin( ), v1.end( ), 7 );

   cout &lt;&lt; &quot;Vector v1 with value 7 removed is ( &quot; ;
   for ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ; Iter1++ )
      cout &lt;&lt; *Iter1 &lt;&lt; &quot; &quot;;
   cout &lt;&lt; &quot;).&quot; &lt;&lt; endl;

   // To change the sequence size, use erase
   v1.erase (new_end, v1.end( ) );

   cout &lt;&lt; &quot;Vector v1 resized with value 7 removed is ( &quot; ;
   for ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ; Iter1++ )
      cout &lt;&lt; *Iter1 &lt;&lt; &quot; &quot;;
   cout &lt;&lt; &quot;).&quot; &lt;&lt; endl;
}
"><span class="hljs-comment">// alg_remove.cpp</span>
<span class="hljs-comment">// compile with: /EHsc</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span>

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
   <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;
   <span class="hljs-built_in">vector</span> &lt;<span class="hljs-keyword">int</span>&gt; v1;
   <span class="hljs-built_in">vector</span> &lt;<span class="hljs-keyword">int</span>&gt;::iterator Iter1, Iter2, new_end;

   <span class="hljs-keyword">int</span> i;
   <span class="hljs-keyword">for</span> ( i = <span class="hljs-number">0</span> ; i &lt;= <span class="hljs-number">9</span> ; i++ )
      v1.push_back( i );

   <span class="hljs-keyword">int</span> ii;
   <span class="hljs-keyword">for</span> ( ii = <span class="hljs-number">0</span> ; ii &lt;= <span class="hljs-number">3</span> ; ii++ )
      v1.push_back( <span class="hljs-number">7</span> );

   random_shuffle ( v1.begin( ), v1.end( ) );
   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Vector v1 is ( "</span> ;
   <span class="hljs-keyword">for</span> ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ; Iter1++ )
      <span class="hljs-built_in">cout</span> &lt;&lt; *Iter1 &lt;&lt; <span class="hljs-string">" "</span>;
   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">")."</span> &lt;&lt; <span class="hljs-built_in">endl</span>;

   <span class="hljs-comment">// Remove elements with a value of 7</span>
   new_end = remove ( v1.begin( ), v1.end( ), <span class="hljs-number">7</span> );

   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Vector v1 with value 7 removed is ( "</span> ;
   <span class="hljs-keyword">for</span> ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ; Iter1++ )
      <span class="hljs-built_in">cout</span> &lt;&lt; *Iter1 &lt;&lt; <span class="hljs-string">" "</span>;
   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">")."</span> &lt;&lt; <span class="hljs-built_in">endl</span>;

   <span class="hljs-comment">// To change the sequence size, use erase</span>
   v1.erase (new_end, v1.end( ) );

   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Vector v1 resized with value 7 removed is ( "</span> ;
   <span class="hljs-keyword">for</span> ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ; Iter1++ )
      <span class="hljs-built_in">cout</span> &lt;&lt; *Iter1 &lt;&lt; <span class="hljs-string">" "</span>;
   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">")."</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
}
</code></pre>
<h2 id="remove_copy" class="heading-with-anchor">  remove_copy<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#remove_copy"></a></h2>
<p>Copies elements from a source range to a destination range, except that elements of a specified value are not copied, without disturbing the order of the remaining elements and returning the end of a new destination range.</p>
<div class="codeHeader" id="code-try-113" data-bi-name="code-header"><span class="language">C++</span>
			<button class="action" data-bi-name="copy">
				<span class="docon docon-edit-copy" role="presentation"></span>
				<span>Copy</span>
			</button></div><pre><code class="lang-cpp" data-author-content="template&lt;class InputIterator, class OutputIterator, class Type&gt;
OutputIterator remove_copy(InputIterator first, InputIterator last, OutputIterator result, const Type&amp; val);
"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InputIterator</span>, <span class="hljs-title">class</span> <span class="hljs-title">OutputIterator</span>, <span class="hljs-title">class</span> <span class="hljs-title">Type</span>&gt;
<span class="hljs-title">OutputIterator</span> <span class="hljs-title">remove_copy</span>(<span class="hljs-title">InputIterator</span> <span class="hljs-title">first</span>, <span class="hljs-title">InputIterator</span> <span class="hljs-title">last</span>, <span class="hljs-title">OutputIterator</span> <span class="hljs-title">result</span>, <span class="hljs-title">const</span> <span class="hljs-title">Type</span>&amp; <span class="hljs-title">val</span>);</span>
</code></pre>
<h3 id="parameters-56" class="heading-with-anchor">Parameters<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#parameters-56"></a></h3>
<p><em>first</em><br>
An input iterator addressing the position of the first element in the range from which elements are being removed.</p>
<p><em>last</em><br>
An input iterator addressing the position one past the final element in the range from which elements are being removed.</p>
<p><em>result</em><br>
An output iterator addressing the position of the first element in the destination range to which elements are being removed.</p>
<p><em>val</em><br>
The value that is to be removed from the range.</p>
<h3 id="return-value-41" class="heading-with-anchor">Return Value<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#return-value-41"></a></h3>
<p>A forward iterator addressing the new end position of the destination range, one past the final element of the copy of the remnant sequence free of the specified value.</p>
<h3 id="remarks-56" class="heading-with-anchor">Remarks<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#remarks-56"></a></h3>
<p>The source and destination ranges referenced must be valid; all pointers must be dereferenceable and within the sequence the last position is reachable from the first by incrementation.</p>
<p>There must be enough space in the destination range to contain the remnant elements that will be copied after elements of the specified value are removed.</p>
<p>The order of the elements not removed remains stable.</p>
<p>The <code>operator==</code> used to determine the equality between elements must impose an equivalence relation between its operands.</p>
<p>The complexity is linear; there are (<code>last</code> - <code>first</code>) comparisons for equality and at most (<code>last</code> - <code>first</code>) assignments.</p>
<h3 id="example-38" class="heading-with-anchor">Example<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#example-38"></a></h3>
<div class="codeHeader" id="code-try-114" data-bi-name="code-header"><span class="language">C++</span>
			<button class="action" data-bi-name="copy">
				<span class="docon docon-edit-copy" role="presentation"></span>
				<span>Copy</span>
			</button></div><pre><code class="lang-cpp" data-author-content="// alg_remove_copy.cpp
// compile with: /EHsc
#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;iostream&gt;

int main() {
   using namespace std;
   vector &lt;int&gt; v1, v2(10);
   vector &lt;int&gt;::iterator Iter1, Iter2, new_end;

   int i;
   for ( i = 0 ; i &lt;= 9 ; i++ )
      v1.push_back( i );

   int ii;
   for ( ii = 0 ; ii &lt;= 3 ; ii++ )
      v1.push_back( 7 );

   random_shuffle (v1.begin( ), v1.end( ) );
   cout &lt;&lt; &quot;The original vector v1 is:     ( &quot; ;
   for ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ; Iter1++ )
      cout &lt;&lt; *Iter1 &lt;&lt; &quot; &quot;;
   cout &lt;&lt; &quot;).&quot; &lt;&lt; endl;

   // Remove elements with a value of 7
   new_end = remove_copy ( v1.begin( ), v1.end( ), v2.begin( ), 7 );

   cout &lt;&lt; &quot;Vector v1 is left unchanged as ( &quot; ;
   for ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ; Iter1++ )
      cout &lt;&lt; *Iter1 &lt;&lt; &quot; &quot;;
   cout &lt;&lt; &quot;).&quot; &lt;&lt; endl;

   cout &lt;&lt; &quot;Vector v2 is a copy of v1 with the value 7 removed:\n ( &quot; ;
   for ( Iter2 = v2.begin( ) ; Iter2 != v2.end( ) ; Iter2++ )
      cout &lt;&lt; *Iter2 &lt;&lt; &quot; &quot;;
   cout &lt;&lt; &quot;).&quot; &lt;&lt; endl;
}
"><span class="hljs-comment">// alg_remove_copy.cpp</span>
<span class="hljs-comment">// compile with: /EHsc</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span>

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
   <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;
   <span class="hljs-built_in">vector</span> &lt;<span class="hljs-keyword">int</span>&gt; v1, v2(<span class="hljs-number">10</span>);
   <span class="hljs-built_in">vector</span> &lt;<span class="hljs-keyword">int</span>&gt;::iterator Iter1, Iter2, new_end;

   <span class="hljs-keyword">int</span> i;
   <span class="hljs-keyword">for</span> ( i = <span class="hljs-number">0</span> ; i &lt;= <span class="hljs-number">9</span> ; i++ )
      v1.push_back( i );

   <span class="hljs-keyword">int</span> ii;
   <span class="hljs-keyword">for</span> ( ii = <span class="hljs-number">0</span> ; ii &lt;= <span class="hljs-number">3</span> ; ii++ )
      v1.push_back( <span class="hljs-number">7</span> );

   random_shuffle (v1.begin( ), v1.end( ) );
   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"The original vector v1 is:     ( "</span> ;
   <span class="hljs-keyword">for</span> ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ; Iter1++ )
      <span class="hljs-built_in">cout</span> &lt;&lt; *Iter1 &lt;&lt; <span class="hljs-string">" "</span>;
   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">")."</span> &lt;&lt; <span class="hljs-built_in">endl</span>;

   <span class="hljs-comment">// Remove elements with a value of 7</span>
   new_end = remove_copy ( v1.begin( ), v1.end( ), v2.begin( ), <span class="hljs-number">7</span> );

   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Vector v1 is left unchanged as ( "</span> ;
   <span class="hljs-keyword">for</span> ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ; Iter1++ )
      <span class="hljs-built_in">cout</span> &lt;&lt; *Iter1 &lt;&lt; <span class="hljs-string">" "</span>;
   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">")."</span> &lt;&lt; <span class="hljs-built_in">endl</span>;

   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Vector v2 is a copy of v1 with the value 7 removed:\n ( "</span> ;
   <span class="hljs-keyword">for</span> ( Iter2 = v2.begin( ) ; Iter2 != v2.end( ) ; Iter2++ )
      <span class="hljs-built_in">cout</span> &lt;&lt; *Iter2 &lt;&lt; <span class="hljs-string">" "</span>;
   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">")."</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
}
</code></pre>
<h2 id="remove_copy_if" class="heading-with-anchor">  remove_copy_if<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#remove_copy_if"></a></h2>
<p>Copies elements from a source range to a destination range, except that satisfying a predicate are not copied, without disturbing the order of the remaining elements and returning the end of a new destination range.</p>
<div class="codeHeader" id="code-try-115" data-bi-name="code-header"><span class="language">C++</span>
			<button class="action" data-bi-name="copy">
				<span class="docon docon-edit-copy" role="presentation"></span>
				<span>Copy</span>
			</button></div><pre><code class="lang-cpp" data-author-content="template&lt;class InputIterator, class OutputIterator, class Predicate&gt;
OutputIterator remove_copy_if(InputIterator first, InputIterator Last, OutputIterator result, Predicate pred);
"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InputIterator</span>, <span class="hljs-title">class</span> <span class="hljs-title">OutputIterator</span>, <span class="hljs-title">class</span> <span class="hljs-title">Predicate</span>&gt;
<span class="hljs-title">OutputIterator</span> <span class="hljs-title">remove_copy_if</span>(<span class="hljs-title">InputIterator</span> <span class="hljs-title">first</span>, <span class="hljs-title">InputIterator</span> <span class="hljs-title">Last</span>, <span class="hljs-title">OutputIterator</span> <span class="hljs-title">result</span>, <span class="hljs-title">Predicate</span> <span class="hljs-title">pred</span>);</span>
</code></pre>
<h3 id="parameters-57" class="heading-with-anchor">Parameters<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#parameters-57"></a></h3>
<p><em>first</em><br>
An input iterator addressing the position of the first element in the range from which elements are being removed.</p>
<p><em>last</em><br>
An input iterator addressing the position one past the final element in the range from which elements are being removed.</p>
<p><em>result</em><br>
An output iterator addressing the position of the first element in the destination range to which elements are being removed.</p>
<p><em>_Pred</em><br>
The unary predicate that must be satisfied is the value of an element is to be replaced.</p>
<h3 id="return-value-42" class="heading-with-anchor">Return Value<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#return-value-42"></a></h3>
<p>A forward iterator addressing the new end position of the destination range, one past the final element of the remnant sequence free of the elements satisfying the predicate.</p>
<h3 id="remarks-57" class="heading-with-anchor">Remarks<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#remarks-57"></a></h3>
<p>The source range referenced must be valid; all pointers must be dereferenceable and within the sequence the last position is reachable from the first by incrementation.</p>
<p>There must be enough space in the destination range to contain the remnant elements that will be copied after elements of the specified value are removed.</p>
<p>The order of the elements not removed remains stable.</p>
<p>The <code>operator==</code> used to determine the equality between elements must impose an equivalence relation between its operands.</p>
<p>The complexity is linear: there are (<code>last</code> - <code>first</code>) comparisons for equality and at most (<code>last</code> - <code>first</code>) assignments.</p>
<p>For information on how these functions behave, see <a href="https://docs.microsoft.com/en-us/cpp/standard-library/checked-iterators?view=vs-2019" data-linktype="relative-path">Checked Iterators</a>.</p>
<h3 id="example-39" class="heading-with-anchor">Example<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#example-39"></a></h3>
<div class="codeHeader" id="code-try-116" data-bi-name="code-header"><span class="language">C++</span>
			<button class="action" data-bi-name="copy">
				<span class="docon docon-edit-copy" role="presentation"></span>
				<span>Copy</span>
			</button></div><pre><code class="lang-cpp" data-author-content="// alg_remove_copy_if.cpp
// compile with: /EHsc
#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;iostream&gt;

bool greater6 ( int value ) {
   return value &gt; 6;
}

int main() {
   using namespace std;
   vector &lt;int&gt; v1, v2(10);
   vector &lt;int&gt;::iterator Iter1, Iter2, new_end;

   int i;
   for ( i = 0 ; i &lt;= 9 ; i++ )
      v1.push_back( i );

   int ii;
   for ( ii = 0 ; ii &lt;= 3 ; ii++ )
      v1.push_back( 7 );

   random_shuffle ( v1.begin( ), v1.end( ) );
   cout &lt;&lt; &quot;The original vector v1 is:      ( &quot; ;
   for ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ; Iter1++ )
      cout &lt;&lt; *Iter1 &lt;&lt; &quot; &quot;;
   cout &lt;&lt; &quot;).&quot; &lt;&lt; endl;

   // Remove elements with a value greater than 6
   new_end = remove_copy_if ( v1.begin( ), v1.end( ),
      v2.begin( ), greater6 );

   cout &lt;&lt; &quot;After the appliation of remove_copy_if to v1,\n &quot;
        &lt;&lt; &quot;vector v1 is left unchanged as ( &quot; ;
   for ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ; Iter1++ )
      cout &lt;&lt; *Iter1 &lt;&lt; &quot; &quot;;
   cout &lt;&lt; &quot;).&quot; &lt;&lt; endl;

   cout &lt;&lt; &quot;Vector v2 is a copy of v1 with values greater &quot;
        &lt;&lt; &quot;than 6 removed:\n ( &quot; ;
   for ( Iter2 = v2.begin( ) ; Iter2 != new_end ; Iter2++ )
      cout &lt;&lt; *Iter2 &lt;&lt; &quot; &quot;;
   cout &lt;&lt; &quot;).&quot; &lt;&lt; endl;
}
"><span class="hljs-comment">// alg_remove_copy_if.cpp</span>
<span class="hljs-comment">// compile with: /EHsc</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span>

<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">greater6</span> <span class="hljs-params">( <span class="hljs-keyword">int</span> value )</span> </span>{
   <span class="hljs-keyword">return</span> value &gt; <span class="hljs-number">6</span>;
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
   <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;
   <span class="hljs-built_in">vector</span> &lt;<span class="hljs-keyword">int</span>&gt; v1, v2(<span class="hljs-number">10</span>);
   <span class="hljs-built_in">vector</span> &lt;<span class="hljs-keyword">int</span>&gt;::iterator Iter1, Iter2, new_end;

   <span class="hljs-keyword">int</span> i;
   <span class="hljs-keyword">for</span> ( i = <span class="hljs-number">0</span> ; i &lt;= <span class="hljs-number">9</span> ; i++ )
      v1.push_back( i );

   <span class="hljs-keyword">int</span> ii;
   <span class="hljs-keyword">for</span> ( ii = <span class="hljs-number">0</span> ; ii &lt;= <span class="hljs-number">3</span> ; ii++ )
      v1.push_back( <span class="hljs-number">7</span> );

   random_shuffle ( v1.begin( ), v1.end( ) );
   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"The original vector v1 is:      ( "</span> ;
   <span class="hljs-keyword">for</span> ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ; Iter1++ )
      <span class="hljs-built_in">cout</span> &lt;&lt; *Iter1 &lt;&lt; <span class="hljs-string">" "</span>;
   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">")."</span> &lt;&lt; <span class="hljs-built_in">endl</span>;

   <span class="hljs-comment">// Remove elements with a value greater than 6</span>
   new_end = remove_copy_if ( v1.begin( ), v1.end( ),
      v2.begin( ), greater6 );

   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"After the appliation of remove_copy_if to v1,\n "</span>
        &lt;&lt; <span class="hljs-string">"vector v1 is left unchanged as ( "</span> ;
   <span class="hljs-keyword">for</span> ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ; Iter1++ )
      <span class="hljs-built_in">cout</span> &lt;&lt; *Iter1 &lt;&lt; <span class="hljs-string">" "</span>;
   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">")."</span> &lt;&lt; <span class="hljs-built_in">endl</span>;

   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Vector v2 is a copy of v1 with values greater "</span>
        &lt;&lt; <span class="hljs-string">"than 6 removed:\n ( "</span> ;
   <span class="hljs-keyword">for</span> ( Iter2 = v2.begin( ) ; Iter2 != new_end ; Iter2++ )
      <span class="hljs-built_in">cout</span> &lt;&lt; *Iter2 &lt;&lt; <span class="hljs-string">" "</span>;
   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">")."</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
}
</code></pre>
<h2 id="remove_if" class="heading-with-anchor">  remove_if<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#remove_if"></a></h2>
<p>Eliminates elements that satisfy a predicate from a given range without disturbing the order of the remaining elements and returning the end of a new range free of the specified value.</p>
<div class="codeHeader" id="code-try-117" data-bi-name="code-header"><span class="language">C++</span>
			<button class="action" data-bi-name="copy">
				<span class="docon docon-edit-copy" role="presentation"></span>
				<span>Copy</span>
			</button></div><pre><code class="lang-cpp" data-author-content="template&lt;class ForwardIterator, class Predicate&gt;
ForwardIterator remove_if(
    ForwardIterator first,
    ForwardIterator last,
    Predicate pred);
"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ForwardIterator</span>, <span class="hljs-title">class</span> <span class="hljs-title">Predicate</span>&gt;
<span class="hljs-title">ForwardIterator</span> <span class="hljs-title">remove_if</span>(
    <span class="hljs-title">ForwardIterator</span> <span class="hljs-title">first</span>,
    <span class="hljs-title">ForwardIterator</span> <span class="hljs-title">last</span>,
    <span class="hljs-title">Predicate</span> <span class="hljs-title">pred</span>);</span>
</code></pre>
<h3 id="parameters-58" class="heading-with-anchor">Parameters<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#parameters-58"></a></h3>
<p><em>first</em><br>
A forward iterator pointing to the position of the first element in the range from which elements are being removed.</p>
<p><em>last</em><br>
A forward iterator pointing to the position one past the final element in the range from which elements are being removed.</p>
<p><em>_Pred</em><br>
The unary predicate that must be satisfied is the value of an element is to be replaced.</p>
<h3 id="return-value-43" class="heading-with-anchor">Return Value<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#return-value-43"></a></h3>
<p>A forward iterator addressing the new end position of the modified range, one past the final element of the remnant sequence free of the specified value.</p>
<h3 id="remarks-58" class="heading-with-anchor">Remarks<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#remarks-58"></a></h3>
<p>The range referenced must be valid; all pointers must be dereferenceable and within the sequence the last position is reachable from the first by incrementation.</p>
<p>The order of the elements not removed remains stable.</p>
<p>The <code>operator==</code> used to determine the equality between elements must impose an equivalence relation between its operands.</p>
<p>The complexity is linear: there are (<code>last</code> - <code>first</code>) comparisons for equality.</p>
<p>List has a more efficient member function version of remove which relinks pointers.</p>
<h3 id="example-40" class="heading-with-anchor">Example<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#example-40"></a></h3>
<div class="codeHeader" id="code-try-118" data-bi-name="code-header"><span class="language">C++</span>
			<button class="action" data-bi-name="copy">
				<span class="docon docon-edit-copy" role="presentation"></span>
				<span>Copy</span>
			</button></div><pre><code class="lang-cpp" data-author-content="// alg_remove_if.cpp
// compile with: /EHsc
#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;iostream&gt;

bool greater6 ( int value ) {
   return value &gt; 6;
}

int main() {
   using namespace std;
   vector &lt;int&gt; v1, v2;
   vector &lt;int&gt;::iterator Iter1, Iter2, new_end;

   int i;
   for ( i = 0 ; i &lt;= 9 ; i++ )
      v1.push_back( i );

   int ii;
   for ( ii = 0 ; ii &lt;= 3 ; ii++ )
      v1.push_back( 7 );

   random_shuffle ( v1.begin( ), v1.end( ) );
   cout &lt;&lt; &quot;Vector v1 is ( &quot; ;
   for ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ; Iter1++ )
      cout &lt;&lt; *Iter1 &lt;&lt; &quot; &quot;;
   cout &lt;&lt; &quot;).&quot; &lt;&lt; endl;

   // Remove elements satisfying predicate greater6
   new_end = remove_if (v1.begin( ), v1.end( ), greater6 );

   cout &lt;&lt; &quot;Vector v1 with elements satisfying greater6 removed is\n ( &quot; ;
   for ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ; Iter1++ )
      cout &lt;&lt; *Iter1 &lt;&lt; &quot; &quot;;
   cout &lt;&lt; &quot;).&quot; &lt;&lt; endl;

   // To change the sequence size, use erase
   v1.erase (new_end, v1.end( ) );

   cout &lt;&lt; &quot;Vector v1 resized elements satisfying greater6 removed is\n ( &quot; ;
   for ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ; Iter1++ )
      cout &lt;&lt; *Iter1 &lt;&lt; &quot; &quot;;
   cout &lt;&lt; &quot;).&quot; &lt;&lt; endl;
}
"><span class="hljs-comment">// alg_remove_if.cpp</span>
<span class="hljs-comment">// compile with: /EHsc</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span>

<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">greater6</span> <span class="hljs-params">( <span class="hljs-keyword">int</span> value )</span> </span>{
   <span class="hljs-keyword">return</span> value &gt; <span class="hljs-number">6</span>;
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
   <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;
   <span class="hljs-built_in">vector</span> &lt;<span class="hljs-keyword">int</span>&gt; v1, v2;
   <span class="hljs-built_in">vector</span> &lt;<span class="hljs-keyword">int</span>&gt;::iterator Iter1, Iter2, new_end;

   <span class="hljs-keyword">int</span> i;
   <span class="hljs-keyword">for</span> ( i = <span class="hljs-number">0</span> ; i &lt;= <span class="hljs-number">9</span> ; i++ )
      v1.push_back( i );

   <span class="hljs-keyword">int</span> ii;
   <span class="hljs-keyword">for</span> ( ii = <span class="hljs-number">0</span> ; ii &lt;= <span class="hljs-number">3</span> ; ii++ )
      v1.push_back( <span class="hljs-number">7</span> );

   random_shuffle ( v1.begin( ), v1.end( ) );
   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Vector v1 is ( "</span> ;
   <span class="hljs-keyword">for</span> ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ; Iter1++ )
      <span class="hljs-built_in">cout</span> &lt;&lt; *Iter1 &lt;&lt; <span class="hljs-string">" "</span>;
   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">")."</span> &lt;&lt; <span class="hljs-built_in">endl</span>;

   <span class="hljs-comment">// Remove elements satisfying predicate greater6</span>
   new_end = remove_if (v1.begin( ), v1.end( ), greater6 );

   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Vector v1 with elements satisfying greater6 removed is\n ( "</span> ;
   <span class="hljs-keyword">for</span> ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ; Iter1++ )
      <span class="hljs-built_in">cout</span> &lt;&lt; *Iter1 &lt;&lt; <span class="hljs-string">" "</span>;
   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">")."</span> &lt;&lt; <span class="hljs-built_in">endl</span>;

   <span class="hljs-comment">// To change the sequence size, use erase</span>
   v1.erase (new_end, v1.end( ) );

   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Vector v1 resized elements satisfying greater6 removed is\n ( "</span> ;
   <span class="hljs-keyword">for</span> ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ; Iter1++ )
      <span class="hljs-built_in">cout</span> &lt;&lt; *Iter1 &lt;&lt; <span class="hljs-string">" "</span>;
   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">")."</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
}
</code></pre>
<h2 id="replace" class="heading-with-anchor">  replace<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#replace"></a></h2>
<p>Examines each element in a range and replaces it if it matches a specified value.</p>
<div class="codeHeader" id="code-try-119" data-bi-name="code-header"><span class="language">C++</span>
			<button class="action" data-bi-name="copy">
				<span class="docon docon-edit-copy" role="presentation"></span>
				<span>Copy</span>
			</button></div><pre><code class="lang-cpp" data-author-content="template&lt;class ForwardIterator, class Type&gt;
void replace(
    ForwardIterator first,
    ForwardIterator last,
    const Type&amp; oldVal,
    const Type&amp; newVal);
"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ForwardIterator</span>, <span class="hljs-title">class</span> <span class="hljs-title">Type</span>&gt;
<span class="hljs-title">void</span> <span class="hljs-title">replace</span>(
    <span class="hljs-title">ForwardIterator</span> <span class="hljs-title">first</span>,
    <span class="hljs-title">ForwardIterator</span> <span class="hljs-title">last</span>,
    <span class="hljs-title">const</span> <span class="hljs-title">Type</span>&amp; <span class="hljs-title">oldVal</span>,
    <span class="hljs-title">const</span> <span class="hljs-title">Type</span>&amp; <span class="hljs-title">newVal</span>);</span>
</code></pre>
<h3 id="parameters-59" class="heading-with-anchor">Parameters<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#parameters-59"></a></h3>
<p><em>first</em><br>
A forward iterator pointing to the position of the first element in the range from which elements are being replaced.</p>
<p><em>last</em><br>
A forward iterator pointing to the position one past the final element in the range from which elements are being replaced.</p>
<p><em>_OldVal</em><br>
The old value of the elements being replaced.</p>
<p><em>_NewVal</em><br>
The new value being assigned to the elements with the old value.</p>
<h3 id="remarks-59" class="heading-with-anchor">Remarks<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#remarks-59"></a></h3>
<p>The range referenced must be valid; all pointers must be dereferenceable and within the sequence the last position is reachable from the first by incrementation.</p>
<p>The order of the elements not replaced remains stable.</p>
<p>The <code>operator==</code> used to determine the equality between elements must impose an equivalence relation between its operands.</p>
<p>The complexity is linear; there are (<code>last</code> - <code>first</code>) comparisons for equality and at most (<code>last</code> - <code>first</code>) assignments of new values.</p>
<h3 id="example-41" class="heading-with-anchor">Example<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#example-41"></a></h3>
<div class="codeHeader" id="code-try-120" data-bi-name="code-header"><span class="language">C++</span>
			<button class="action" data-bi-name="copy">
				<span class="docon docon-edit-copy" role="presentation"></span>
				<span>Copy</span>
			</button></div><pre><code class="lang-cpp" data-author-content="// alg_replace.cpp
// compile with: /EHsc
#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;iostream&gt;

int main() {
   using namespace std;
   vector &lt;int&gt; v1;
   vector &lt;int&gt;::iterator Iter1;

   int i;
   for ( i = 0 ; i &lt;= 9 ; i++ )
      v1.push_back( i );

   int ii;
   for ( ii = 0 ; ii &lt;= 3 ; ii++ )
      v1.push_back( 7 );

   random_shuffle (v1.begin( ), v1.end( ) );
   cout &lt;&lt; &quot;The original vector v1 is:\n ( &quot; ;
   for ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ; Iter1++ )
      cout &lt;&lt; *Iter1 &lt;&lt; &quot; &quot;;
   cout &lt;&lt; &quot;).&quot; &lt;&lt; endl;

   // Replace elements with a value of 7 with a value of 700
   replace (v1.begin( ), v1.end( ), 7 , 700);

   cout &lt;&lt; &quot;The vector v1 with a value 700 replacing that of 7 is:\n ( &quot; ;
   for ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ; Iter1++ )
      cout &lt;&lt; *Iter1 &lt;&lt; &quot; &quot;;
   cout &lt;&lt; &quot;).&quot; &lt;&lt; endl;
}
"><span class="hljs-comment">// alg_replace.cpp</span>
<span class="hljs-comment">// compile with: /EHsc</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span>

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
   <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;
   <span class="hljs-built_in">vector</span> &lt;<span class="hljs-keyword">int</span>&gt; v1;
   <span class="hljs-built_in">vector</span> &lt;<span class="hljs-keyword">int</span>&gt;::iterator Iter1;

   <span class="hljs-keyword">int</span> i;
   <span class="hljs-keyword">for</span> ( i = <span class="hljs-number">0</span> ; i &lt;= <span class="hljs-number">9</span> ; i++ )
      v1.push_back( i );

   <span class="hljs-keyword">int</span> ii;
   <span class="hljs-keyword">for</span> ( ii = <span class="hljs-number">0</span> ; ii &lt;= <span class="hljs-number">3</span> ; ii++ )
      v1.push_back( <span class="hljs-number">7</span> );

   random_shuffle (v1.begin( ), v1.end( ) );
   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"The original vector v1 is:\n ( "</span> ;
   <span class="hljs-keyword">for</span> ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ; Iter1++ )
      <span class="hljs-built_in">cout</span> &lt;&lt; *Iter1 &lt;&lt; <span class="hljs-string">" "</span>;
   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">")."</span> &lt;&lt; <span class="hljs-built_in">endl</span>;

   <span class="hljs-comment">// Replace elements with a value of 7 with a value of 700</span>
   replace (v1.begin( ), v1.end( ), <span class="hljs-number">7</span> , <span class="hljs-number">700</span>);

   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"The vector v1 with a value 700 replacing that of 7 is:\n ( "</span> ;
   <span class="hljs-keyword">for</span> ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ; Iter1++ )
      <span class="hljs-built_in">cout</span> &lt;&lt; *Iter1 &lt;&lt; <span class="hljs-string">" "</span>;
   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">")."</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
}
</code></pre>
<h2 id="replace_copy" class="heading-with-anchor">  replace_copy<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#replace_copy"></a></h2>
<p>Examines each element in a source range and replaces it if it matches a specified value while copying the result into a new destination range.</p>
<div class="codeHeader" id="code-try-121" data-bi-name="code-header"><span class="language">C++</span>
			<button class="action" data-bi-name="copy">
				<span class="docon docon-edit-copy" role="presentation"></span>
				<span>Copy</span>
			</button></div><pre><code class="lang-cpp" data-author-content="template&lt;class InputIterator, class OutputIterator, class Type&gt;
OutputIterator replace_copy(
    InputIterator first,
    InputIterator last,
    OutputIterator result,
    const Type&amp; oldVal,
    const Type&amp; newVal);
"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InputIterator</span>, <span class="hljs-title">class</span> <span class="hljs-title">OutputIterator</span>, <span class="hljs-title">class</span> <span class="hljs-title">Type</span>&gt;
<span class="hljs-title">OutputIterator</span> <span class="hljs-title">replace_copy</span>(
    <span class="hljs-title">InputIterator</span> <span class="hljs-title">first</span>,
    <span class="hljs-title">InputIterator</span> <span class="hljs-title">last</span>,
    <span class="hljs-title">OutputIterator</span> <span class="hljs-title">result</span>,
    <span class="hljs-title">const</span> <span class="hljs-title">Type</span>&amp; <span class="hljs-title">oldVal</span>,
    <span class="hljs-title">const</span> <span class="hljs-title">Type</span>&amp; <span class="hljs-title">newVal</span>);</span>
</code></pre>
<h3 id="parameters-60" class="heading-with-anchor">Parameters<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#parameters-60"></a></h3>
<p><em>first</em><br>
An input iterator pointing to the position of the first element in the range from which elements are being replaced.</p>
<p><em>last</em><br>
An input iterator pointing to the position one past the final element in the range from which elements are being replaced.</p>
<p><em>result</em><br>
An output iterator pointing to the first element in the destination range to where the altered sequence of elements is being copied.</p>
<p><em>_OldVal</em><br>
The old value of the elements being replaced.</p>
<p><em>_NewVal</em><br>
The new value being assigned to the elements with the old value.</p>
<h3 id="return-value-44" class="heading-with-anchor">Return Value<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#return-value-44"></a></h3>
<p>An output iterator pointing to the position one past the final element in the destination range to where the altered sequence of elements is being copied.</p>
<h3 id="remarks-60" class="heading-with-anchor">Remarks<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#remarks-60"></a></h3>
<p>The source and destination ranges referenced must not overlap and must both be valid: all pointers must be dereferenceable and within the sequences the last position is reachable from the first by incrementation.</p>
<p>The order of the elements not replaced remains stable.</p>
<p>The <code>operator==</code> used to determine the equality between elements must impose an equivalence relation between its operands.</p>
<p>The complexity is linear: there are (<code>last</code> - <code>first</code>) comparisons for equality and at most (<code>last</code> - <code>first</code>) assignments of new values.</p>
<h3 id="example-42" class="heading-with-anchor">Example<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#example-42"></a></h3>
<div class="codeHeader" id="code-try-122" data-bi-name="code-header"><span class="language">C++</span>
			<button class="action" data-bi-name="copy">
				<span class="docon docon-edit-copy" role="presentation"></span>
				<span>Copy</span>
			</button></div><pre><code class="lang-cpp" data-author-content="// alg_replace_copy.cpp
// compile with: /EHsc
#include &lt;vector&gt;
#include &lt;list&gt;
#include &lt;algorithm&gt;
#include &lt;iostream&gt;

int main() {
   using namespace std;
   vector &lt;int&gt; v1;
   list &lt;int&gt; L1 (15);
   vector &lt;int&gt;::iterator Iter1;
   list &lt;int&gt;::iterator L_Iter1;

   int i;
   for ( i = 0 ; i &lt;= 9 ; i++ )
      v1.push_back( i );

   int ii;
   for ( ii = 0 ; ii &lt;= 3 ; ii++ )
      v1.push_back( 7 );

   random_shuffle ( v1.begin( ), v1.end( ) );

   int iii;
   for ( iii = 0 ; iii &lt;= 15 ; iii++ )
      v1.push_back( 1 );

   cout &lt;&lt; &quot;The original vector v1 is:\n ( &quot; ;
   for ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ; Iter1++ )
      cout &lt;&lt; *Iter1 &lt;&lt; &quot; &quot;;
   cout &lt;&lt; &quot;).&quot; &lt;&lt; endl;

   // Replace elements in one part of a vector with a value of 7
   // with a value of 70 and copy into another part of the vector
   replace_copy ( v1.begin( ), v1.begin( ) + 14,v1.end( ) -15, 7 , 70);

   cout &lt;&lt; &quot;The vector v1 with a value 70 replacing that of 7 is:\n ( &quot; ;
   for ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ; Iter1++ )
      cout &lt;&lt; *Iter1 &lt;&lt; &quot; &quot;;
   cout &lt;&lt; &quot;).&quot; &lt;&lt; endl;

   // Replace elements in a vector with a value of 70
   // with a value of 1 and copy into a list
   replace_copy ( v1.begin( ), v1.begin( ) + 14,L1.begin( ), 7 , 1);

   cout &lt;&lt; &quot;The list copy L1 of v1 with the value 0 replacing &quot;
        &lt;&lt; &quot;that of 7 is:\n ( &quot; ;
   for ( L_Iter1 = L1.begin( ) ; L_Iter1 != L1.end( ) ; L_Iter1++ )
      cout &lt;&lt; *L_Iter1 &lt;&lt; &quot; &quot;;
   cout &lt;&lt; &quot;).&quot; &lt;&lt; endl;
}
"><span class="hljs-comment">// alg_replace_copy.cpp</span>
<span class="hljs-comment">// compile with: /EHsc</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;list&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span>

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
   <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;
   <span class="hljs-built_in">vector</span> &lt;<span class="hljs-keyword">int</span>&gt; v1;
   <span class="hljs-built_in">list</span> &lt;<span class="hljs-keyword">int</span>&gt; L1 (<span class="hljs-number">15</span>);
   <span class="hljs-built_in">vector</span> &lt;<span class="hljs-keyword">int</span>&gt;::iterator Iter1;
   <span class="hljs-built_in">list</span> &lt;<span class="hljs-keyword">int</span>&gt;::iterator L_Iter1;

   <span class="hljs-keyword">int</span> i;
   <span class="hljs-keyword">for</span> ( i = <span class="hljs-number">0</span> ; i &lt;= <span class="hljs-number">9</span> ; i++ )
      v1.push_back( i );

   <span class="hljs-keyword">int</span> ii;
   <span class="hljs-keyword">for</span> ( ii = <span class="hljs-number">0</span> ; ii &lt;= <span class="hljs-number">3</span> ; ii++ )
      v1.push_back( <span class="hljs-number">7</span> );

   random_shuffle ( v1.begin( ), v1.end( ) );

   <span class="hljs-keyword">int</span> iii;
   <span class="hljs-keyword">for</span> ( iii = <span class="hljs-number">0</span> ; iii &lt;= <span class="hljs-number">15</span> ; iii++ )
      v1.push_back( <span class="hljs-number">1</span> );

   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"The original vector v1 is:\n ( "</span> ;
   <span class="hljs-keyword">for</span> ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ; Iter1++ )
      <span class="hljs-built_in">cout</span> &lt;&lt; *Iter1 &lt;&lt; <span class="hljs-string">" "</span>;
   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">")."</span> &lt;&lt; <span class="hljs-built_in">endl</span>;

   <span class="hljs-comment">// Replace elements in one part of a vector with a value of 7</span>
   <span class="hljs-comment">// with a value of 70 and copy into another part of the vector</span>
   replace_copy ( v1.begin( ), v1.begin( ) + <span class="hljs-number">14</span>,v1.end( ) <span class="hljs-number">-15</span>, <span class="hljs-number">7</span> , <span class="hljs-number">70</span>);

   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"The vector v1 with a value 70 replacing that of 7 is:\n ( "</span> ;
   <span class="hljs-keyword">for</span> ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ; Iter1++ )
      <span class="hljs-built_in">cout</span> &lt;&lt; *Iter1 &lt;&lt; <span class="hljs-string">" "</span>;
   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">")."</span> &lt;&lt; <span class="hljs-built_in">endl</span>;

   <span class="hljs-comment">// Replace elements in a vector with a value of 70</span>
   <span class="hljs-comment">// with a value of 1 and copy into a list</span>
   replace_copy ( v1.begin( ), v1.begin( ) + <span class="hljs-number">14</span>,L1.begin( ), <span class="hljs-number">7</span> , <span class="hljs-number">1</span>);

   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"The list copy L1 of v1 with the value 0 replacing "</span>
        &lt;&lt; <span class="hljs-string">"that of 7 is:\n ( "</span> ;
   <span class="hljs-keyword">for</span> ( L_Iter1 = L1.begin( ) ; L_Iter1 != L1.end( ) ; L_Iter1++ )
      <span class="hljs-built_in">cout</span> &lt;&lt; *L_Iter1 &lt;&lt; <span class="hljs-string">" "</span>;
   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">")."</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
}
</code></pre>
<h2 id="replace_copy_if" class="heading-with-anchor">  replace_copy_if<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#replace_copy_if"></a></h2>
<p>Examines each element in a source range and replaces it if it satisfies a specified predicate while copying the result into a new destination range.</p>
<div class="codeHeader" id="code-try-123" data-bi-name="code-header"><span class="language">C++</span>
			<button class="action" data-bi-name="copy">
				<span class="docon docon-edit-copy" role="presentation"></span>
				<span>Copy</span>
			</button></div><pre><code class="lang-cpp" data-author-content="template&lt;class InputIterator, class OutputIterator, class Predicate, class Type&gt;
OutputIterator replace_copy_if(
    InputIterator first,
    InputIterator last,
    OutputIterator result,
    Predicate pred,
    const Type&amp; val);
"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InputIterator</span>, <span class="hljs-title">class</span> <span class="hljs-title">OutputIterator</span>, <span class="hljs-title">class</span> <span class="hljs-title">Predicate</span>, <span class="hljs-title">class</span> <span class="hljs-title">Type</span>&gt;
<span class="hljs-title">OutputIterator</span> <span class="hljs-title">replace_copy_if</span>(
    <span class="hljs-title">InputIterator</span> <span class="hljs-title">first</span>,
    <span class="hljs-title">InputIterator</span> <span class="hljs-title">last</span>,
    <span class="hljs-title">OutputIterator</span> <span class="hljs-title">result</span>,
    <span class="hljs-title">Predicate</span> <span class="hljs-title">pred</span>,
    <span class="hljs-title">const</span> <span class="hljs-title">Type</span>&amp; <span class="hljs-title">val</span>);</span>
</code></pre>
<h3 id="parameters-61" class="heading-with-anchor">Parameters<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#parameters-61"></a></h3>
<p><em>first</em><br>
An input iterator pointing to the position of the first element in the range from which elements are being replaced.</p>
<p><em>last</em><br>
An input iterator pointing to the position one past the final element in the range from which elements are being replaced.</p>
<p><em>result</em><br>
An output iterator pointing to the position of the first element in the destination range to which elements are being copied.</p>
<p><em>_Pred</em><br>
The unary predicate that must be satisfied is the value of an element is to be replaced.</p>
<p><em>val</em><br>
The new value being assigned to the elements whose old value satisfies the predicate.</p>
<h3 id="return-value-45" class="heading-with-anchor">Return Value<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#return-value-45"></a></h3>
<p>An output iterator pointing to the position one past the final element in the destination range to where the altered sequence of elements is being copied.</p>
<h3 id="remarks-61" class="heading-with-anchor">Remarks<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#remarks-61"></a></h3>
<p>The source and destination ranges referenced must not overlap and must both be valid: all pointers must be dereferenceable and within the sequences the last position is reachable from the first by incrementation.</p>
<p>The order of the elements not replaced remains stable.</p>
<p>The <code>operator==</code> used to determine the equality between elements must impose an equivalence relation between its operands.</p>
<p>The complexity is linear; there are (<code>last</code> - <code>first</code>) comparisons for equality and at most (<code>last</code> - <code>first</code>) assignments of new values.</p>
<h3 id="example-43" class="heading-with-anchor">Example<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#example-43"></a></h3>
<div class="codeHeader" id="code-try-124" data-bi-name="code-header"><span class="language">C++</span>
			<button class="action" data-bi-name="copy">
				<span class="docon docon-edit-copy" role="presentation"></span>
				<span>Copy</span>
			</button></div><pre><code class="lang-cpp" data-author-content="// alg_replace_copy_if.cpp
// compile with: /EHsc
#include &lt;vector&gt;
#include &lt;list&gt;
#include &lt;algorithm&gt;
#include &lt;iostream&gt;

bool greater6 ( int value ) {
   return value &gt; 6;
}

int main() {
   using namespace std;
   vector &lt;int&gt; v1;
   list &lt;int&gt; L1 (13);
   vector &lt;int&gt;::iterator Iter1;
   list &lt;int&gt;::iterator L_Iter1;

   int i;
   for ( i = 0 ; i &lt;= 9 ; i++ )
      v1.push_back( i );

   int ii;
   for ( ii = 0 ; ii &lt;= 3 ; ii++ )
      v1.push_back( 7 );

   random_shuffle ( v1.begin( ), v1.end( ) );

   int iii;
   for ( iii = 0 ; iii &lt;= 13 ; iii++ )
      v1.push_back( 1 );

   cout &lt;&lt; &quot;The original vector v1 is:\n ( &quot; ;
   for ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ; Iter1++ )
      cout &lt;&lt; *Iter1 &lt;&lt; &quot; &quot;;
   cout &lt;&lt; &quot;).&quot; &lt;&lt; endl;

   // Replace elements with a value of 7 in the 1st half of a vector
   // with a value of 70 and copy it into the 2nd half of the vector
   replace_copy_if ( v1.begin( ), v1.begin( ) + 14,v1.end( ) -14,
      greater6 , 70);

   cout &lt;&lt; &quot;The vector v1 with values of 70 replacing those greater&quot;
        &lt;&lt; &quot;\n than 6 in the 1st half &amp; copied into the 2nd half is:\n ( &quot; ;
   for ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ; Iter1++ )
      cout &lt;&lt; *Iter1 &lt;&lt; &quot; &quot;;
   cout &lt;&lt; &quot;).&quot; &lt;&lt; endl;

   // Replace elements in a vector with a value of 70
   // with a value of 1 and copy into a list
   replace_copy_if ( v1.begin( ), v1.begin( ) + 13,L1.begin( ),
      greater6 , -1 );

   cout &lt;&lt; &quot;A list copy of vector v1 with the value -1\n replacing &quot;
        &lt;&lt; &quot;those greater than 6 is:\n ( &quot; ;
   for ( L_Iter1 = L1.begin( ) ; L_Iter1 != L1.end( ) ; L_Iter1++ )
      cout &lt;&lt; *L_Iter1 &lt;&lt; &quot; &quot;;
   cout &lt;&lt; &quot;).&quot; &lt;&lt; endl;
}
"><span class="hljs-comment">// alg_replace_copy_if.cpp</span>
<span class="hljs-comment">// compile with: /EHsc</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;list&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span>

<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">greater6</span> <span class="hljs-params">( <span class="hljs-keyword">int</span> value )</span> </span>{
   <span class="hljs-keyword">return</span> value &gt; <span class="hljs-number">6</span>;
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
   <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;
   <span class="hljs-built_in">vector</span> &lt;<span class="hljs-keyword">int</span>&gt; v1;
   <span class="hljs-built_in">list</span> &lt;<span class="hljs-keyword">int</span>&gt; L1 (<span class="hljs-number">13</span>);
   <span class="hljs-built_in">vector</span> &lt;<span class="hljs-keyword">int</span>&gt;::iterator Iter1;
   <span class="hljs-built_in">list</span> &lt;<span class="hljs-keyword">int</span>&gt;::iterator L_Iter1;

   <span class="hljs-keyword">int</span> i;
   <span class="hljs-keyword">for</span> ( i = <span class="hljs-number">0</span> ; i &lt;= <span class="hljs-number">9</span> ; i++ )
      v1.push_back( i );

   <span class="hljs-keyword">int</span> ii;
   <span class="hljs-keyword">for</span> ( ii = <span class="hljs-number">0</span> ; ii &lt;= <span class="hljs-number">3</span> ; ii++ )
      v1.push_back( <span class="hljs-number">7</span> );

   random_shuffle ( v1.begin( ), v1.end( ) );

   <span class="hljs-keyword">int</span> iii;
   <span class="hljs-keyword">for</span> ( iii = <span class="hljs-number">0</span> ; iii &lt;= <span class="hljs-number">13</span> ; iii++ )
      v1.push_back( <span class="hljs-number">1</span> );

   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"The original vector v1 is:\n ( "</span> ;
   <span class="hljs-keyword">for</span> ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ; Iter1++ )
      <span class="hljs-built_in">cout</span> &lt;&lt; *Iter1 &lt;&lt; <span class="hljs-string">" "</span>;
   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">")."</span> &lt;&lt; <span class="hljs-built_in">endl</span>;

   <span class="hljs-comment">// Replace elements with a value of 7 in the 1st half of a vector</span>
   <span class="hljs-comment">// with a value of 70 and copy it into the 2nd half of the vector</span>
   replace_copy_if ( v1.begin( ), v1.begin( ) + <span class="hljs-number">14</span>,v1.end( ) <span class="hljs-number">-14</span>,
      greater6 , <span class="hljs-number">70</span>);

   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"The vector v1 with values of 70 replacing those greater"</span>
        &lt;&lt; <span class="hljs-string">"\n than 6 in the 1st half &amp; copied into the 2nd half is:\n ( "</span> ;
   <span class="hljs-keyword">for</span> ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ; Iter1++ )
      <span class="hljs-built_in">cout</span> &lt;&lt; *Iter1 &lt;&lt; <span class="hljs-string">" "</span>;
   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">")."</span> &lt;&lt; <span class="hljs-built_in">endl</span>;

   <span class="hljs-comment">// Replace elements in a vector with a value of 70</span>
   <span class="hljs-comment">// with a value of 1 and copy into a list</span>
   replace_copy_if ( v1.begin( ), v1.begin( ) + <span class="hljs-number">13</span>,L1.begin( ),
      greater6 , <span class="hljs-number">-1</span> );

   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"A list copy of vector v1 with the value -1\n replacing "</span>
        &lt;&lt; <span class="hljs-string">"those greater than 6 is:\n ( "</span> ;
   <span class="hljs-keyword">for</span> ( L_Iter1 = L1.begin( ) ; L_Iter1 != L1.end( ) ; L_Iter1++ )
      <span class="hljs-built_in">cout</span> &lt;&lt; *L_Iter1 &lt;&lt; <span class="hljs-string">" "</span>;
   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">")."</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
}
</code></pre>
<h2 id="replace_if" class="heading-with-anchor">  replace_if<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#replace_if"></a></h2>
<p>Examines each element in a range and replaces it if it satisfies a specified predicate.</p>
<div class="codeHeader" id="code-try-125" data-bi-name="code-header"><span class="language">C++</span>
			<button class="action" data-bi-name="copy">
				<span class="docon docon-edit-copy" role="presentation"></span>
				<span>Copy</span>
			</button></div><pre><code class="lang-cpp" data-author-content="template&lt;class ForwardIterator, class Predicate, class Type&gt;
void replace_if(
    ForwardIterator first,
    ForwardIterator last,
    Predicate pred,
    const Type&amp; val);
"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ForwardIterator</span>, <span class="hljs-title">class</span> <span class="hljs-title">Predicate</span>, <span class="hljs-title">class</span> <span class="hljs-title">Type</span>&gt;
<span class="hljs-title">void</span> <span class="hljs-title">replace_if</span>(
    <span class="hljs-title">ForwardIterator</span> <span class="hljs-title">first</span>,
    <span class="hljs-title">ForwardIterator</span> <span class="hljs-title">last</span>,
    <span class="hljs-title">Predicate</span> <span class="hljs-title">pred</span>,
    <span class="hljs-title">const</span> <span class="hljs-title">Type</span>&amp; <span class="hljs-title">val</span>);</span>
</code></pre>
<h3 id="parameters-62" class="heading-with-anchor">Parameters<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#parameters-62"></a></h3>
<p><em>first</em><br>
A forward iterator pointing to the position of the first element in the range from which elements are being replaced.</p>
<p><em>last</em><br>
An iterator pointing to the position one past the final element in the range from which elements are being replaced.</p>
<p><em>_Pred</em><br>
The unary predicate that must be satisfied is the value of an element is to be replaced.</p>
<p><em>val</em><br>
The new value being assigned to the elements whose old value satisfies the predicate.</p>
<h3 id="remarks-62" class="heading-with-anchor">Remarks<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#remarks-62"></a></h3>
<p>The range referenced must be valid; all pointers must be dereferenceable and within the sequence the last position is reachable from the first by incrementation.</p>
<p>The order of the elements not replaced remains stable.</p>
<p>The algorithm <code>replace_if</code> is a generalization of the algorithm <code>replace</code>, allowing any predicate to be specified, rather than equality to a specified constant value.</p>
<p>The <code>operator==</code> used to determine the equality between elements must impose an equivalence relation between its operands.</p>
<p>The complexity is linear: there are (<code>last</code> - <code>first</code>) comparisons for equality and at most (<code>last</code> - <code>first</code>) assignments of new values.</p>
<h3 id="example-44" class="heading-with-anchor">Example<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#example-44"></a></h3>
<div class="codeHeader" id="code-try-126" data-bi-name="code-header"><span class="language">C++</span>
			<button class="action" data-bi-name="copy">
				<span class="docon docon-edit-copy" role="presentation"></span>
				<span>Copy</span>
			</button></div><pre><code class="lang-cpp" data-author-content="// alg_replace_if.cpp
// compile with: /EHsc
#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;iostream&gt;

bool greater6 ( int value ) {
   return value &gt; 6;
}

int main() {
   using namespace std;
   vector &lt;int&gt; v1;
   vector &lt;int&gt;::iterator Iter1;

   int i;
   for ( i = 0 ; i &lt;= 9 ; i++ )
      v1.push_back( i );

   int ii;
   for ( ii = 0 ; ii &lt;= 3 ; ii++ )
      v1.push_back( 7 );

   random_shuffle ( v1.begin( ), v1.end( ) );
   cout &lt;&lt; &quot;The original vector v1 is:\n ( &quot; ;
   for ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ; Iter1++ )
      cout &lt;&lt; *Iter1 &lt;&lt; &quot; &quot;;
   cout &lt;&lt; &quot;).&quot; &lt;&lt; endl;

   // Replace elements satisfying the predicate greater6
   // with a value of 70
   replace_if ( v1.begin( ), v1.end( ), greater6 , 70);

   cout &lt;&lt; &quot;The vector v1 with a value 70 replacing those\n &quot;
        &lt;&lt; &quot;elements satisfying the greater6 predicate is:\n ( &quot; ;
   for ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ; Iter1++ )
      cout &lt;&lt; *Iter1 &lt;&lt; &quot; &quot;;
   cout &lt;&lt; &quot;).&quot; &lt;&lt; endl;
}
"><span class="hljs-comment">// alg_replace_if.cpp</span>
<span class="hljs-comment">// compile with: /EHsc</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span>

<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">greater6</span> <span class="hljs-params">( <span class="hljs-keyword">int</span> value )</span> </span>{
   <span class="hljs-keyword">return</span> value &gt; <span class="hljs-number">6</span>;
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
   <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;
   <span class="hljs-built_in">vector</span> &lt;<span class="hljs-keyword">int</span>&gt; v1;
   <span class="hljs-built_in">vector</span> &lt;<span class="hljs-keyword">int</span>&gt;::iterator Iter1;

   <span class="hljs-keyword">int</span> i;
   <span class="hljs-keyword">for</span> ( i = <span class="hljs-number">0</span> ; i &lt;= <span class="hljs-number">9</span> ; i++ )
      v1.push_back( i );

   <span class="hljs-keyword">int</span> ii;
   <span class="hljs-keyword">for</span> ( ii = <span class="hljs-number">0</span> ; ii &lt;= <span class="hljs-number">3</span> ; ii++ )
      v1.push_back( <span class="hljs-number">7</span> );

   random_shuffle ( v1.begin( ), v1.end( ) );
   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"The original vector v1 is:\n ( "</span> ;
   <span class="hljs-keyword">for</span> ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ; Iter1++ )
      <span class="hljs-built_in">cout</span> &lt;&lt; *Iter1 &lt;&lt; <span class="hljs-string">" "</span>;
   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">")."</span> &lt;&lt; <span class="hljs-built_in">endl</span>;

   <span class="hljs-comment">// Replace elements satisfying the predicate greater6</span>
   <span class="hljs-comment">// with a value of 70</span>
   replace_if ( v1.begin( ), v1.end( ), greater6 , <span class="hljs-number">70</span>);

   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"The vector v1 with a value 70 replacing those\n "</span>
        &lt;&lt; <span class="hljs-string">"elements satisfying the greater6 predicate is:\n ( "</span> ;
   <span class="hljs-keyword">for</span> ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ; Iter1++ )
      <span class="hljs-built_in">cout</span> &lt;&lt; *Iter1 &lt;&lt; <span class="hljs-string">" "</span>;
   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">")."</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
}
</code></pre>
<h2 id="reverse" class="heading-with-anchor">  reverse<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#reverse"></a></h2>
<p>Reverses the order of the elements within a range.</p>
<div class="codeHeader" id="code-try-127" data-bi-name="code-header"><span class="language">C++</span>
			<button class="action" data-bi-name="copy">
				<span class="docon docon-edit-copy" role="presentation"></span>
				<span>Copy</span>
			</button></div><pre><code class="lang-cpp" data-author-content="template&lt;class BidirectionalIterator&gt;
void reverse(BidirectionalIterator first, BidirectionalIterator last);
"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BidirectionalIterator</span>&gt;
<span class="hljs-title">void</span> <span class="hljs-title">reverse</span>(<span class="hljs-title">BidirectionalIterator</span> <span class="hljs-title">first</span>, <span class="hljs-title">BidirectionalIterator</span> <span class="hljs-title">last</span>);</span>
</code></pre>
<h3 id="parameters-63" class="heading-with-anchor">Parameters<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#parameters-63"></a></h3>
<p><em>first</em><br>
A bidirectional iterator pointing to the position of the first element in the range within which the elements are being permuted.</p>
<p><em>last</em><br>
A bidirectional iterator pointing to the position one past the final element in the range within which the elements are being permuted.</p>
<h3 id="remarks-63" class="heading-with-anchor">Remarks<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#remarks-63"></a></h3>
<p>The source range referenced must be valid; all pointers must be dereferenceable and within the sequence the last position is reachable from the first by incrementation.</p>
<h3 id="example-45" class="heading-with-anchor">Example<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#example-45"></a></h3>
<div class="codeHeader" id="code-try-128" data-bi-name="code-header"><span class="language">C++</span>
			<button class="action" data-bi-name="copy">
				<span class="docon docon-edit-copy" role="presentation"></span>
				<span>Copy</span>
			</button></div><pre><code class="lang-cpp" data-author-content="// alg_reverse.cpp
// compile with: /EHsc
#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;iostream&gt;

int main() {
   using namespace std;
   vector &lt;int&gt; v1;
   vector &lt;int&gt;::iterator Iter1;

   int i;
   for ( i = 0 ; i &lt;= 9 ; i++ )
   {
      v1.push_back( i );
   }

   cout &lt;&lt; &quot;The original vector v1 is:\n ( &quot; ;
   for ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ; Iter1++ )
      cout &lt;&lt; *Iter1 &lt;&lt; &quot; &quot;;
   cout &lt;&lt; &quot;).&quot; &lt;&lt; endl;

   // Reverse the elements in the vector
   reverse (v1.begin( ), v1.end( ) );

   cout &lt;&lt; &quot;The modified vector v1 with values reversed is:\n ( &quot; ;
   for ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ; Iter1++ )
      cout &lt;&lt; *Iter1 &lt;&lt; &quot; &quot;;
   cout &lt;&lt; &quot;).&quot; &lt;&lt; endl;
}
"><span class="hljs-comment">// alg_reverse.cpp</span>
<span class="hljs-comment">// compile with: /EHsc</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span>

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
   <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;
   <span class="hljs-built_in">vector</span> &lt;<span class="hljs-keyword">int</span>&gt; v1;
   <span class="hljs-built_in">vector</span> &lt;<span class="hljs-keyword">int</span>&gt;::iterator Iter1;

   <span class="hljs-keyword">int</span> i;
   <span class="hljs-keyword">for</span> ( i = <span class="hljs-number">0</span> ; i &lt;= <span class="hljs-number">9</span> ; i++ )
   {
      v1.push_back( i );
   }

   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"The original vector v1 is:\n ( "</span> ;
   <span class="hljs-keyword">for</span> ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ; Iter1++ )
      <span class="hljs-built_in">cout</span> &lt;&lt; *Iter1 &lt;&lt; <span class="hljs-string">" "</span>;
   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">")."</span> &lt;&lt; <span class="hljs-built_in">endl</span>;

   <span class="hljs-comment">// Reverse the elements in the vector</span>
   reverse (v1.begin( ), v1.end( ) );

   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"The modified vector v1 with values reversed is:\n ( "</span> ;
   <span class="hljs-keyword">for</span> ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ; Iter1++ )
      <span class="hljs-built_in">cout</span> &lt;&lt; *Iter1 &lt;&lt; <span class="hljs-string">" "</span>;
   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">")."</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
}
</code></pre>
<div class="codeHeader" id="code-try-129" data-bi-name="code-header"><span class="language">Output</span>
			<button class="action" data-bi-name="copy">
				<span class="docon docon-edit-copy" role="presentation"></span>
				<span>Copy</span>
			</button></div><pre><code class="lang-Output" data-author-content="The original vector v1 is:
( 0 1 2 3 4 5 6 7 8 9 ).
The modified vector v1 with values reversed is:
( 9 8 7 6 5 4 3 2 1 0 ).
">The original vector v1 is:
( 0 1 2 3 4 5 6 7 8 9 ).
The modified vector v1 with values reversed is:
( 9 8 7 6 5 4 3 2 1 0 ).
</code></pre>
<h2 id="reverse_copy" class="heading-with-anchor">  reverse_copy<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#reverse_copy"></a></h2>
<p>Reverses the order of the elements within a source range while copying them into a destination range</p>
<div class="codeHeader" id="code-try-130" data-bi-name="code-header"><span class="language">C++</span>
			<button class="action" data-bi-name="copy">
				<span class="docon docon-edit-copy" role="presentation"></span>
				<span>Copy</span>
			</button></div><pre><code class="lang-cpp" data-author-content="template&lt;class BidirectionalIterator, class OutputIterator&gt;
OutputIterator reverse_copy(
    BidirectionalIterator first,
    BidirectionalIterator Last,
    OutputIterator result);
"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BidirectionalIterator</span>, <span class="hljs-title">class</span> <span class="hljs-title">OutputIterator</span>&gt;
<span class="hljs-title">OutputIterator</span> <span class="hljs-title">reverse_copy</span>(
    <span class="hljs-title">BidirectionalIterator</span> <span class="hljs-title">first</span>,
    <span class="hljs-title">BidirectionalIterator</span> <span class="hljs-title">Last</span>,
    <span class="hljs-title">OutputIterator</span> <span class="hljs-title">result</span>);</span>
</code></pre>
<h3 id="parameters-64" class="heading-with-anchor">Parameters<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#parameters-64"></a></h3>
<p><em>first</em><br>
A bidirectional iterator pointing to the position of the first element in the source range within which the elements are being permuted.</p>
<p><em>last</em><br>
A bidirectional iterator pointing to the position one past the final element in the source range within which the elements are being permuted.</p>
<p><em>result</em><br>
An output iterator pointing to the position of the first element in the destination range to which elements are being copied.</p>
<h3 id="return-value-46" class="heading-with-anchor">Return Value<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#return-value-46"></a></h3>
<p>An output iterator pointing to the position one past the final element in the destination range to where the altered sequence of elements is being copied.</p>
<h3 id="remarks-64" class="heading-with-anchor">Remarks<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#remarks-64"></a></h3>
<p>The source and destination ranges referenced must be valid; all pointers must be dereferenceable and within the sequence the last position is reachable from the first by incrementation.</p>
<h3 id="example-46" class="heading-with-anchor">Example<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#example-46"></a></h3>
<div class="codeHeader" id="code-try-131" data-bi-name="code-header"><span class="language">C++</span>
			<button class="action" data-bi-name="copy">
				<span class="docon docon-edit-copy" role="presentation"></span>
				<span>Copy</span>
			</button></div><pre><code class="lang-cpp" data-author-content="// alg_reverse_copy.cpp
// compile with: /EHsc
#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;iostream&gt;

int main() {
   using namespace std;
   vector &lt;int&gt; v1, v2( 10 );
   vector &lt;int&gt;::iterator Iter1, Iter2;

   int i;
   for ( i = 0 ; i &lt;= 9 ; i++ )
   {
      v1.push_back( i );
   }

   cout &lt;&lt; &quot;The original vector v1 is:\n ( &quot; ;
   for ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ; Iter1++ )
      cout &lt;&lt; *Iter1 &lt;&lt; &quot; &quot;;
   cout &lt;&lt; &quot;).&quot; &lt;&lt; endl;

   // Reverse the elements in the vector
   reverse_copy (v1.begin( ), v1.end( ), v2.begin( ) );

   cout &lt;&lt; &quot;The copy v2 of the reversed vector v1 is:\n ( &quot; ;
   for ( Iter2 = v2.begin( ) ; Iter2 != v2.end( ) ; Iter2++ )
      cout &lt;&lt; *Iter2 &lt;&lt; &quot; &quot;;
   cout &lt;&lt; &quot;).&quot; &lt;&lt; endl;

   cout &lt;&lt; &quot;The original vector v1 remains unmodified as:\n ( &quot; ;
   for ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ; Iter1++ )
      cout &lt;&lt; *Iter1 &lt;&lt; &quot; &quot;;
   cout &lt;&lt; &quot;).&quot; &lt;&lt; endl;
}
"><span class="hljs-comment">// alg_reverse_copy.cpp</span>
<span class="hljs-comment">// compile with: /EHsc</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span>

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
   <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;
   <span class="hljs-built_in">vector</span> &lt;<span class="hljs-keyword">int</span>&gt; v1, v2( <span class="hljs-number">10</span> );
   <span class="hljs-built_in">vector</span> &lt;<span class="hljs-keyword">int</span>&gt;::iterator Iter1, Iter2;

   <span class="hljs-keyword">int</span> i;
   <span class="hljs-keyword">for</span> ( i = <span class="hljs-number">0</span> ; i &lt;= <span class="hljs-number">9</span> ; i++ )
   {
      v1.push_back( i );
   }

   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"The original vector v1 is:\n ( "</span> ;
   <span class="hljs-keyword">for</span> ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ; Iter1++ )
      <span class="hljs-built_in">cout</span> &lt;&lt; *Iter1 &lt;&lt; <span class="hljs-string">" "</span>;
   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">")."</span> &lt;&lt; <span class="hljs-built_in">endl</span>;

   <span class="hljs-comment">// Reverse the elements in the vector</span>
   reverse_copy (v1.begin( ), v1.end( ), v2.begin( ) );

   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"The copy v2 of the reversed vector v1 is:\n ( "</span> ;
   <span class="hljs-keyword">for</span> ( Iter2 = v2.begin( ) ; Iter2 != v2.end( ) ; Iter2++ )
      <span class="hljs-built_in">cout</span> &lt;&lt; *Iter2 &lt;&lt; <span class="hljs-string">" "</span>;
   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">")."</span> &lt;&lt; <span class="hljs-built_in">endl</span>;

   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"The original vector v1 remains unmodified as:\n ( "</span> ;
   <span class="hljs-keyword">for</span> ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ; Iter1++ )
      <span class="hljs-built_in">cout</span> &lt;&lt; *Iter1 &lt;&lt; <span class="hljs-string">" "</span>;
   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">")."</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
}
</code></pre>
<h2 id="rotate" class="heading-with-anchor">  rotate<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#rotate"></a></h2>
<p>Exchanges the elements in two adjacent ranges.</p>
<div class="codeHeader" id="code-try-132" data-bi-name="code-header"><span class="language">C++</span>
			<button class="action" data-bi-name="copy">
				<span class="docon docon-edit-copy" role="presentation"></span>
				<span>Copy</span>
			</button></div><pre><code class="lang-cpp" data-author-content="template&lt;class ForwardIterator&gt;
void rotate(
    ForwardIterator first,
    ForwardIterator middle,
    ForwardIterator last);
"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ForwardIterator</span>&gt;
<span class="hljs-title">void</span> <span class="hljs-title">rotate</span>(
    <span class="hljs-title">ForwardIterator</span> <span class="hljs-title">first</span>,
    <span class="hljs-title">ForwardIterator</span> <span class="hljs-title">middle</span>,
    <span class="hljs-title">ForwardIterator</span> <span class="hljs-title">last</span>);</span>
</code></pre>
<h3 id="parameters-65" class="heading-with-anchor">Parameters<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#parameters-65"></a></h3>
<p><em>first</em><br>
A forward iterator addressing the position of the first element in the range to be rotated.</p>
<p><em>middle</em><br>
A forward iterator defining the boundary within the range that addresses the position of the first element in the second part of the range whose elements are to be exchanged with those in the first part of the range.</p>
<p><em>Last</em><br>
A forward iterator addressing the position one past the final element in the range to be rotated.</p>
<h3 id="remarks-65" class="heading-with-anchor">Remarks<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#remarks-65"></a></h3>
<p>The ranges referenced must be valid; all pointers must be dereferenceable and within the sequence the last position is reachable from the first by incrementation.</p>
<p>The complexity is linear with at most (<code>last</code> - <code>first</code>) swaps.</p>
<h3 id="example-47" class="heading-with-anchor">Example<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#example-47"></a></h3>
<div class="codeHeader" id="code-try-133" data-bi-name="code-header"><span class="language">C++</span>
			<button class="action" data-bi-name="copy">
				<span class="docon docon-edit-copy" role="presentation"></span>
				<span>Copy</span>
			</button></div><pre><code class="lang-cpp" data-author-content="// alg_rotate.cpp
// compile with: /EHsc
#include &lt;vector&gt;
#include &lt;deque&gt;
#include &lt;algorithm&gt;
#include &lt;iostream&gt;

int main() {
   using namespace std;
   vector &lt;int&gt; v1;
   deque &lt;int&gt; d1;
   vector &lt;int&gt;::iterator v1Iter1;
   deque&lt;int&gt;::iterator d1Iter1;

   int i;
   for ( i = -3 ; i &lt;= 5 ; i++ )
   {
      v1.push_back( i );
   }

   int ii;
   for ( ii =0 ; ii &lt;= 5 ; ii++ )
   {
      d1.push_back( ii );
   }

   cout &lt;&lt; &quot;Vector v1 is ( &quot; ;
   for ( v1Iter1 = v1.begin( ) ; v1Iter1 != v1.end( ) ;v1Iter1 ++ )
      cout &lt;&lt; *v1Iter1  &lt;&lt; &quot; &quot;;
   cout &lt;&lt; &quot;).&quot; &lt;&lt; endl;

   rotate ( v1.begin( ), v1.begin( ) + 3 , v1.end( ) );
   cout &lt;&lt; &quot;After rotating, vector v1 is ( &quot; ;
   for ( v1Iter1 = v1.begin( ) ; v1Iter1 != v1.end( ) ;v1Iter1 ++ )
      cout &lt;&lt; *v1Iter1  &lt;&lt; &quot; &quot;;
   cout &lt;&lt; &quot;).&quot; &lt;&lt; endl;

   cout &lt;&lt; &quot;The original deque d1 is ( &quot; ;
   for ( d1Iter1 = d1.begin( ) ; d1Iter1 != d1.end( ) ;d1Iter1 ++ )
      cout &lt;&lt; *d1Iter1  &lt;&lt; &quot; &quot;;
   cout &lt;&lt; &quot;).&quot; &lt;&lt; endl;

   int iii = 1;
   while ( iii &lt;= d1.end( ) - d1.begin( ) ) {
      rotate ( d1.begin( ), d1.begin( ) + 1 , d1.end( ) );
      cout &lt;&lt; &quot;After the rotation of a single deque element to the back,\n d1 is   ( &quot; ;
      for ( d1Iter1 = d1.begin( ) ; d1Iter1 != d1.end( ) ;d1Iter1 ++ )
         cout &lt;&lt; *d1Iter1  &lt;&lt; &quot; &quot;;
      cout &lt;&lt; &quot;).&quot; &lt;&lt; endl;
      iii++;
   }
}
"><span class="hljs-comment">// alg_rotate.cpp</span>
<span class="hljs-comment">// compile with: /EHsc</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;deque&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span>

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
   <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;
   <span class="hljs-built_in">vector</span> &lt;<span class="hljs-keyword">int</span>&gt; v1;
   <span class="hljs-built_in">deque</span> &lt;<span class="hljs-keyword">int</span>&gt; d1;
   <span class="hljs-built_in">vector</span> &lt;<span class="hljs-keyword">int</span>&gt;::iterator v1Iter1;
   <span class="hljs-built_in">deque</span>&lt;<span class="hljs-keyword">int</span>&gt;::iterator d1Iter1;

   <span class="hljs-keyword">int</span> i;
   <span class="hljs-keyword">for</span> ( i = <span class="hljs-number">-3</span> ; i &lt;= <span class="hljs-number">5</span> ; i++ )
   {
      v1.push_back( i );
   }

   <span class="hljs-keyword">int</span> ii;
   <span class="hljs-keyword">for</span> ( ii =<span class="hljs-number">0</span> ; ii &lt;= <span class="hljs-number">5</span> ; ii++ )
   {
      d1.push_back( ii );
   }

   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Vector v1 is ( "</span> ;
   <span class="hljs-keyword">for</span> ( v1Iter1 = v1.begin( ) ; v1Iter1 != v1.end( ) ;v1Iter1 ++ )
      <span class="hljs-built_in">cout</span> &lt;&lt; *v1Iter1  &lt;&lt; <span class="hljs-string">" "</span>;
   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">")."</span> &lt;&lt; <span class="hljs-built_in">endl</span>;

   rotate ( v1.begin( ), v1.begin( ) + <span class="hljs-number">3</span> , v1.end( ) );
   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"After rotating, vector v1 is ( "</span> ;
   <span class="hljs-keyword">for</span> ( v1Iter1 = v1.begin( ) ; v1Iter1 != v1.end( ) ;v1Iter1 ++ )
      <span class="hljs-built_in">cout</span> &lt;&lt; *v1Iter1  &lt;&lt; <span class="hljs-string">" "</span>;
   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">")."</span> &lt;&lt; <span class="hljs-built_in">endl</span>;

   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"The original deque d1 is ( "</span> ;
   <span class="hljs-keyword">for</span> ( d1Iter1 = d1.begin( ) ; d1Iter1 != d1.end( ) ;d1Iter1 ++ )
      <span class="hljs-built_in">cout</span> &lt;&lt; *d1Iter1  &lt;&lt; <span class="hljs-string">" "</span>;
   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">")."</span> &lt;&lt; <span class="hljs-built_in">endl</span>;

   <span class="hljs-keyword">int</span> iii = <span class="hljs-number">1</span>;
   <span class="hljs-keyword">while</span> ( iii &lt;= d1.end( ) - d1.begin( ) ) {
      rotate ( d1.begin( ), d1.begin( ) + <span class="hljs-number">1</span> , d1.end( ) );
      <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"After the rotation of a single deque element to the back,\n d1 is   ( "</span> ;
      <span class="hljs-keyword">for</span> ( d1Iter1 = d1.begin( ) ; d1Iter1 != d1.end( ) ;d1Iter1 ++ )
         <span class="hljs-built_in">cout</span> &lt;&lt; *d1Iter1  &lt;&lt; <span class="hljs-string">" "</span>;
      <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">")."</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
      iii++;
   }
}
</code></pre>
<div class="codeHeader" id="code-try-134" data-bi-name="code-header"><span class="language">Output</span>
			<button class="action" data-bi-name="copy">
				<span class="docon docon-edit-copy" role="presentation"></span>
				<span>Copy</span>
			</button></div><pre><code class="lang-Output" data-author-content="Vector v1 is ( -3 -2 -1 0 1 2 3 4 5 ).
After rotating, vector v1 is ( 0 1 2 3 4 5 -3 -2 -1 ).
The original deque d1 is ( 0 1 2 3 4 5 ).
After the rotation of a single deque element to the back,
d1 is   ( 1 2 3 4 5 0 ).
After the rotation of a single deque element to the back,
d1 is   ( 2 3 4 5 0 1 ).
After the rotation of a single deque element to the back,
d1 is   ( 3 4 5 0 1 2 ).
After the rotation of a single deque element to the back,
d1 is   ( 4 5 0 1 2 3 ).
After the rotation of a single deque element to the back,
d1 is   ( 5 0 1 2 3 4 ).
After the rotation of a single deque element to the back,
d1 is   ( 0 1 2 3 4 5 ).
">Vector v1 is ( -3 -2 -1 0 1 2 3 4 5 ).
After rotating, vector v1 is ( 0 1 2 3 4 5 -3 -2 -1 ).
The original deque d1 is ( 0 1 2 3 4 5 ).
After the rotation of a single deque element to the back,
d1 is   ( 1 2 3 4 5 0 ).
After the rotation of a single deque element to the back,
d1 is   ( 2 3 4 5 0 1 ).
After the rotation of a single deque element to the back,
d1 is   ( 3 4 5 0 1 2 ).
After the rotation of a single deque element to the back,
d1 is   ( 4 5 0 1 2 3 ).
After the rotation of a single deque element to the back,
d1 is   ( 5 0 1 2 3 4 ).
After the rotation of a single deque element to the back,
d1 is   ( 0 1 2 3 4 5 ).
</code></pre>
<h2 id="rotate_copy" class="heading-with-anchor">  rotate_copy<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#rotate_copy"></a></h2>
<p>Exchanges the elements in two adjacent ranges within a source range and copies the result to a destination range.</p>
<div class="codeHeader" id="code-try-135" data-bi-name="code-header"><span class="language">C++</span>
			<button class="action" data-bi-name="copy">
				<span class="docon docon-edit-copy" role="presentation"></span>
				<span>Copy</span>
			</button></div><pre><code class="lang-cpp" data-author-content="template&lt;class ForwardIterator, class OutputIterator&gt;
OutputIterator rotate_copy(
    ForwardIterator first,
    ForwardIterator middle,
    ForwardIterator last,
    OutputIterator result );
"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ForwardIterator</span>, <span class="hljs-title">class</span> <span class="hljs-title">OutputIterator</span>&gt;
<span class="hljs-title">OutputIterator</span> <span class="hljs-title">rotate_copy</span>(
    <span class="hljs-title">ForwardIterator</span> <span class="hljs-title">first</span>,
    <span class="hljs-title">ForwardIterator</span> <span class="hljs-title">middle</span>,
    <span class="hljs-title">ForwardIterator</span> <span class="hljs-title">last</span>,
    <span class="hljs-title">OutputIterator</span> <span class="hljs-title">result</span> );</span>
</code></pre>
<h3 id="parameters-66" class="heading-with-anchor">Parameters<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#parameters-66"></a></h3>
<p><em>first</em><br>
A forward iterator addressing the position of the first element in the range to be rotated.</p>
<p><em>middle</em><br>
A forward iterator defining the boundary within the range that addresses the position of the first element in the second part of the range whose elements are to be exchanged with those in the first part of the range.</p>
<p>_ <em>Last</em>
A forward iterator addressing the position one past the final element in the range to be rotated.</p>
<p><em>result</em><br>
An output iterator addressing the position of the first element in the destination range.</p>
<h3 id="return-value-47" class="heading-with-anchor">Return Value<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#return-value-47"></a></h3>
<p>An output iterator addressing the position one past the final element in the destination range.</p>
<h3 id="remarks-66" class="heading-with-anchor">Remarks<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#remarks-66"></a></h3>
<p>The ranges referenced must be valid; all pointers must be dereferenceable and within the sequence the last position is reachable from the first by incrementation.</p>
<p>The complexity is linear with at most (<code>last</code> - <code>first</code>) swaps.</p>
<h3 id="example-48" class="heading-with-anchor">Example<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#example-48"></a></h3>
<div class="codeHeader" id="code-try-136" data-bi-name="code-header"><span class="language">C++</span>
			<button class="action" data-bi-name="copy">
				<span class="docon docon-edit-copy" role="presentation"></span>
				<span>Copy</span>
			</button></div><pre><code class="lang-cpp" data-author-content="// alg_rotate_copy.cpp
// compile with: /EHsc
#include &lt;vector&gt;
#include &lt;deque&gt;
#include &lt;algorithm&gt;
#include &lt;iostream&gt;

int main() {
   using namespace std;
   vector &lt;int&gt; v1 , v2 ( 9 );
   deque &lt;int&gt; d1 , d2 ( 6 );
   vector &lt;int&gt;::iterator v1Iter , v2Iter;
   deque&lt;int&gt;::iterator d1Iter , d2Iter;

   int i;
   for ( i = -3 ; i &lt;= 5 ; i++ )
      v1.push_back( i );

   int ii;
   for ( ii =0 ; ii &lt;= 5 ; ii++ )
      d1.push_back( ii );

   cout &lt;&lt; &quot;Vector v1 is ( &quot; ;
   for ( v1Iter = v1.begin( ) ; v1Iter != v1.end( ) ;v1Iter ++ )
      cout &lt;&lt; *v1Iter  &lt;&lt; &quot; &quot;;
   cout &lt;&lt; &quot;).&quot; &lt;&lt; endl;

   rotate_copy ( v1.begin( ), v1.begin( ) + 3 , v1.end( ), v2.begin( ) );
   cout &lt;&lt; &quot;After rotating, the vector v1 remains unchanged as:\n v1 = ( &quot; ;
   for ( v1Iter = v1.begin( ) ; v1Iter != v1.end( ) ;v1Iter ++ )
      cout &lt;&lt; *v1Iter  &lt;&lt; &quot; &quot;;
   cout &lt;&lt; &quot;).&quot; &lt;&lt; endl;

   cout &lt;&lt; &quot;After rotating, the copy of vector v1 in v2 is:\n v2 = ( &quot; ;
   for ( v2Iter = v2.begin( ) ; v2Iter != v2.end( ) ;v2Iter ++ )
      cout &lt;&lt; *v2Iter  &lt;&lt; &quot; &quot;;
   cout &lt;&lt; &quot;).&quot; &lt;&lt; endl;

   cout &lt;&lt; &quot;The original deque d1 is ( &quot; ;
   for ( d1Iter = d1.begin( ) ; d1Iter != d1.end( ) ;d1Iter ++ )
      cout &lt;&lt; *d1Iter  &lt;&lt; &quot; &quot;;
   cout &lt;&lt; &quot;).&quot; &lt;&lt; endl;

   int iii = 1;
   while ( iii &lt;= d1.end( ) - d1.begin( ) )
   {
      rotate_copy ( d1.begin( ), d1.begin( ) + iii , d1.end( ), d2.begin( ) );
      cout &lt;&lt; &quot;After the rotation of a single deque element to the back,\n d2 is   ( &quot; ;
      for ( d2Iter = d2.begin( ) ; d2Iter != d2.end( ) ;d2Iter ++ )
         cout &lt;&lt; *d2Iter  &lt;&lt; &quot; &quot;;
      cout &lt;&lt; &quot;).&quot; &lt;&lt; endl;
      iii++;
   }
}
"><span class="hljs-comment">// alg_rotate_copy.cpp</span>
<span class="hljs-comment">// compile with: /EHsc</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;deque&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span>

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
   <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;
   <span class="hljs-built_in">vector</span> &lt;<span class="hljs-keyword">int</span>&gt; v1 , v2 ( <span class="hljs-number">9</span> );
   <span class="hljs-built_in">deque</span> &lt;<span class="hljs-keyword">int</span>&gt; d1 , d2 ( <span class="hljs-number">6</span> );
   <span class="hljs-built_in">vector</span> &lt;<span class="hljs-keyword">int</span>&gt;::iterator v1Iter , v2Iter;
   <span class="hljs-built_in">deque</span>&lt;<span class="hljs-keyword">int</span>&gt;::iterator d1Iter , d2Iter;

   <span class="hljs-keyword">int</span> i;
   <span class="hljs-keyword">for</span> ( i = <span class="hljs-number">-3</span> ; i &lt;= <span class="hljs-number">5</span> ; i++ )
      v1.push_back( i );

   <span class="hljs-keyword">int</span> ii;
   <span class="hljs-keyword">for</span> ( ii =<span class="hljs-number">0</span> ; ii &lt;= <span class="hljs-number">5</span> ; ii++ )
      d1.push_back( ii );

   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Vector v1 is ( "</span> ;
   <span class="hljs-keyword">for</span> ( v1Iter = v1.begin( ) ; v1Iter != v1.end( ) ;v1Iter ++ )
      <span class="hljs-built_in">cout</span> &lt;&lt; *v1Iter  &lt;&lt; <span class="hljs-string">" "</span>;
   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">")."</span> &lt;&lt; <span class="hljs-built_in">endl</span>;

   rotate_copy ( v1.begin( ), v1.begin( ) + <span class="hljs-number">3</span> , v1.end( ), v2.begin( ) );
   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"After rotating, the vector v1 remains unchanged as:\n v1 = ( "</span> ;
   <span class="hljs-keyword">for</span> ( v1Iter = v1.begin( ) ; v1Iter != v1.end( ) ;v1Iter ++ )
      <span class="hljs-built_in">cout</span> &lt;&lt; *v1Iter  &lt;&lt; <span class="hljs-string">" "</span>;
   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">")."</span> &lt;&lt; <span class="hljs-built_in">endl</span>;

   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"After rotating, the copy of vector v1 in v2 is:\n v2 = ( "</span> ;
   <span class="hljs-keyword">for</span> ( v2Iter = v2.begin( ) ; v2Iter != v2.end( ) ;v2Iter ++ )
      <span class="hljs-built_in">cout</span> &lt;&lt; *v2Iter  &lt;&lt; <span class="hljs-string">" "</span>;
   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">")."</span> &lt;&lt; <span class="hljs-built_in">endl</span>;

   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"The original deque d1 is ( "</span> ;
   <span class="hljs-keyword">for</span> ( d1Iter = d1.begin( ) ; d1Iter != d1.end( ) ;d1Iter ++ )
      <span class="hljs-built_in">cout</span> &lt;&lt; *d1Iter  &lt;&lt; <span class="hljs-string">" "</span>;
   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">")."</span> &lt;&lt; <span class="hljs-built_in">endl</span>;

   <span class="hljs-keyword">int</span> iii = <span class="hljs-number">1</span>;
   <span class="hljs-keyword">while</span> ( iii &lt;= d1.end( ) - d1.begin( ) )
   {
      rotate_copy ( d1.begin( ), d1.begin( ) + iii , d1.end( ), d2.begin( ) );
      <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"After the rotation of a single deque element to the back,\n d2 is   ( "</span> ;
      <span class="hljs-keyword">for</span> ( d2Iter = d2.begin( ) ; d2Iter != d2.end( ) ;d2Iter ++ )
         <span class="hljs-built_in">cout</span> &lt;&lt; *d2Iter  &lt;&lt; <span class="hljs-string">" "</span>;
      <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">")."</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
      iii++;
   }
}
</code></pre>
<h2 id="search" class="heading-with-anchor">  search<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#search"></a></h2>
<p>Searches for the first occurrence of a sequence within a target range whose elements are equal to those in a given sequence of elements or whose elements are equivalent in a sense specified by a binary predicate to the elements in the given sequence.</p>
<div class="codeHeader" id="code-try-137" data-bi-name="code-header"><span class="language">C++</span>
			<button class="action" data-bi-name="copy">
				<span class="docon docon-edit-copy" role="presentation"></span>
				<span>Copy</span>
			</button></div><pre><code class="lang-cpp" data-author-content="template&lt;class ForwardIterator1, class ForwardIterator2&gt;
ForwardIterator1 search(
    ForwardIterator1 first1,
    ForwardIterator1 last1,
    ForwardIterator2 first2,
    ForwardIterator2 last2);

template&lt;class ForwardIterator1, class ForwardIterator2, class Predicate&gt;
ForwardIterator1 search(
    ForwardIterator1 first1,
    ForwardIterator1 last1,
    ForwardIterator2 first2,
    ForwardIterator2 last2
    Predicate comp);
"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ForwardIterator1</span>, <span class="hljs-title">class</span> <span class="hljs-title">ForwardIterator2</span>&gt;
<span class="hljs-title">ForwardIterator1</span> <span class="hljs-title">search</span>(
    <span class="hljs-title">ForwardIterator1</span> <span class="hljs-title">first1</span>,
    <span class="hljs-title">ForwardIterator1</span> <span class="hljs-title">last1</span>,
    <span class="hljs-title">ForwardIterator2</span> <span class="hljs-title">first2</span>,
    <span class="hljs-title">ForwardIterator2</span> <span class="hljs-title">last2</span>);</span>

<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ForwardIterator1</span>, <span class="hljs-title">class</span> <span class="hljs-title">ForwardIterator2</span>, <span class="hljs-title">class</span> <span class="hljs-title">Predicate</span>&gt;
<span class="hljs-title">ForwardIterator1</span> <span class="hljs-title">search</span>(
    <span class="hljs-title">ForwardIterator1</span> <span class="hljs-title">first1</span>,
    <span class="hljs-title">ForwardIterator1</span> <span class="hljs-title">last1</span>,
    <span class="hljs-title">ForwardIterator2</span> <span class="hljs-title">first2</span>,
    <span class="hljs-title">ForwardIterator2</span> <span class="hljs-title">last2</span>
    <span class="hljs-title">Predicate</span> <span class="hljs-title">comp</span>);</span>
</code></pre>
<h3 id="parameters-67" class="heading-with-anchor">Parameters<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#parameters-67"></a></h3>
<p><em>first1</em><br>
A forward iterator addressing the position of the first element in the range to be searched.</p>
<p><em>last1</em><br>
A forward iterator addressing the position one past the final element in the range to be searched.</p>
<p><em>first2</em><br>
A forward iterator addressing the position of the first element in the range to be matched.</p>
<p><em>last2</em><br>
A forward iterator addressing the position one past the final element in the range to be matched.</p>
<p><em>comp</em><br>
User-defined predicate function object that defines the condition to be satisfied if two elements are to be taken as equivalent. A binary predicate takes two arguments and returns <strong>true</strong> when satisfied and <strong>false</strong> when not satisfied.</p>
<h3 id="return-value-48" class="heading-with-anchor">Return Value<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#return-value-48"></a></h3>
<p>A forward iterator addressing the position of the first element of the first subsequence that matches the specified sequence or that is equivalent in a sense specified by a binary predicate.</p>
<h3 id="remarks-67" class="heading-with-anchor">Remarks<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#remarks-67"></a></h3>
<p>The <code>operator==</code> used to determine the match between an element and the specified value must impose an equivalence relation between its operands.</p>
<p>The ranges referenced must be valid; all pointers must be dereferenceable and within each sequence the last position is reachable from the first by incrementation.</p>
<p>Average complexity is linear with respect to the size of the searched range, and worst case complexity is also linear with respect to the size of the sequence being searched for.</p>
<h3 id="example-49" class="heading-with-anchor">Example<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#example-49"></a></h3>
<div class="codeHeader" id="code-try-138" data-bi-name="code-header"><span class="language">C++</span>
			<button class="action" data-bi-name="copy">
				<span class="docon docon-edit-copy" role="presentation"></span>
				<span>Copy</span>
			</button></div><pre><code class="lang-cpp" data-author-content="// alg_search.cpp
// compile with: /EHsc
#include &lt;vector&gt;
#include &lt;list&gt;
#include &lt;algorithm&gt;
#include &lt;iostream&gt;

// Return whether second element is twice the first
bool twice (int elem1, int elem2 )
{
   return 2 * elem1 == elem2;
}

int main() {
   using namespace std;
   vector &lt;int&gt; v1, v2;
   list &lt;int&gt; L1;
   vector &lt;int&gt;::iterator Iter1, Iter2;
   list &lt;int&gt;::iterator L1_Iter, L1_inIter;

   int i;
   for ( i = 0 ; i &lt;= 5 ; i++ )
   {
      v1.push_back( 5 * i );
   }
   for ( i = 0 ; i &lt;= 5 ; i++ )
   {
      v1.push_back( 5 * i );
   }

   int ii;
   for ( ii = 4 ; ii &lt;= 5 ; ii++ )
   {
      L1.push_back( 5 * ii );
   }

   int iii;
   for ( iii = 2 ; iii &lt;= 4 ; iii++ )
   {
      v2.push_back( 10 * iii );
   }

   cout &lt;&lt; &quot;Vector v1 = ( &quot; ;
   for ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ; Iter1++ )
      cout &lt;&lt; *Iter1 &lt;&lt; &quot; &quot;;
   cout &lt;&lt; &quot;)&quot; &lt;&lt; endl;

   cout &lt;&lt; &quot;List L1 = ( &quot; ;
   for ( L1_Iter = L1.begin( ) ; L1_Iter!= L1.end( ) ; L1_Iter++ )
      cout &lt;&lt; *L1_Iter &lt;&lt; &quot; &quot;;
   cout &lt;&lt; &quot;)&quot; &lt;&lt; endl;

   cout &lt;&lt; &quot;Vector v2 = ( &quot; ;
   for ( Iter2 = v2.begin( ) ; Iter2 != v2.end( ) ; Iter2++ )
      cout &lt;&lt; *Iter2 &lt;&lt; &quot; &quot;;
      cout &lt;&lt; &quot;)&quot; &lt;&lt; endl;

   // Searching v1 for first match to L1 under identity
   vector &lt;int&gt;::iterator result1;
   result1 = search (v1.begin( ), v1.end( ), L1.begin( ), L1.end( ) );

   if ( result1 == v1.end( ) )
      cout &lt;&lt; &quot;There is no match of L1 in v1.&quot;
           &lt;&lt; endl;
   else
      cout &lt;&lt; &quot;There is at least one match of L1 in v1&quot;
           &lt;&lt; &quot;\n and the first one begins at &quot;
           &lt;&lt; &quot;position &quot;&lt;&lt; result1 - v1.begin( ) &lt;&lt; &quot;.&quot; &lt;&lt; endl;

   // Searching v1 for a match to L1 under the binary predicate twice
   vector &lt;int&gt;::iterator result2;
   result2 = search  (v1.begin( ), v1.end( ), v2.begin( ), v2.end( ), twice );

   if ( result2 == v1.end( ) )
      cout &lt;&lt; &quot;There is no match of L1 in v1.&quot;
           &lt;&lt; endl;
   else
      cout &lt;&lt; &quot;There is a sequence of elements in v1 that &quot;
           &lt;&lt; &quot;are equivalent\n to those in v2 under the binary &quot;
           &lt;&lt; &quot;predicate twice\n and the first one begins at position &quot;
           &lt;&lt; result2 - v1.begin( ) &lt;&lt; &quot;.&quot; &lt;&lt; endl;
}
"><span class="hljs-comment">// alg_search.cpp</span>
<span class="hljs-comment">// compile with: /EHsc</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;list&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span>

<span class="hljs-comment">// Return whether second element is twice the first</span>
<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">twice</span> <span class="hljs-params">(<span class="hljs-keyword">int</span> elem1, <span class="hljs-keyword">int</span> elem2 )</span>
</span>{
   <span class="hljs-keyword">return</span> <span class="hljs-number">2</span> * elem1 == elem2;
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
   <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;
   <span class="hljs-built_in">vector</span> &lt;<span class="hljs-keyword">int</span>&gt; v1, v2;
   <span class="hljs-built_in">list</span> &lt;<span class="hljs-keyword">int</span>&gt; L1;
   <span class="hljs-built_in">vector</span> &lt;<span class="hljs-keyword">int</span>&gt;::iterator Iter1, Iter2;
   <span class="hljs-built_in">list</span> &lt;<span class="hljs-keyword">int</span>&gt;::iterator L1_Iter, L1_inIter;

   <span class="hljs-keyword">int</span> i;
   <span class="hljs-keyword">for</span> ( i = <span class="hljs-number">0</span> ; i &lt;= <span class="hljs-number">5</span> ; i++ )
   {
      v1.push_back( <span class="hljs-number">5</span> * i );
   }
   <span class="hljs-keyword">for</span> ( i = <span class="hljs-number">0</span> ; i &lt;= <span class="hljs-number">5</span> ; i++ )
   {
      v1.push_back( <span class="hljs-number">5</span> * i );
   }

   <span class="hljs-keyword">int</span> ii;
   <span class="hljs-keyword">for</span> ( ii = <span class="hljs-number">4</span> ; ii &lt;= <span class="hljs-number">5</span> ; ii++ )
   {
      L1.push_back( <span class="hljs-number">5</span> * ii );
   }

   <span class="hljs-keyword">int</span> iii;
   <span class="hljs-keyword">for</span> ( iii = <span class="hljs-number">2</span> ; iii &lt;= <span class="hljs-number">4</span> ; iii++ )
   {
      v2.push_back( <span class="hljs-number">10</span> * iii );
   }

   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Vector v1 = ( "</span> ;
   <span class="hljs-keyword">for</span> ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ; Iter1++ )
      <span class="hljs-built_in">cout</span> &lt;&lt; *Iter1 &lt;&lt; <span class="hljs-string">" "</span>;
   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">")"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;

   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"List L1 = ( "</span> ;
   <span class="hljs-keyword">for</span> ( L1_Iter = L1.begin( ) ; L1_Iter!= L1.end( ) ; L1_Iter++ )
      <span class="hljs-built_in">cout</span> &lt;&lt; *L1_Iter &lt;&lt; <span class="hljs-string">" "</span>;
   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">")"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;

   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Vector v2 = ( "</span> ;
   <span class="hljs-keyword">for</span> ( Iter2 = v2.begin( ) ; Iter2 != v2.end( ) ; Iter2++ )
      <span class="hljs-built_in">cout</span> &lt;&lt; *Iter2 &lt;&lt; <span class="hljs-string">" "</span>;
      <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">")"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;

   <span class="hljs-comment">// Searching v1 for first match to L1 under identity</span>
   <span class="hljs-built_in">vector</span> &lt;<span class="hljs-keyword">int</span>&gt;::iterator result1;
   result1 = search (v1.begin( ), v1.end( ), L1.begin( ), L1.end( ) );

   <span class="hljs-keyword">if</span> ( result1 == v1.end( ) )
      <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"There is no match of L1 in v1."</span>
           &lt;&lt; <span class="hljs-built_in">endl</span>;
   <span class="hljs-keyword">else</span>
      <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"There is at least one match of L1 in v1"</span>
           &lt;&lt; <span class="hljs-string">"\n and the first one begins at "</span>
           &lt;&lt; <span class="hljs-string">"position "</span>&lt;&lt; result1 - v1.begin( ) &lt;&lt; <span class="hljs-string">"."</span> &lt;&lt; <span class="hljs-built_in">endl</span>;

   <span class="hljs-comment">// Searching v1 for a match to L1 under the binary predicate twice</span>
   <span class="hljs-built_in">vector</span> &lt;<span class="hljs-keyword">int</span>&gt;::iterator result2;
   result2 = search  (v1.begin( ), v1.end( ), v2.begin( ), v2.end( ), twice );

   <span class="hljs-keyword">if</span> ( result2 == v1.end( ) )
      <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"There is no match of L1 in v1."</span>
           &lt;&lt; <span class="hljs-built_in">endl</span>;
   <span class="hljs-keyword">else</span>
      <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"There is a sequence of elements in v1 that "</span>
           &lt;&lt; <span class="hljs-string">"are equivalent\n to those in v2 under the binary "</span>
           &lt;&lt; <span class="hljs-string">"predicate twice\n and the first one begins at position "</span>
           &lt;&lt; result2 - v1.begin( ) &lt;&lt; <span class="hljs-string">"."</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
}
</code></pre>
<div class="codeHeader" id="code-try-139" data-bi-name="code-header"><span class="language">Output</span>
			<button class="action" data-bi-name="copy">
				<span class="docon docon-edit-copy" role="presentation"></span>
				<span>Copy</span>
			</button></div><pre><code class="lang-Output" data-author-content="Vector v1 = ( 0 5 10 15 20 25 0 5 10 15 20 25 )
List L1 = ( 20 25 )
Vector v2 = ( 20 30 40 )
There is at least one match of L1 in v1
and the first one begins at position 4.
There is a sequence of elements in v1 that are equivalent
to those in v2 under the binary predicate twice
and the first one begins at position 2.
">Vector v1 = ( 0 5 10 15 20 25 0 5 10 15 20 25 )
List L1 = ( 20 25 )
Vector v2 = ( 20 30 40 )
There is at least one match of L1 in v1
and the first one begins at position 4.
There is a sequence of elements in v1 that are equivalent
to those in v2 under the binary predicate twice
and the first one begins at position 2.
</code></pre>
<h2 id="search_n" class="heading-with-anchor">  search_n<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#search_n"></a></h2>
<p>Searches for the first subsequence in a range that of a specified number of elements having a particular value or a relation to that value as specified by a binary predicate.</p>
<div class="codeHeader" id="code-try-140" data-bi-name="code-header"><span class="language">C++</span>
			<button class="action" data-bi-name="copy">
				<span class="docon docon-edit-copy" role="presentation"></span>
				<span>Copy</span>
			</button></div><pre><code class="lang-cpp" data-author-content="template&lt;class ForwardIterator1, class Diff2, class Type&gt;
ForwardIterator1 search_n(
    ForwardIterator1 first1,
    ForwardIterator1 last1,
    Diff2 count,
    const Type&amp; val);

template&lt;class ForwardIterator1, class Diff2, class Type, class BinaryPredicate&gt;
ForwardIterator1 search_n(
    ForwardIterator1 first1,
    ForwardIterator1 last1,
    Diff2 count,
    const Type&amp; val,
    BinaryPredicate comp);
"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ForwardIterator1</span>, <span class="hljs-title">class</span> <span class="hljs-title">Diff2</span>, <span class="hljs-title">class</span> <span class="hljs-title">Type</span>&gt;
<span class="hljs-title">ForwardIterator1</span> <span class="hljs-title">search_n</span>(
    <span class="hljs-title">ForwardIterator1</span> <span class="hljs-title">first1</span>,
    <span class="hljs-title">ForwardIterator1</span> <span class="hljs-title">last1</span>,
    <span class="hljs-title">Diff2</span> <span class="hljs-title">count</span>,
    <span class="hljs-title">const</span> <span class="hljs-title">Type</span>&amp; <span class="hljs-title">val</span>);</span>

<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ForwardIterator1</span>, <span class="hljs-title">class</span> <span class="hljs-title">Diff2</span>, <span class="hljs-title">class</span> <span class="hljs-title">Type</span>, <span class="hljs-title">class</span> <span class="hljs-title">BinaryPredicate</span>&gt;
<span class="hljs-title">ForwardIterator1</span> <span class="hljs-title">search_n</span>(
    <span class="hljs-title">ForwardIterator1</span> <span class="hljs-title">first1</span>,
    <span class="hljs-title">ForwardIterator1</span> <span class="hljs-title">last1</span>,
    <span class="hljs-title">Diff2</span> <span class="hljs-title">count</span>,
    <span class="hljs-title">const</span> <span class="hljs-title">Type</span>&amp; <span class="hljs-title">val</span>,
    <span class="hljs-title">BinaryPredicate</span> <span class="hljs-title">comp</span>);</span>
</code></pre>
<h3 id="parameters-68" class="heading-with-anchor">Parameters<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#parameters-68"></a></h3>
<p><em>first1</em><br>
A forward iterator addressing the position of the first element in the range to be searched.</p>
<p><em>last1</em><br>
A forward iterator addressing the position one past the final element in the range to be searched.</p>
<p><em>count</em><br>
The size of the subsequence being searched for.</p>
<p><em>val</em><br>
The value of the elements in the sequence being searched for.</p>
<p><em>comp</em><br>
User-defined predicate function object that defines the condition to be satisfied if two elements are to be taken as equivalent. A binary predicate takes two arguments and returns <strong>true</strong> when satisfied and <strong>false</strong> when not satisfied.</p>
<h3 id="return-value-49" class="heading-with-anchor">Return Value<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#return-value-49"></a></h3>
<p>A forward iterator addressing the position of the first element of the first subsequence that matches the specified sequence or that is equivalent in a sense specified by a binary predicate.</p>
<h3 id="remarks-68" class="heading-with-anchor">Remarks<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#remarks-68"></a></h3>
<p>The <code>operator==</code> used to determine the match between an element and the specified value must impose an equivalence relation between its operands.</p>
<p>The range referenced must be valid; all pointers must be dereferenceable and within the sequence the last position is reachable from the first by incrementation.</p>
<p>Complexity is linear with respect to the size of the searched.</p>
<h3 id="example-50" class="heading-with-anchor">Example<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#example-50"></a></h3>
<div class="codeHeader" id="code-try-141" data-bi-name="code-header"><span class="language">C++</span>
			<button class="action" data-bi-name="copy">
				<span class="docon docon-edit-copy" role="presentation"></span>
				<span>Copy</span>
			</button></div><pre><code class="lang-cpp" data-author-content="// alg_search_n.cpp
// compile with: /EHsc
#include &lt;vector&gt;
#include &lt;list&gt;
#include &lt;algorithm&gt;
#include &lt;iostream&gt;

// Return whether second element is 1/2 of the first
bool one_half ( int elem1, int elem2 )
{
   return elem1 == 2 * elem2;
}

int main()
{
   using namespace std;
   vector &lt;int&gt; v1, v2;
   vector &lt;int&gt;::iterator Iter1;

   int i;
   for ( i = 0 ; i &lt;= 5 ; i++ )
   {
      v1.push_back( 5 * i );
   }

   for ( i = 0 ; i &lt;= 2 ; i++ )
   {
      v1.push_back( 5  );
   }

   for ( i = 0 ; i &lt;= 5 ; i++ )
   {
      v1.push_back( 5 * i );
   }

   for ( i = 0 ; i &lt;= 2 ; i++ )
   {
      v1.push_back( 10  );
   }

   cout &lt;&lt; &quot;Vector v1 = ( &quot; ;
   for ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ; Iter1++ )
      cout &lt;&lt; *Iter1 &lt;&lt; &quot; &quot;;
   cout &lt;&lt; &quot;)&quot; &lt;&lt; endl;

   // Searching v1 for first match to (5 5 5) under identity
   vector &lt;int&gt;::iterator result1;
   result1 = search_n ( v1.begin( ), v1.end( ), 3, 5 );

   if ( result1 == v1.end( ) )
      cout &lt;&lt; &quot;There is no match for a sequence ( 5 5 5 ) in v1.&quot;
           &lt;&lt; endl;
   else
      cout &lt;&lt; &quot;There is at least one match of a sequence ( 5 5 5 )&quot;
           &lt;&lt; &quot;\n in v1 and the first one begins at &quot;
           &lt;&lt; &quot;position &quot;&lt;&lt; result1 - v1.begin( ) &lt;&lt; &quot;.&quot; &lt;&lt; endl;

   // Searching v1 for first match to (5 5 5) under one_half
   vector &lt;int&gt;::iterator result2;
   result2 = search_n (v1.begin( ), v1.end( ), 3, 5, one_half );

   if ( result2 == v1.end( ) )
      cout &lt;&lt; &quot;There is no match for a sequence ( 5 5 5 ) in v1&quot;
           &lt;&lt; &quot; under the equivalence predicate one_half.&quot; &lt;&lt; endl;
   else
      cout &lt;&lt; &quot;There is a match of a sequence ( 5 5 5 ) &quot;
           &lt;&lt; &quot;under the equivalence\n predicate one_half &quot;
           &lt;&lt; &quot;in v1 and the first one begins at &quot;
           &lt;&lt; &quot;position &quot;&lt;&lt; result2 - v1.begin( ) &lt;&lt; &quot;.&quot; &lt;&lt; endl;
}
"><span class="hljs-comment">// alg_search_n.cpp</span>
<span class="hljs-comment">// compile with: /EHsc</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;list&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span>

<span class="hljs-comment">// Return whether second element is 1/2 of the first</span>
<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">one_half</span> <span class="hljs-params">( <span class="hljs-keyword">int</span> elem1, <span class="hljs-keyword">int</span> elem2 )</span>
</span>{
   <span class="hljs-keyword">return</span> elem1 == <span class="hljs-number">2</span> * elem2;
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
   <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;
   <span class="hljs-built_in">vector</span> &lt;<span class="hljs-keyword">int</span>&gt; v1, v2;
   <span class="hljs-built_in">vector</span> &lt;<span class="hljs-keyword">int</span>&gt;::iterator Iter1;

   <span class="hljs-keyword">int</span> i;
   <span class="hljs-keyword">for</span> ( i = <span class="hljs-number">0</span> ; i &lt;= <span class="hljs-number">5</span> ; i++ )
   {
      v1.push_back( <span class="hljs-number">5</span> * i );
   }

   <span class="hljs-keyword">for</span> ( i = <span class="hljs-number">0</span> ; i &lt;= <span class="hljs-number">2</span> ; i++ )
   {
      v1.push_back( <span class="hljs-number">5</span>  );
   }

   <span class="hljs-keyword">for</span> ( i = <span class="hljs-number">0</span> ; i &lt;= <span class="hljs-number">5</span> ; i++ )
   {
      v1.push_back( <span class="hljs-number">5</span> * i );
   }

   <span class="hljs-keyword">for</span> ( i = <span class="hljs-number">0</span> ; i &lt;= <span class="hljs-number">2</span> ; i++ )
   {
      v1.push_back( <span class="hljs-number">10</span>  );
   }

   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Vector v1 = ( "</span> ;
   <span class="hljs-keyword">for</span> ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ; Iter1++ )
      <span class="hljs-built_in">cout</span> &lt;&lt; *Iter1 &lt;&lt; <span class="hljs-string">" "</span>;
   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">")"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;

   <span class="hljs-comment">// Searching v1 for first match to (5 5 5) under identity</span>
   <span class="hljs-built_in">vector</span> &lt;<span class="hljs-keyword">int</span>&gt;::iterator result1;
   result1 = search_n ( v1.begin( ), v1.end( ), <span class="hljs-number">3</span>, <span class="hljs-number">5</span> );

   <span class="hljs-keyword">if</span> ( result1 == v1.end( ) )
      <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"There is no match for a sequence ( 5 5 5 ) in v1."</span>
           &lt;&lt; <span class="hljs-built_in">endl</span>;
   <span class="hljs-keyword">else</span>
      <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"There is at least one match of a sequence ( 5 5 5 )"</span>
           &lt;&lt; <span class="hljs-string">"\n in v1 and the first one begins at "</span>
           &lt;&lt; <span class="hljs-string">"position "</span>&lt;&lt; result1 - v1.begin( ) &lt;&lt; <span class="hljs-string">"."</span> &lt;&lt; <span class="hljs-built_in">endl</span>;

   <span class="hljs-comment">// Searching v1 for first match to (5 5 5) under one_half</span>
   <span class="hljs-built_in">vector</span> &lt;<span class="hljs-keyword">int</span>&gt;::iterator result2;
   result2 = search_n (v1.begin( ), v1.end( ), <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, one_half );

   <span class="hljs-keyword">if</span> ( result2 == v1.end( ) )
      <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"There is no match for a sequence ( 5 5 5 ) in v1"</span>
           &lt;&lt; <span class="hljs-string">" under the equivalence predicate one_half."</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
   <span class="hljs-keyword">else</span>
      <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"There is a match of a sequence ( 5 5 5 ) "</span>
           &lt;&lt; <span class="hljs-string">"under the equivalence\n predicate one_half "</span>
           &lt;&lt; <span class="hljs-string">"in v1 and the first one begins at "</span>
           &lt;&lt; <span class="hljs-string">"position "</span>&lt;&lt; result2 - v1.begin( ) &lt;&lt; <span class="hljs-string">"."</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
}
</code></pre>
<div class="codeHeader" id="code-try-142" data-bi-name="code-header"><span class="language">Output</span>
			<button class="action" data-bi-name="copy">
				<span class="docon docon-edit-copy" role="presentation"></span>
				<span>Copy</span>
			</button></div><pre><code class="lang-Output" data-author-content="Vector v1 = ( 0 5 10 15 20 25 5 5 5 0 5 10 15 20 25 10 10 10 )
There is at least one match of a sequence ( 5 5 5 )
in v1 and the first one begins at position 6.
There is a match of a sequence ( 5 5 5 ) under the equivalence
predicate one_half in v1 and the first one begins at position 15.
">Vector v1 = ( 0 5 10 15 20 25 5 5 5 0 5 10 15 20 25 10 10 10 )
There is at least one match of a sequence ( 5 5 5 )
in v1 and the first one begins at position 6.
There is a match of a sequence ( 5 5 5 ) under the equivalence
predicate one_half in v1 and the first one begins at position 15.
</code></pre>
<h2 id="set_difference" class="heading-with-anchor">  set_difference<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#set_difference"></a></h2>
<p>Unites all of the elements that belong to one sorted source range, but not to a second sorted source range, into a single, sorted destination range, where the ordering criterion may be specified by a binary predicate.</p>
<div class="codeHeader" id="code-try-143" data-bi-name="code-header"><span class="language">C++</span>
			<button class="action" data-bi-name="copy">
				<span class="docon docon-edit-copy" role="presentation"></span>
				<span>Copy</span>
			</button></div><pre><code class="lang-cpp" data-author-content="template&lt;class InputIterator1, class InputIterator2, class OutputIterator&gt;
OutputIterator set_difference(
    InputIterator1  first1,
    InputIterator1  last1,
    InputIterator2  first2,
    InputIterator2  last2,
    OutputIterator  result );

template&lt;class InputIterator1, class InputIterator2, class OutputIterator, class BinaryPredicate&gt;
OutputIterator set_difference(
    InputIterator1  first1,
    InputIterator1  last1,
    InputIterator2  first2,
    InputIterator2  last2,
    OutputIterator  result,
    BinaryPredicate  comp );
"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InputIterator1</span>, <span class="hljs-title">class</span> <span class="hljs-title">InputIterator2</span>, <span class="hljs-title">class</span> <span class="hljs-title">OutputIterator</span>&gt;
<span class="hljs-title">OutputIterator</span> <span class="hljs-title">set_difference</span>(
    <span class="hljs-title">InputIterator1</span>  <span class="hljs-title">first1</span>,
    <span class="hljs-title">InputIterator1</span>  <span class="hljs-title">last1</span>,
    <span class="hljs-title">InputIterator2</span>  <span class="hljs-title">first2</span>,
    <span class="hljs-title">InputIterator2</span>  <span class="hljs-title">last2</span>,
    <span class="hljs-title">OutputIterator</span>  <span class="hljs-title">result</span> );</span>

<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InputIterator1</span>, <span class="hljs-title">class</span> <span class="hljs-title">InputIterator2</span>, <span class="hljs-title">class</span> <span class="hljs-title">OutputIterator</span>, <span class="hljs-title">class</span> <span class="hljs-title">BinaryPredicate</span>&gt;
<span class="hljs-title">OutputIterator</span> <span class="hljs-title">set_difference</span>(
    <span class="hljs-title">InputIterator1</span>  <span class="hljs-title">first1</span>,
    <span class="hljs-title">InputIterator1</span>  <span class="hljs-title">last1</span>,
    <span class="hljs-title">InputIterator2</span>  <span class="hljs-title">first2</span>,
    <span class="hljs-title">InputIterator2</span>  <span class="hljs-title">last2</span>,
    <span class="hljs-title">OutputIterator</span>  <span class="hljs-title">result</span>,
    <span class="hljs-title">BinaryPredicate</span>  <span class="hljs-title">comp</span> );</span>
</code></pre>
<h3 id="parameters-69" class="heading-with-anchor">Parameters<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#parameters-69"></a></h3>
<p><em>first1</em><br>
An input iterator addressing the position of the first element in the first of two sorted source ranges to be united and sorted into a single range representing the difference of the two source ranges.</p>
<p><em>last1</em><br>
An input iterator addressing the position one past the last element in the first of two sorted source ranges to be united and sorted into a single range representing the difference of the two source ranges.</p>
<p><em>first2</em><br>
An input iterator addressing the position of the first element in second of two consecutive sorted source ranges to be united and sorted into a single range representing the difference of the two source ranges.</p>
<p><em>last2</em><br>
An input iterator addressing the position one past the last element in second of two consecutive sorted source ranges to be united and sorted into a single range representing the difference of the two source ranges.</p>
<p><em>result</em><br>
An output iterator addressing the position of the first element in the destination range where the two source ranges are to be united into a single sorted range representing the difference of the two source ranges.</p>
<p><em>comp</em><br>
User-defined predicate function object that defines the sense in which one element is greater than another. The binary predicate takes two arguments and should return <strong>true</strong> when the first element is less than the second element and <strong>false</strong> otherwise.</p>
<h3 id="return-value-50" class="heading-with-anchor">Return Value<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#return-value-50"></a></h3>
<p>An output iterator addressing the position one past the last element in the sorted destination range representing the difference of the two source ranges.</p>
<h3 id="remarks-69" class="heading-with-anchor">Remarks<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#remarks-69"></a></h3>
<p>The sorted source ranges referenced must be valid; all pointers must be dereferenceable and within each sequence the last position must be reachable from the first by incrementation.</p>
<p>The destination range should not overlap either of the source ranges and should be large enough to contain the first source range.</p>
<p>The sorted source ranges must each be arranged as a precondition to the application of the <code>set_difference</code> algorithm in accordance with the same ordering as is to be used by the algorithm to sort the combined ranges.</p>
<p>The operation is stable as the relative order of elements within each range is preserved in the destination range. The source ranges are not modified by the algorithm merge.</p>
<p>The value types of the input iterators need be less-than-comparable to be ordered, so that, given two elements, it may be determined either that they are equivalent (in the sense that neither is less than the other) or that one is less than the other. This results in an ordering between the nonequivalent elements. When there are equivalent elements in both source ranges, the elements in the first range precede the elements from the second source range in the destination range. If the source ranges contain duplicates of an element such that there are more in the first source range than in the second, then the destination range will contain the number by which the occurrences of those elements in the first source range exceed the occurrences of those elements in the second source range.</p>
<p>The complexity of the algorithm is linear with at most 2 * ( ( <em>last1 - first1</em>) - ( <em>last2 - first2</em>) ) - 1 comparisons for nonempty source ranges.</p>
<h3 id="example-51" class="heading-with-anchor">Example<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#example-51"></a></h3>
<div class="codeHeader" id="code-try-144" data-bi-name="code-header"><span class="language">C++</span>
			<button class="action" data-bi-name="copy">
				<span class="docon docon-edit-copy" role="presentation"></span>
				<span>Copy</span>
			</button></div><pre><code class="lang-cpp" data-author-content="// alg_set_diff.cpp
// compile with: /EHsc
#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;functional&gt;      // For greater&lt;int&gt;( )
#include &lt;iostream&gt;

// Return whether modulus of elem1 is less than modulus of elem2
bool mod_lesser (int elem1, int elem2 )
{
   if (elem1 &lt; 0)
      elem1 = - elem1;
   if (elem2 &lt; 0)
      elem2 = - elem2;
   return elem1 &lt; elem2;
}

int main()
{
   using namespace std;
   vector &lt;int&gt; v1a, v1b, v1 ( 12 );
   vector &lt;int&gt;::iterator Iter1a,  Iter1b, Iter1, Result1;

   // Constructing vectors v1a &amp; v1b with default less-than ordering
   int i;
   for ( i = -1 ; i &lt;= 4 ; i++ )
   {
      v1a.push_back(  i );
   }

   int ii;
   for ( ii =-3 ; ii &lt;= 0 ; ii++ )
   {
      v1b.push_back(  ii  );
   }

   cout &lt;&lt; &quot;Original vector v1a with range sorted by the\n &quot;
        &lt;&lt;  &quot;binary predicate less than is  v1a = ( &quot; ;
   for ( Iter1a = v1a.begin( ) ; Iter1a != v1a.end( ) ; Iter1a++ )
      cout &lt;&lt; *Iter1a &lt;&lt; &quot; &quot;;
   cout &lt;&lt; &quot;).&quot; &lt;&lt; endl;

   cout &lt;&lt; &quot;Original vector v1b with range sorted by the\n &quot;
        &lt;&lt;  &quot;binary predicate less than is  v1b = ( &quot; ;
   for ( Iter1b = v1b.begin( ) ; Iter1b != v1b.end( ) ; Iter1b++ )
      cout &lt;&lt; *Iter1b &lt;&lt; &quot; &quot;;
   cout &lt;&lt; &quot;).&quot; &lt;&lt; endl;

   // Constructing vectors v2a &amp; v2b with ranges sorted by greater
   vector &lt;int&gt; v2a ( v1a ) , v2b ( v1b ) ,  v2 ( v1 );
   vector &lt;int&gt;::iterator Iter2a, Iter2b, Iter2, Result2;
   sort ( v2a.begin( ), v2a.end( ), greater&lt;int&gt;( ) );
   sort ( v2b.begin( ), v2b.end( ), greater&lt;int&gt;( ) );

   cout &lt;&lt; &quot;Original vector v2a with range sorted by the\n &quot;
        &lt;&lt;  &quot;binary predicate greater is   v2a =  ( &quot; ;
   for ( Iter2a = v2a.begin( ) ; Iter2a != v2a.end( ) ; Iter2a++ )
      cout &lt;&lt; *Iter2a &lt;&lt; &quot; &quot;;
   cout &lt;&lt; &quot;).&quot; &lt;&lt; endl;

   cout &lt;&lt; &quot;Original vector v2b with range sorted by the\n &quot;
        &lt;&lt;  &quot;binary predicate greater is   v2b =  ( &quot; ;
   for ( Iter2b = v2b.begin( ) ; Iter2b != v2b.end( ) ; Iter2b++ )
      cout &lt;&lt; *Iter2b &lt;&lt; &quot; &quot;;
   cout &lt;&lt; &quot;).&quot; &lt;&lt; endl;

   // Constructing vectors v3a &amp; v3b with ranges sorted by mod_lesser
   vector &lt;int&gt; v3a ( v1a ), v3b ( v1b ) ,  v3 ( v1 );
   vector &lt;int&gt;::iterator Iter3a,  Iter3b, Iter3, Result3;
   sort ( v3a.begin( ), v3a.end( ), mod_lesser );
   sort ( v3b.begin( ), v3b.end( ), mod_lesser  );

   cout &lt;&lt; &quot;Original vector v3a with range sorted by the\n &quot;
        &lt;&lt;  &quot;binary predicate mod_lesser is   v3a =  ( &quot; ;
   for ( Iter3a = v3a.begin( ) ; Iter3a != v3a.end( ) ; Iter3a++ )
      cout &lt;&lt; *Iter3a &lt;&lt; &quot; &quot;;
   cout &lt;&lt; &quot;).&quot; &lt;&lt; endl;

   cout &lt;&lt; &quot;Original vector v3b with range sorted by the\n &quot;
        &lt;&lt;  &quot;binary predicate mod_lesser is   v3b =  ( &quot; ;
   for ( Iter3b = v3b.begin( ) ; Iter3b != v3b.end( ) ; Iter3b++ )
      cout &lt;&lt; *Iter3b &lt;&lt; &quot; &quot;;
   cout &lt;&lt; &quot;).&quot; &lt;&lt; endl;

   // To combine into a difference in asscending
   // order with the default binary predicate less &lt;int&gt;( )
   Result1 = set_difference ( v1a.begin( ), v1a.end( ),
      v1b.begin( ), v1b.end( ), v1.begin( ) );
   cout &lt;&lt; &quot;Set_difference of source ranges with default order,&quot;
        &lt;&lt; &quot;\n vector v1mod =  ( &quot; ;
   for ( Iter1 = v1.begin( ) ; Iter1 != Result1 ; Iter1++ )
      cout &lt;&lt; *Iter1 &lt;&lt; &quot; &quot;;
   cout &lt;&lt; &quot;).&quot; &lt;&lt; endl;

   // To combine into a difference in descending
   // order specify binary predicate greater&lt;int&gt;( )
   Result2 = set_difference ( v2a.begin( ), v2a.end( ),
      v2b.begin( ), v2b.end( ),v2.begin( ), greater &lt;int&gt;( ) );
   cout &lt;&lt; &quot;Set_difference of source ranges with binary&quot;
        &lt;&lt; &quot;predicate greater specified,\n vector v2mod  = ( &quot; ;
   for ( Iter2 = v2.begin( ) ; Iter2 != Result2 ; Iter2++ )
      cout &lt;&lt; *Iter2 &lt;&lt; &quot; &quot;;
   cout &lt;&lt; &quot;).&quot; &lt;&lt; endl;

   // To combine into a difference applying a user
   // defined binary predicate mod_lesser
   Result3 = set_difference (  v3a.begin( ), v3a.end( ),
      v3b.begin( ), v3b.end( ), v3.begin( ), mod_lesser );
   cout &lt;&lt; &quot;Set_difference of source ranges with binary &quot;
        &lt;&lt; &quot;predicate mod_lesser specified,\n vector v3mod  = ( &quot; ; ;
   for ( Iter3 = v3.begin( ) ; Iter3 != Result3 ; Iter3++ )
      cout &lt;&lt; *Iter3 &lt;&lt; &quot; &quot;;
   cout &lt;&lt; &quot;).&quot; &lt;&lt; endl;
}
"><span class="hljs-comment">// alg_set_diff.cpp</span>
<span class="hljs-comment">// compile with: /EHsc</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;functional&gt;      // For greater&lt;int&gt;( )</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span>

<span class="hljs-comment">// Return whether modulus of elem1 is less than modulus of elem2</span>
<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">mod_lesser</span> <span class="hljs-params">(<span class="hljs-keyword">int</span> elem1, <span class="hljs-keyword">int</span> elem2 )</span>
</span>{
   <span class="hljs-keyword">if</span> (elem1 &lt; <span class="hljs-number">0</span>)
      elem1 = - elem1;
   <span class="hljs-keyword">if</span> (elem2 &lt; <span class="hljs-number">0</span>)
      elem2 = - elem2;
   <span class="hljs-keyword">return</span> elem1 &lt; elem2;
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
   <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;
   <span class="hljs-built_in">vector</span> &lt;<span class="hljs-keyword">int</span>&gt; v1a, v1b, v1 ( <span class="hljs-number">12</span> );
   <span class="hljs-built_in">vector</span> &lt;<span class="hljs-keyword">int</span>&gt;::iterator Iter1a,  Iter1b, Iter1, Result1;

   <span class="hljs-comment">// Constructing vectors v1a &amp; v1b with default less-than ordering</span>
   <span class="hljs-keyword">int</span> i;
   <span class="hljs-keyword">for</span> ( i = <span class="hljs-number">-1</span> ; i &lt;= <span class="hljs-number">4</span> ; i++ )
   {
      v1a.push_back(  i );
   }

   <span class="hljs-keyword">int</span> ii;
   <span class="hljs-keyword">for</span> ( ii =<span class="hljs-number">-3</span> ; ii &lt;= <span class="hljs-number">0</span> ; ii++ )
   {
      v1b.push_back(  ii  );
   }

   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Original vector v1a with range sorted by the\n "</span>
        &lt;&lt;  <span class="hljs-string">"binary predicate less than is  v1a = ( "</span> ;
   <span class="hljs-keyword">for</span> ( Iter1a = v1a.begin( ) ; Iter1a != v1a.end( ) ; Iter1a++ )
      <span class="hljs-built_in">cout</span> &lt;&lt; *Iter1a &lt;&lt; <span class="hljs-string">" "</span>;
   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">")."</span> &lt;&lt; <span class="hljs-built_in">endl</span>;

   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Original vector v1b with range sorted by the\n "</span>
        &lt;&lt;  <span class="hljs-string">"binary predicate less than is  v1b = ( "</span> ;
   <span class="hljs-keyword">for</span> ( Iter1b = v1b.begin( ) ; Iter1b != v1b.end( ) ; Iter1b++ )
      <span class="hljs-built_in">cout</span> &lt;&lt; *Iter1b &lt;&lt; <span class="hljs-string">" "</span>;
   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">")."</span> &lt;&lt; <span class="hljs-built_in">endl</span>;

   <span class="hljs-comment">// Constructing vectors v2a &amp; v2b with ranges sorted by greater</span>
   <span class="hljs-built_in">vector</span> &lt;<span class="hljs-keyword">int</span>&gt; v2a ( v1a ) , v2b ( v1b ) ,  v2 ( v1 );
   <span class="hljs-built_in">vector</span> &lt;<span class="hljs-keyword">int</span>&gt;::iterator Iter2a, Iter2b, Iter2, Result2;
   sort ( v2a.begin( ), v2a.end( ), greater&lt;<span class="hljs-keyword">int</span>&gt;( ) );
   sort ( v2b.begin( ), v2b.end( ), greater&lt;<span class="hljs-keyword">int</span>&gt;( ) );

   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Original vector v2a with range sorted by the\n "</span>
        &lt;&lt;  <span class="hljs-string">"binary predicate greater is   v2a =  ( "</span> ;
   <span class="hljs-keyword">for</span> ( Iter2a = v2a.begin( ) ; Iter2a != v2a.end( ) ; Iter2a++ )
      <span class="hljs-built_in">cout</span> &lt;&lt; *Iter2a &lt;&lt; <span class="hljs-string">" "</span>;
   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">")."</span> &lt;&lt; <span class="hljs-built_in">endl</span>;

   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Original vector v2b with range sorted by the\n "</span>
        &lt;&lt;  <span class="hljs-string">"binary predicate greater is   v2b =  ( "</span> ;
   <span class="hljs-keyword">for</span> ( Iter2b = v2b.begin( ) ; Iter2b != v2b.end( ) ; Iter2b++ )
      <span class="hljs-built_in">cout</span> &lt;&lt; *Iter2b &lt;&lt; <span class="hljs-string">" "</span>;
   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">")."</span> &lt;&lt; <span class="hljs-built_in">endl</span>;

   <span class="hljs-comment">// Constructing vectors v3a &amp; v3b with ranges sorted by mod_lesser</span>
   <span class="hljs-built_in">vector</span> &lt;<span class="hljs-keyword">int</span>&gt; v3a ( v1a ), v3b ( v1b ) ,  v3 ( v1 );
   <span class="hljs-built_in">vector</span> &lt;<span class="hljs-keyword">int</span>&gt;::iterator Iter3a,  Iter3b, Iter3, Result3;
   sort ( v3a.begin( ), v3a.end( ), mod_lesser );
   sort ( v3b.begin( ), v3b.end( ), mod_lesser  );

   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Original vector v3a with range sorted by the\n "</span>
        &lt;&lt;  <span class="hljs-string">"binary predicate mod_lesser is   v3a =  ( "</span> ;
   <span class="hljs-keyword">for</span> ( Iter3a = v3a.begin( ) ; Iter3a != v3a.end( ) ; Iter3a++ )
      <span class="hljs-built_in">cout</span> &lt;&lt; *Iter3a &lt;&lt; <span class="hljs-string">" "</span>;
   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">")."</span> &lt;&lt; <span class="hljs-built_in">endl</span>;

   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Original vector v3b with range sorted by the\n "</span>
        &lt;&lt;  <span class="hljs-string">"binary predicate mod_lesser is   v3b =  ( "</span> ;
   <span class="hljs-keyword">for</span> ( Iter3b = v3b.begin( ) ; Iter3b != v3b.end( ) ; Iter3b++ )
      <span class="hljs-built_in">cout</span> &lt;&lt; *Iter3b &lt;&lt; <span class="hljs-string">" "</span>;
   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">")."</span> &lt;&lt; <span class="hljs-built_in">endl</span>;

   <span class="hljs-comment">// To combine into a difference in asscending</span>
   <span class="hljs-comment">// order with the default binary predicate less &lt;int&gt;( )</span>
   Result1 = set_difference ( v1a.begin( ), v1a.end( ),
      v1b.begin( ), v1b.end( ), v1.begin( ) );
   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Set_difference of source ranges with default order,"</span>
        &lt;&lt; <span class="hljs-string">"\n vector v1mod =  ( "</span> ;
   <span class="hljs-keyword">for</span> ( Iter1 = v1.begin( ) ; Iter1 != Result1 ; Iter1++ )
      <span class="hljs-built_in">cout</span> &lt;&lt; *Iter1 &lt;&lt; <span class="hljs-string">" "</span>;
   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">")."</span> &lt;&lt; <span class="hljs-built_in">endl</span>;

   <span class="hljs-comment">// To combine into a difference in descending</span>
   <span class="hljs-comment">// order specify binary predicate greater&lt;int&gt;( )</span>
   Result2 = set_difference ( v2a.begin( ), v2a.end( ),
      v2b.begin( ), v2b.end( ),v2.begin( ), greater &lt;<span class="hljs-keyword">int</span>&gt;( ) );
   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Set_difference of source ranges with binary"</span>
        &lt;&lt; <span class="hljs-string">"predicate greater specified,\n vector v2mod  = ( "</span> ;
   <span class="hljs-keyword">for</span> ( Iter2 = v2.begin( ) ; Iter2 != Result2 ; Iter2++ )
      <span class="hljs-built_in">cout</span> &lt;&lt; *Iter2 &lt;&lt; <span class="hljs-string">" "</span>;
   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">")."</span> &lt;&lt; <span class="hljs-built_in">endl</span>;

   <span class="hljs-comment">// To combine into a difference applying a user</span>
   <span class="hljs-comment">// defined binary predicate mod_lesser</span>
   Result3 = set_difference (  v3a.begin( ), v3a.end( ),
      v3b.begin( ), v3b.end( ), v3.begin( ), mod_lesser );
   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Set_difference of source ranges with binary "</span>
        &lt;&lt; <span class="hljs-string">"predicate mod_lesser specified,\n vector v3mod  = ( "</span> ; ;
   <span class="hljs-keyword">for</span> ( Iter3 = v3.begin( ) ; Iter3 != Result3 ; Iter3++ )
      <span class="hljs-built_in">cout</span> &lt;&lt; *Iter3 &lt;&lt; <span class="hljs-string">" "</span>;
   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">")."</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
}
</code></pre>
<h2 id="set_intersection" class="heading-with-anchor">  set_intersection<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#set_intersection"></a></h2>
<p>Unites all of the elements that belong to both sorted source ranges into a single, sorted destination range, where the ordering criterion may be specified by a binary predicate.</p>
<div class="codeHeader" id="code-try-145" data-bi-name="code-header"><span class="language">C++</span>
			<button class="action" data-bi-name="copy">
				<span class="docon docon-edit-copy" role="presentation"></span>
				<span>Copy</span>
			</button></div><pre><code class="lang-cpp" data-author-content="template&lt;class InputIterator1, class InputIterator2, class OutputIterator&gt;
OutputIterator set_intersection(
    InputIterator1 first1,
    InputIterator1 last1,
    InputIterator2 first2,
    InputIterator2 last2,
    OutputIterator result );

template&lt;class InputIterator1, class InputIterator2, class OutputIterator, class BinaryPredicate&gt;
OutputIterator set_intersection(
    InputIterator1 first1,
    InputIterator1 last1,
    InputIterator2 first2,
    InputIterator2 last2,
    OutputIterator result,
    BinaryPredicate comp );
"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InputIterator1</span>, <span class="hljs-title">class</span> <span class="hljs-title">InputIterator2</span>, <span class="hljs-title">class</span> <span class="hljs-title">OutputIterator</span>&gt;
<span class="hljs-title">OutputIterator</span> <span class="hljs-title">set_intersection</span>(
    <span class="hljs-title">InputIterator1</span> <span class="hljs-title">first1</span>,
    <span class="hljs-title">InputIterator1</span> <span class="hljs-title">last1</span>,
    <span class="hljs-title">InputIterator2</span> <span class="hljs-title">first2</span>,
    <span class="hljs-title">InputIterator2</span> <span class="hljs-title">last2</span>,
    <span class="hljs-title">OutputIterator</span> <span class="hljs-title">result</span> );</span>

<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InputIterator1</span>, <span class="hljs-title">class</span> <span class="hljs-title">InputIterator2</span>, <span class="hljs-title">class</span> <span class="hljs-title">OutputIterator</span>, <span class="hljs-title">class</span> <span class="hljs-title">BinaryPredicate</span>&gt;
<span class="hljs-title">OutputIterator</span> <span class="hljs-title">set_intersection</span>(
    <span class="hljs-title">InputIterator1</span> <span class="hljs-title">first1</span>,
    <span class="hljs-title">InputIterator1</span> <span class="hljs-title">last1</span>,
    <span class="hljs-title">InputIterator2</span> <span class="hljs-title">first2</span>,
    <span class="hljs-title">InputIterator2</span> <span class="hljs-title">last2</span>,
    <span class="hljs-title">OutputIterator</span> <span class="hljs-title">result</span>,
    <span class="hljs-title">BinaryPredicate</span> <span class="hljs-title">comp</span> );</span>
</code></pre>
<h3 id="parameters-70" class="heading-with-anchor">Parameters<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#parameters-70"></a></h3>
<p><em>first1</em><br>
An input iterator addressing the position of the first element in the first of two sorted source ranges to be united and sorted into a single range representing the intersection of the two source ranges.</p>
<p><em>last1</em><br>
An input iterator addressing the position one past the last element in the first of two sorted source ranges to be united and sorted into a single range representing the intersection of the two source ranges.</p>
<p><em>first2</em><br>
An input iterator addressing the position of the first element in second of two consecutive sorted source ranges to be united and sorted into a single range representing the intersection of the two source ranges.</p>
<p><em>last2</em><br>
An input iterator addressing the position one past the last element in second of two consecutive sorted source ranges to be united and sorted into a single range representing the intersection of the two source ranges.</p>
<p><strong>_</strong> <em>Result</em>
An output iterator addressing the position of the first element in the destination range where the two source ranges are to be united into a single sorted range representing the intersection of the two source ranges.</p>
<p><em>comp</em><br>
User-defined predicate function object that defines the sense in which one element is greater than another. The binary predicate takes two arguments and should return <strong>true</strong> when the first element is less than the second element and <strong>false</strong> otherwise.</p>
<h3 id="return-value-51" class="heading-with-anchor">Return Value<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#return-value-51"></a></h3>
<p>An output iterator addressing the position one past the last element in the sorted destination range representing the intersection of the two source ranges.</p>
<h3 id="remarks-70" class="heading-with-anchor">Remarks<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#remarks-70"></a></h3>
<p>The sorted source ranges referenced must be valid; all pointers must be dereferenceable and within each sequence the last position must be reachable from the first by incrementation.</p>
<p>The destination range should not overlap either of the source ranges and should be large enough to contain the destination range.</p>
<p>The sorted source ranges must each be arranged as a precondition to the application of the merge algorithm in accordance with the same ordering as is to be used by the algorithm to sort the combined ranges.</p>
<p>The operation is stable as the relative order of elements within each range is preserved in the destination range. The source ranges are not modified by the algorithm.</p>
<p>The value types of the input iterators need be less-than comparable to be ordered, so that, given two elements, it may be determined either that they are equivalent (in the sense that neither is less than the other) or that one is less than the other. This results in an ordering between the nonequivalent elements. When there are equivalent elements in both source ranges, the elements in the first range precede the elements from the second source range in the destination range. If the source ranges contain duplicates of an element, then the destination range will contain the maximum number of those elements that occur in both source ranges.</p>
<p>The complexity of the algorithm is linear with at most 2 * ( ( <em>last1 - first1</em>) + ( <em>last2 - first2</em>) ) - 1 comparisons for nonempty source ranges.</p>
<h3 id="example-52" class="heading-with-anchor">Example<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#example-52"></a></h3>
<div class="codeHeader" id="code-try-146" data-bi-name="code-header"><span class="language">C++</span>
			<button class="action" data-bi-name="copy">
				<span class="docon docon-edit-copy" role="presentation"></span>
				<span>Copy</span>
			</button></div><pre><code class="lang-cpp" data-author-content="// alg_set_intersection.cpp
// compile with: /EHsc
#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;functional&gt;   // For greater&lt;int&gt;( )
#include &lt;iostream&gt;

// Return whether modulus of elem1 is less than modulus of elem2
bool mod_lesser (int elem1, int elem2 ) {
   if ( elem1 &lt; 0 )
      elem1 = - elem1;
   if ( elem2 &lt; 0 )
      elem2 = - elem2;
   return elem1 &lt; elem2;
}

int main() {
   using namespace std;
   vector &lt;int&gt; v1a, v1b, v1 ( 12 );
   vector &lt;int&gt;::iterator Iter1a,  Iter1b, Iter1, Result1;

   // Constructing vectors v1a &amp; v1b with default less than ordering
   int i;
   for ( i = -1 ; i &lt;= 3 ; i++ )
      v1a.push_back( i );

   int ii;
   for ( ii =-3 ; ii &lt;= 1 ; ii++ )
      v1b.push_back( ii );

   cout &lt;&lt; &quot;Original vector v1a with range sorted by the\n &quot;
        &lt;&lt;  &quot;binary predicate less than is  v1a = ( &quot; ;
   for ( Iter1a = v1a.begin( ) ; Iter1a != v1a.end( ) ; Iter1a++ )
      cout &lt;&lt; *Iter1a &lt;&lt; &quot; &quot;;
   cout &lt;&lt; &quot;).&quot; &lt;&lt; endl;

   cout &lt;&lt; &quot;Original vector v1b with range sorted by the\n &quot;
        &lt;&lt;  &quot;binary predicate less than is  v1b = ( &quot; ;
   for ( Iter1b = v1b.begin( ) ; Iter1b != v1b.end( ) ; Iter1b++ )
      cout &lt;&lt; *Iter1b &lt;&lt; &quot; &quot;;
   cout &lt;&lt; &quot;).&quot; &lt;&lt; endl;

   // Constructing vectors v2a &amp; v2b with ranges sorted by greater
   vector &lt;int&gt; v2a ( v1a ) , v2b ( v1b ) , v2 ( v1 );
   vector &lt;int&gt;::iterator Iter2a, Iter2b, Iter2, Result2;
   sort ( v2a.begin( ), v2a.end( ), greater&lt;int&gt;( ) );
   sort ( v2b.begin( ), v2b.end( ), greater&lt;int&gt;( ) );

   cout &lt;&lt; &quot;Original vector v2a with range sorted by the\n &quot;
        &lt;&lt; &quot;binary predicate greater is   v2a =  ( &quot; ;
   for ( Iter2a = v2a.begin( ) ; Iter2a != v2a.end( ) ; Iter2a++ )
      cout &lt;&lt; *Iter2a &lt;&lt; &quot; &quot;;
   cout &lt;&lt; &quot;).&quot; &lt;&lt; endl;

   cout &lt;&lt; &quot;Original vector v2b with range sorted by the\n &quot;
        &lt;&lt; &quot;binary predicate greater is   v2b =  ( &quot; ;
   for ( Iter2b = v2b.begin( ) ; Iter2b != v2b.end( ) ; Iter2b++ )
      cout &lt;&lt; *Iter2b &lt;&lt; &quot; &quot;;
   cout &lt;&lt; &quot;).&quot; &lt;&lt; endl;

   // Constructing vectors v3a &amp; v3b with ranges sorted by mod_lesser
   vector &lt;int&gt; v3a ( v1a ), v3b ( v1b ) , v3 ( v1 );
   vector &lt;int&gt;::iterator Iter3a,  Iter3b, Iter3, Result3;
   sort ( v3a.begin( ), v3a.end( ), mod_lesser );
   sort ( v3b.begin( ), v3b.end( ), mod_lesser );

   cout &lt;&lt; &quot;Original vector v3a with range sorted by the\n &quot;
        &lt;&lt;  &quot;binary predicate mod_lesser is   v3a =  ( &quot; ;
   for ( Iter3a = v3a.begin( ) ; Iter3a != v3a.end( ) ; Iter3a++ )
      cout &lt;&lt; *Iter3a &lt;&lt; &quot; &quot;;
   cout &lt;&lt; &quot;).&quot; &lt;&lt; endl;

   cout &lt;&lt; &quot;Original vector v3b with range sorted by the\n &quot;
           &lt;&lt;  &quot;binary predicate mod_lesser is   v3b =  ( &quot; ;
   for ( Iter3b = v3b.begin( ) ; Iter3b != v3b.end( ) ; Iter3b++ )
      cout &lt;&lt; *Iter3b &lt;&lt; &quot; &quot;;
   cout &lt;&lt; &quot;).&quot; &lt;&lt; endl;

   // To combine into an intersection in asscending order with the
   // default binary predicate less &lt;int&gt;( )
   Result1 = set_intersection ( v1a.begin( ), v1a.end( ),
      v1b.begin( ), v1b.end( ), v1.begin( ) );
   cout &lt;&lt; &quot;Intersection of source ranges with default order,&quot;
        &lt;&lt; &quot;\n vector v1mod =  ( &quot; ;
   for ( Iter1 = v1.begin( ) ; Iter1 != Result1 ; ++Iter1 )
      cout &lt;&lt; *Iter1 &lt;&lt; &quot; &quot;;
   cout &lt;&lt; &quot;).&quot; &lt;&lt; endl;

   // To combine into an intersection in descending order, specify
   // binary predicate greater&lt;int&gt;( )
   Result2 = set_intersection ( v2a.begin( ), v2a.end( ),
      v2b.begin( ), v2b.end( ),v2.begin( ), greater &lt;int&gt;( ) );
   cout &lt;&lt; &quot;Intersection of source ranges with binary predicate&quot;
        &lt;&lt; &quot; greater specified,\n vector v2mod  = ( &quot; ;
   for ( Iter2 = v2.begin( ) ; Iter2 != Result2 ; ++Iter2 )
      cout &lt;&lt; *Iter2 &lt;&lt; &quot; &quot;;
   cout &lt;&lt; &quot;).&quot; &lt;&lt; endl;

   // To combine into an intersection applying a user-defined
   // binary predicate mod_lesser
   Result3 = set_intersection ( v3a.begin( ), v3a.end( ),
      v3b.begin( ), v3b.end( ), v3.begin( ), mod_lesser );
   cout &lt;&lt; &quot;Intersection of source ranges with binary predicate &quot;
        &lt;&lt; &quot;mod_lesser specified,\n vector v3mod  = ( &quot; ; ;
   for ( Iter3 = v3.begin( ) ; Iter3 != Result3 ; ++Iter3 )
      cout &lt;&lt; *Iter3 &lt;&lt; &quot; &quot;;
   cout &lt;&lt; &quot;).&quot; &lt;&lt; endl;
}
"><span class="hljs-comment">// alg_set_intersection.cpp</span>
<span class="hljs-comment">// compile with: /EHsc</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;functional&gt;   // For greater&lt;int&gt;( )</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span>

<span class="hljs-comment">// Return whether modulus of elem1 is less than modulus of elem2</span>
<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">mod_lesser</span> <span class="hljs-params">(<span class="hljs-keyword">int</span> elem1, <span class="hljs-keyword">int</span> elem2 )</span> </span>{
   <span class="hljs-keyword">if</span> ( elem1 &lt; <span class="hljs-number">0</span> )
      elem1 = - elem1;
   <span class="hljs-keyword">if</span> ( elem2 &lt; <span class="hljs-number">0</span> )
      elem2 = - elem2;
   <span class="hljs-keyword">return</span> elem1 &lt; elem2;
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
   <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;
   <span class="hljs-built_in">vector</span> &lt;<span class="hljs-keyword">int</span>&gt; v1a, v1b, v1 ( <span class="hljs-number">12</span> );
   <span class="hljs-built_in">vector</span> &lt;<span class="hljs-keyword">int</span>&gt;::iterator Iter1a,  Iter1b, Iter1, Result1;

   <span class="hljs-comment">// Constructing vectors v1a &amp; v1b with default less than ordering</span>
   <span class="hljs-keyword">int</span> i;
   <span class="hljs-keyword">for</span> ( i = <span class="hljs-number">-1</span> ; i &lt;= <span class="hljs-number">3</span> ; i++ )
      v1a.push_back( i );

   <span class="hljs-keyword">int</span> ii;
   <span class="hljs-keyword">for</span> ( ii =<span class="hljs-number">-3</span> ; ii &lt;= <span class="hljs-number">1</span> ; ii++ )
      v1b.push_back( ii );

   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Original vector v1a with range sorted by the\n "</span>
        &lt;&lt;  <span class="hljs-string">"binary predicate less than is  v1a = ( "</span> ;
   <span class="hljs-keyword">for</span> ( Iter1a = v1a.begin( ) ; Iter1a != v1a.end( ) ; Iter1a++ )
      <span class="hljs-built_in">cout</span> &lt;&lt; *Iter1a &lt;&lt; <span class="hljs-string">" "</span>;
   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">")."</span> &lt;&lt; <span class="hljs-built_in">endl</span>;

   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Original vector v1b with range sorted by the\n "</span>
        &lt;&lt;  <span class="hljs-string">"binary predicate less than is  v1b = ( "</span> ;
   <span class="hljs-keyword">for</span> ( Iter1b = v1b.begin( ) ; Iter1b != v1b.end( ) ; Iter1b++ )
      <span class="hljs-built_in">cout</span> &lt;&lt; *Iter1b &lt;&lt; <span class="hljs-string">" "</span>;
   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">")."</span> &lt;&lt; <span class="hljs-built_in">endl</span>;

   <span class="hljs-comment">// Constructing vectors v2a &amp; v2b with ranges sorted by greater</span>
   <span class="hljs-built_in">vector</span> &lt;<span class="hljs-keyword">int</span>&gt; v2a ( v1a ) , v2b ( v1b ) , v2 ( v1 );
   <span class="hljs-built_in">vector</span> &lt;<span class="hljs-keyword">int</span>&gt;::iterator Iter2a, Iter2b, Iter2, Result2;
   sort ( v2a.begin( ), v2a.end( ), greater&lt;<span class="hljs-keyword">int</span>&gt;( ) );
   sort ( v2b.begin( ), v2b.end( ), greater&lt;<span class="hljs-keyword">int</span>&gt;( ) );

   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Original vector v2a with range sorted by the\n "</span>
        &lt;&lt; <span class="hljs-string">"binary predicate greater is   v2a =  ( "</span> ;
   <span class="hljs-keyword">for</span> ( Iter2a = v2a.begin( ) ; Iter2a != v2a.end( ) ; Iter2a++ )
      <span class="hljs-built_in">cout</span> &lt;&lt; *Iter2a &lt;&lt; <span class="hljs-string">" "</span>;
   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">")."</span> &lt;&lt; <span class="hljs-built_in">endl</span>;

   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Original vector v2b with range sorted by the\n "</span>
        &lt;&lt; <span class="hljs-string">"binary predicate greater is   v2b =  ( "</span> ;
   <span class="hljs-keyword">for</span> ( Iter2b = v2b.begin( ) ; Iter2b != v2b.end( ) ; Iter2b++ )
      <span class="hljs-built_in">cout</span> &lt;&lt; *Iter2b &lt;&lt; <span class="hljs-string">" "</span>;
   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">")."</span> &lt;&lt; <span class="hljs-built_in">endl</span>;

   <span class="hljs-comment">// Constructing vectors v3a &amp; v3b with ranges sorted by mod_lesser</span>
   <span class="hljs-built_in">vector</span> &lt;<span class="hljs-keyword">int</span>&gt; v3a ( v1a ), v3b ( v1b ) , v3 ( v1 );
   <span class="hljs-built_in">vector</span> &lt;<span class="hljs-keyword">int</span>&gt;::iterator Iter3a,  Iter3b, Iter3, Result3;
   sort ( v3a.begin( ), v3a.end( ), mod_lesser );
   sort ( v3b.begin( ), v3b.end( ), mod_lesser );

   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Original vector v3a with range sorted by the\n "</span>
        &lt;&lt;  <span class="hljs-string">"binary predicate mod_lesser is   v3a =  ( "</span> ;
   <span class="hljs-keyword">for</span> ( Iter3a = v3a.begin( ) ; Iter3a != v3a.end( ) ; Iter3a++ )
      <span class="hljs-built_in">cout</span> &lt;&lt; *Iter3a &lt;&lt; <span class="hljs-string">" "</span>;
   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">")."</span> &lt;&lt; <span class="hljs-built_in">endl</span>;

   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Original vector v3b with range sorted by the\n "</span>
           &lt;&lt;  <span class="hljs-string">"binary predicate mod_lesser is   v3b =  ( "</span> ;
   <span class="hljs-keyword">for</span> ( Iter3b = v3b.begin( ) ; Iter3b != v3b.end( ) ; Iter3b++ )
      <span class="hljs-built_in">cout</span> &lt;&lt; *Iter3b &lt;&lt; <span class="hljs-string">" "</span>;
   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">")."</span> &lt;&lt; <span class="hljs-built_in">endl</span>;

   <span class="hljs-comment">// To combine into an intersection in asscending order with the</span>
   <span class="hljs-comment">// default binary predicate less &lt;int&gt;( )</span>
   Result1 = set_intersection ( v1a.begin( ), v1a.end( ),
      v1b.begin( ), v1b.end( ), v1.begin( ) );
   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Intersection of source ranges with default order,"</span>
        &lt;&lt; <span class="hljs-string">"\n vector v1mod =  ( "</span> ;
   <span class="hljs-keyword">for</span> ( Iter1 = v1.begin( ) ; Iter1 != Result1 ; ++Iter1 )
      <span class="hljs-built_in">cout</span> &lt;&lt; *Iter1 &lt;&lt; <span class="hljs-string">" "</span>;
   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">")."</span> &lt;&lt; <span class="hljs-built_in">endl</span>;

   <span class="hljs-comment">// To combine into an intersection in descending order, specify</span>
   <span class="hljs-comment">// binary predicate greater&lt;int&gt;( )</span>
   Result2 = set_intersection ( v2a.begin( ), v2a.end( ),
      v2b.begin( ), v2b.end( ),v2.begin( ), greater &lt;<span class="hljs-keyword">int</span>&gt;( ) );
   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Intersection of source ranges with binary predicate"</span>
        &lt;&lt; <span class="hljs-string">" greater specified,\n vector v2mod  = ( "</span> ;
   <span class="hljs-keyword">for</span> ( Iter2 = v2.begin( ) ; Iter2 != Result2 ; ++Iter2 )
      <span class="hljs-built_in">cout</span> &lt;&lt; *Iter2 &lt;&lt; <span class="hljs-string">" "</span>;
   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">")."</span> &lt;&lt; <span class="hljs-built_in">endl</span>;

   <span class="hljs-comment">// To combine into an intersection applying a user-defined</span>
   <span class="hljs-comment">// binary predicate mod_lesser</span>
   Result3 = set_intersection ( v3a.begin( ), v3a.end( ),
      v3b.begin( ), v3b.end( ), v3.begin( ), mod_lesser );
   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Intersection of source ranges with binary predicate "</span>
        &lt;&lt; <span class="hljs-string">"mod_lesser specified,\n vector v3mod  = ( "</span> ; ;
   <span class="hljs-keyword">for</span> ( Iter3 = v3.begin( ) ; Iter3 != Result3 ; ++Iter3 )
      <span class="hljs-built_in">cout</span> &lt;&lt; *Iter3 &lt;&lt; <span class="hljs-string">" "</span>;
   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">")."</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
}
</code></pre>
<h2 id="set_symmetric_difference" class="heading-with-anchor">  set_symmetric_difference<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#set_symmetric_difference"></a></h2>
<p>Unites all of the elements that belong to one, but not both, of the sorted source ranges into a single, sorted destination range, where the ordering criterion may be specified by a binary predicate.</p>
<div class="codeHeader" id="code-try-147" data-bi-name="code-header"><span class="language">C++</span>
			<button class="action" data-bi-name="copy">
				<span class="docon docon-edit-copy" role="presentation"></span>
				<span>Copy</span>
			</button></div><pre><code class="lang-cpp" data-author-content="template&lt;class InputIterator1, class InputIterator2, class OutputIterator&gt;
OutputIterator set_symmetric_difference(
    InputIterator1 first1,
    InputIterator1 last1,
    InputIterator2 first2,
    InputIterator2 last2,
    OutputIterator result );

template&lt;class InputIterator1, class InputIterator2, class OutputIterator, class BinaryPredicate&gt;
OutputIterator set_symmetric_difference(
    InputIterator1 first1,
    InputIterator1 last1,
    InputIterator2 first2,
    InputIterator2 last2,
    OutputIterator result,
    BinaryPredicate comp );
"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InputIterator1</span>, <span class="hljs-title">class</span> <span class="hljs-title">InputIterator2</span>, <span class="hljs-title">class</span> <span class="hljs-title">OutputIterator</span>&gt;
<span class="hljs-title">OutputIterator</span> <span class="hljs-title">set_symmetric_difference</span>(
    <span class="hljs-title">InputIterator1</span> <span class="hljs-title">first1</span>,
    <span class="hljs-title">InputIterator1</span> <span class="hljs-title">last1</span>,
    <span class="hljs-title">InputIterator2</span> <span class="hljs-title">first2</span>,
    <span class="hljs-title">InputIterator2</span> <span class="hljs-title">last2</span>,
    <span class="hljs-title">OutputIterator</span> <span class="hljs-title">result</span> );</span>

<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InputIterator1</span>, <span class="hljs-title">class</span> <span class="hljs-title">InputIterator2</span>, <span class="hljs-title">class</span> <span class="hljs-title">OutputIterator</span>, <span class="hljs-title">class</span> <span class="hljs-title">BinaryPredicate</span>&gt;
<span class="hljs-title">OutputIterator</span> <span class="hljs-title">set_symmetric_difference</span>(
    <span class="hljs-title">InputIterator1</span> <span class="hljs-title">first1</span>,
    <span class="hljs-title">InputIterator1</span> <span class="hljs-title">last1</span>,
    <span class="hljs-title">InputIterator2</span> <span class="hljs-title">first2</span>,
    <span class="hljs-title">InputIterator2</span> <span class="hljs-title">last2</span>,
    <span class="hljs-title">OutputIterator</span> <span class="hljs-title">result</span>,
    <span class="hljs-title">BinaryPredicate</span> <span class="hljs-title">comp</span> );</span>
</code></pre>
<h3 id="parameters-71" class="heading-with-anchor">Parameters<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#parameters-71"></a></h3>
<p><em>first1</em><br>
An input iterator addressing the position of the first element in the first of two sorted source ranges to be united and sorted into a single range representing the symmetric difference of the two source ranges.</p>
<p><em>last1</em><br>
An input iterator addressing the position one past the last element in the first of two sorted source ranges to be united and sorted into a single range representing the symmetric difference of the two source ranges.</p>
<p><em>first2</em><br>
An input iterator addressing the position of the first element in second of two consecutive sorted source ranges to be united and sorted into a single range representing the symmetric difference of the two source ranges.</p>
<p><em>last2</em><br>
An input iterator addressing the position one past the last element in second of two consecutive sorted source ranges to be united and sorted into a single range representing the symmetric difference of the two source ranges.</p>
<p><strong>_</strong> <em>Result</em>
An output iterator addressing the position of the first element in the destination range where the two source ranges are to be united into a single sorted range representing the symmetric difference of the two source ranges.</p>
<p><em>comp</em><br>
User-defined predicate function object that defines the sense in which one element is greater than another. The binary predicate takes two arguments and should return <strong>true</strong> when the first element is less than the second element and <strong>false</strong> otherwise.</p>
<h3 id="return-value-52" class="heading-with-anchor">Return Value<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#return-value-52"></a></h3>
<p>An output iterator addressing the position one past the last element in the sorted destination range representing the symmetric difference of the two source ranges.</p>
<h3 id="remarks-71" class="heading-with-anchor">Remarks<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#remarks-71"></a></h3>
<p>The sorted source ranges referenced must be valid; all pointers must be dereferenceable and within each sequence the last position must be reachable from the first by incrementation.</p>
<p>The destination range should not overlap either of the source ranges and should be large enough to contain the destination range.</p>
<p>The sorted source ranges must each be arranged as a precondition to the application of the <code>merge*</code> algorithm in accordance with the same ordering as is to be used by the algorithm to sort the combined ranges.</p>
<p>The operation is stable as the relative order of elements within each range is preserved in the destination range. The source ranges are not modified by the algorithm merge.</p>
<p>The value types of the input iterators need be less-than comparable to be ordered, so that, given two elements, it may be determined either that they are equivalent (in the sense that neither is less than the other) or that one is less than the other. This results in an ordering between the nonequivalent elements. When there are equivalent elements in both source ranges, the elements in the first range precede the elements from the second source range in the destination range. If the source ranges contain duplicates of an element, then the destination range will contain the absolute value of the number by which the occurrences of those elements in the one of the source ranges exceeds the occurrences of those elements in the second source range.</p>
<p>The complexity of the algorithm is linear with at most 2 * ( (<em>last1 - first1</em>) - (<em>last2 - first2</em>) ) - 1 comparisons for nonempty source ranges.</p>
<h3 id="example-53" class="heading-with-anchor">Example<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#example-53"></a></h3>
<div class="codeHeader" id="code-try-148" data-bi-name="code-header"><span class="language">C++</span>
			<button class="action" data-bi-name="copy">
				<span class="docon docon-edit-copy" role="presentation"></span>
				<span>Copy</span>
			</button></div><pre><code class="lang-cpp" data-author-content="// alg_set_sym_diff.cpp
// compile with: /EHsc
#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;functional&gt;      // For greater&lt;int&gt;( )
#include &lt;iostream&gt;

// Return whether modulus of elem1 is less than modulus of elem2
bool mod_lesser (int elem1, int elem2 )
{
   if ( elem1 &lt; 0 )
      elem1 = - elem1;
   if ( elem2 &lt; 0 )
      elem2 = - elem2;
   return elem1 &lt; elem2;
}

int main()
{
   using namespace std;
   vector &lt;int&gt; v1a, v1b, v1 ( 12 );
   vector &lt;int&gt;::iterator Iter1a,  Iter1b, Iter1, Result1;

   // Constructing vectors v1a &amp; v1b with default less-than ordering
   int i;
   for ( i = -1 ; i &lt;= 4 ; i++ )
   {
      v1a.push_back(  i );
   }

   int ii;
   for ( ii =-3 ; ii &lt;= 0 ; ii++ )
   {
      v1b.push_back(  ii  );
   }

   cout &lt;&lt; &quot;Original vector v1a with range sorted by the\n &quot;
        &lt;&lt;  &quot;binary predicate less than is  v1a = ( &quot; ;
   for ( Iter1a = v1a.begin( ) ; Iter1a != v1a.end( ) ; Iter1a++ )
      cout &lt;&lt; *Iter1a &lt;&lt; &quot; &quot;;
   cout &lt;&lt; &quot;).&quot; &lt;&lt; endl;

   cout &lt;&lt; &quot;Original vector v1b with range sorted by the\n &quot;
        &lt;&lt;  &quot;binary predicate less than is  v1b = ( &quot; ;
   for ( Iter1b = v1b.begin( ) ; Iter1b != v1b.end( ) ; Iter1b++ )
      cout &lt;&lt; *Iter1b &lt;&lt; &quot; &quot;;
   cout &lt;&lt; &quot;).&quot; &lt;&lt; endl;

   // Constructing vectors v2a &amp; v2b with ranges sorted by greater
   vector &lt;int&gt; v2a ( v1a ) , v2b ( v1b ) ,  v2 ( v1 );
   vector &lt;int&gt;::iterator Iter2a, Iter2b, Iter2, Result2;
   sort ( v2a.begin( ), v2a.end( ), greater&lt;int&gt;( ) );
   sort ( v2b.begin( ), v2b.end( ), greater&lt;int&gt;( ) );

   cout &lt;&lt; &quot;Original vector v2a with range sorted by the\n &quot;
        &lt;&lt;  &quot;binary predicate greater is   v2a =  ( &quot; ;
   for ( Iter2a = v2a.begin( ) ; Iter2a != v2a.end( ) ; Iter2a++ )
      cout &lt;&lt; *Iter2a &lt;&lt; &quot; &quot;;
   cout &lt;&lt; &quot;).&quot; &lt;&lt; endl;

   cout &lt;&lt; &quot;Original vector v2b with range sorted by the\n &quot;
        &lt;&lt;  &quot;binary predicate greater is   v2b =  ( &quot; ;
   for ( Iter2b = v2b.begin( ) ; Iter2b != v2b.end( ) ; Iter2b++ )
      cout &lt;&lt; *Iter2b &lt;&lt; &quot; &quot;;
   cout &lt;&lt; &quot;).&quot; &lt;&lt; endl;

   // Constructing vectors v3a &amp; v3b with ranges sorted by mod_lesser
   vector &lt;int&gt; v3a ( v1a ), v3b ( v1b ) ,  v3 ( v1 );
   vector &lt;int&gt;::iterator Iter3a, Iter3b, Iter3, Result3;
   sort ( v3a.begin( ), v3a.end( ), mod_lesser );
   sort ( v3b.begin( ), v3b.end( ), mod_lesser  );

   cout &lt;&lt; &quot;Original vector v3a with range sorted by the\n &quot;
        &lt;&lt;  &quot;binary predicate mod_lesser is   v3a =  ( &quot; ;
   for ( Iter3a = v3a.begin( ) ; Iter3a != v3a.end( ) ; Iter3a++ )
      cout &lt;&lt; *Iter3a &lt;&lt; &quot; &quot;;
   cout &lt;&lt; &quot;).&quot; &lt;&lt; endl;

   cout &lt;&lt; &quot;Original vector v3b with range sorted by the\n &quot;
        &lt;&lt;  &quot;binary predicate mod_lesser is   v3b =  ( &quot; ;
   for ( Iter3b = v3b.begin( ) ; Iter3b != v3b.end( ) ; Iter3b++ )
      cout &lt;&lt; *Iter3b &lt;&lt; &quot; &quot;;
   cout &lt;&lt; &quot;).&quot; &lt;&lt; endl;

   // To combine into a symmetric difference in ascending
   // order with the default binary predicate less &lt;int&gt;( )
   Result1 = set_symmetric_difference ( v1a.begin( ), v1a.end( ),
      v1b.begin( ), v1b.end( ), v1.begin( ) );
   cout &lt;&lt; &quot;Set_symmetric_difference of source ranges with default order,&quot;
        &lt;&lt; &quot;\n vector v1mod =  ( &quot; ;
   for ( Iter1 = v1.begin( ) ; Iter1 != Result1 ; Iter1++ )
      cout &lt;&lt; *Iter1 &lt;&lt; &quot; &quot;;
   cout &lt;&lt; &quot;).&quot; &lt;&lt; endl;

   // To combine into a symmetric difference in descending
   // order, specify binary predicate greater&lt;int&gt;( )
   Result2 = set_symmetric_difference ( v2a.begin( ), v2a.end( ),
      v2b.begin( ), v2b.end( ),v2.begin( ), greater &lt;int&gt;( ) );
   cout &lt;&lt; &quot;Set_symmetric_difference of source ranges with binary&quot;
        &lt;&lt; &quot;predicate greater specified,\n vector v2mod  = ( &quot; ;
   for ( Iter2 = v2.begin( ) ; Iter2 != Result2 ; Iter2++ )
      cout &lt;&lt; *Iter2 &lt;&lt; &quot; &quot;;
   cout &lt;&lt; &quot;).&quot; &lt;&lt; endl;

   // To combine into a symmetric difference applying a user
   // defined binary predicate mod_lesser
   Result3 = set_symmetric_difference ( v3a.begin( ), v3a.end( ),
      v3b.begin( ), v3b.end( ), v3.begin( ), mod_lesser );
   cout &lt;&lt; &quot;Set_symmetric_difference of source ranges with binary &quot;
        &lt;&lt; &quot;predicate mod_lesser specified,\n vector v3mod  = ( &quot; ; ;
   for ( Iter3 = v3.begin( ) ; Iter3 != Result3 ; Iter3++ )
      cout &lt;&lt; *Iter3 &lt;&lt; &quot; &quot;;
   cout &lt;&lt; &quot;).&quot; &lt;&lt; endl;
}
"><span class="hljs-comment">// alg_set_sym_diff.cpp</span>
<span class="hljs-comment">// compile with: /EHsc</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;functional&gt;      // For greater&lt;int&gt;( )</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span>

<span class="hljs-comment">// Return whether modulus of elem1 is less than modulus of elem2</span>
<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">mod_lesser</span> <span class="hljs-params">(<span class="hljs-keyword">int</span> elem1, <span class="hljs-keyword">int</span> elem2 )</span>
</span>{
   <span class="hljs-keyword">if</span> ( elem1 &lt; <span class="hljs-number">0</span> )
      elem1 = - elem1;
   <span class="hljs-keyword">if</span> ( elem2 &lt; <span class="hljs-number">0</span> )
      elem2 = - elem2;
   <span class="hljs-keyword">return</span> elem1 &lt; elem2;
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
   <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;
   <span class="hljs-built_in">vector</span> &lt;<span class="hljs-keyword">int</span>&gt; v1a, v1b, v1 ( <span class="hljs-number">12</span> );
   <span class="hljs-built_in">vector</span> &lt;<span class="hljs-keyword">int</span>&gt;::iterator Iter1a,  Iter1b, Iter1, Result1;

   <span class="hljs-comment">// Constructing vectors v1a &amp; v1b with default less-than ordering</span>
   <span class="hljs-keyword">int</span> i;
   <span class="hljs-keyword">for</span> ( i = <span class="hljs-number">-1</span> ; i &lt;= <span class="hljs-number">4</span> ; i++ )
   {
      v1a.push_back(  i );
   }

   <span class="hljs-keyword">int</span> ii;
   <span class="hljs-keyword">for</span> ( ii =<span class="hljs-number">-3</span> ; ii &lt;= <span class="hljs-number">0</span> ; ii++ )
   {
      v1b.push_back(  ii  );
   }

   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Original vector v1a with range sorted by the\n "</span>
        &lt;&lt;  <span class="hljs-string">"binary predicate less than is  v1a = ( "</span> ;
   <span class="hljs-keyword">for</span> ( Iter1a = v1a.begin( ) ; Iter1a != v1a.end( ) ; Iter1a++ )
      <span class="hljs-built_in">cout</span> &lt;&lt; *Iter1a &lt;&lt; <span class="hljs-string">" "</span>;
   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">")."</span> &lt;&lt; <span class="hljs-built_in">endl</span>;

   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Original vector v1b with range sorted by the\n "</span>
        &lt;&lt;  <span class="hljs-string">"binary predicate less than is  v1b = ( "</span> ;
   <span class="hljs-keyword">for</span> ( Iter1b = v1b.begin( ) ; Iter1b != v1b.end( ) ; Iter1b++ )
      <span class="hljs-built_in">cout</span> &lt;&lt; *Iter1b &lt;&lt; <span class="hljs-string">" "</span>;
   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">")."</span> &lt;&lt; <span class="hljs-built_in">endl</span>;

   <span class="hljs-comment">// Constructing vectors v2a &amp; v2b with ranges sorted by greater</span>
   <span class="hljs-built_in">vector</span> &lt;<span class="hljs-keyword">int</span>&gt; v2a ( v1a ) , v2b ( v1b ) ,  v2 ( v1 );
   <span class="hljs-built_in">vector</span> &lt;<span class="hljs-keyword">int</span>&gt;::iterator Iter2a, Iter2b, Iter2, Result2;
   sort ( v2a.begin( ), v2a.end( ), greater&lt;<span class="hljs-keyword">int</span>&gt;( ) );
   sort ( v2b.begin( ), v2b.end( ), greater&lt;<span class="hljs-keyword">int</span>&gt;( ) );

   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Original vector v2a with range sorted by the\n "</span>
        &lt;&lt;  <span class="hljs-string">"binary predicate greater is   v2a =  ( "</span> ;
   <span class="hljs-keyword">for</span> ( Iter2a = v2a.begin( ) ; Iter2a != v2a.end( ) ; Iter2a++ )
      <span class="hljs-built_in">cout</span> &lt;&lt; *Iter2a &lt;&lt; <span class="hljs-string">" "</span>;
   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">")."</span> &lt;&lt; <span class="hljs-built_in">endl</span>;

   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Original vector v2b with range sorted by the\n "</span>
        &lt;&lt;  <span class="hljs-string">"binary predicate greater is   v2b =  ( "</span> ;
   <span class="hljs-keyword">for</span> ( Iter2b = v2b.begin( ) ; Iter2b != v2b.end( ) ; Iter2b++ )
      <span class="hljs-built_in">cout</span> &lt;&lt; *Iter2b &lt;&lt; <span class="hljs-string">" "</span>;
   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">")."</span> &lt;&lt; <span class="hljs-built_in">endl</span>;

   <span class="hljs-comment">// Constructing vectors v3a &amp; v3b with ranges sorted by mod_lesser</span>
   <span class="hljs-built_in">vector</span> &lt;<span class="hljs-keyword">int</span>&gt; v3a ( v1a ), v3b ( v1b ) ,  v3 ( v1 );
   <span class="hljs-built_in">vector</span> &lt;<span class="hljs-keyword">int</span>&gt;::iterator Iter3a, Iter3b, Iter3, Result3;
   sort ( v3a.begin( ), v3a.end( ), mod_lesser );
   sort ( v3b.begin( ), v3b.end( ), mod_lesser  );

   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Original vector v3a with range sorted by the\n "</span>
        &lt;&lt;  <span class="hljs-string">"binary predicate mod_lesser is   v3a =  ( "</span> ;
   <span class="hljs-keyword">for</span> ( Iter3a = v3a.begin( ) ; Iter3a != v3a.end( ) ; Iter3a++ )
      <span class="hljs-built_in">cout</span> &lt;&lt; *Iter3a &lt;&lt; <span class="hljs-string">" "</span>;
   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">")."</span> &lt;&lt; <span class="hljs-built_in">endl</span>;

   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Original vector v3b with range sorted by the\n "</span>
        &lt;&lt;  <span class="hljs-string">"binary predicate mod_lesser is   v3b =  ( "</span> ;
   <span class="hljs-keyword">for</span> ( Iter3b = v3b.begin( ) ; Iter3b != v3b.end( ) ; Iter3b++ )
      <span class="hljs-built_in">cout</span> &lt;&lt; *Iter3b &lt;&lt; <span class="hljs-string">" "</span>;
   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">")."</span> &lt;&lt; <span class="hljs-built_in">endl</span>;

   <span class="hljs-comment">// To combine into a symmetric difference in ascending</span>
   <span class="hljs-comment">// order with the default binary predicate less &lt;int&gt;( )</span>
   Result1 = set_symmetric_difference ( v1a.begin( ), v1a.end( ),
      v1b.begin( ), v1b.end( ), v1.begin( ) );
   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Set_symmetric_difference of source ranges with default order,"</span>
        &lt;&lt; <span class="hljs-string">"\n vector v1mod =  ( "</span> ;
   <span class="hljs-keyword">for</span> ( Iter1 = v1.begin( ) ; Iter1 != Result1 ; Iter1++ )
      <span class="hljs-built_in">cout</span> &lt;&lt; *Iter1 &lt;&lt; <span class="hljs-string">" "</span>;
   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">")."</span> &lt;&lt; <span class="hljs-built_in">endl</span>;

   <span class="hljs-comment">// To combine into a symmetric difference in descending</span>
   <span class="hljs-comment">// order, specify binary predicate greater&lt;int&gt;( )</span>
   Result2 = set_symmetric_difference ( v2a.begin( ), v2a.end( ),
      v2b.begin( ), v2b.end( ),v2.begin( ), greater &lt;<span class="hljs-keyword">int</span>&gt;( ) );
   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Set_symmetric_difference of source ranges with binary"</span>
        &lt;&lt; <span class="hljs-string">"predicate greater specified,\n vector v2mod  = ( "</span> ;
   <span class="hljs-keyword">for</span> ( Iter2 = v2.begin( ) ; Iter2 != Result2 ; Iter2++ )
      <span class="hljs-built_in">cout</span> &lt;&lt; *Iter2 &lt;&lt; <span class="hljs-string">" "</span>;
   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">")."</span> &lt;&lt; <span class="hljs-built_in">endl</span>;

   <span class="hljs-comment">// To combine into a symmetric difference applying a user</span>
   <span class="hljs-comment">// defined binary predicate mod_lesser</span>
   Result3 = set_symmetric_difference ( v3a.begin( ), v3a.end( ),
      v3b.begin( ), v3b.end( ), v3.begin( ), mod_lesser );
   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Set_symmetric_difference of source ranges with binary "</span>
        &lt;&lt; <span class="hljs-string">"predicate mod_lesser specified,\n vector v3mod  = ( "</span> ; ;
   <span class="hljs-keyword">for</span> ( Iter3 = v3.begin( ) ; Iter3 != Result3 ; Iter3++ )
      <span class="hljs-built_in">cout</span> &lt;&lt; *Iter3 &lt;&lt; <span class="hljs-string">" "</span>;
   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">")."</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
}
</code></pre>
<h2 id="set_union" class="heading-with-anchor">  set_union<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#set_union"></a></h2>
<p>Unites all of the elements that belong to at least one of two sorted source ranges into a single, sorted destination range, where the ordering criterion may be specified by a binary predicate.</p>
<div class="codeHeader" id="code-try-149" data-bi-name="code-header"><span class="language">C++</span>
			<button class="action" data-bi-name="copy">
				<span class="docon docon-edit-copy" role="presentation"></span>
				<span>Copy</span>
			</button></div><pre><code class="lang-cpp" data-author-content="template&lt;class InputIterator1, class InputIterator2, class OutputIterator&gt;
OutputIterator set_union(
    InputIterator1 first1,
    InputIterator1 last1,
    InputIterator2 first2,
    InputIterator2 last2,
    OutputIterator result );

template&lt;class InputIterator1, class InputIterator2, class OutputIterator, class BinaryPredicate&gt;
OutputIterator set_union(
    InputIterator1 first1,
    InputIterator1 last1,
    InputIterator2 first2,
    InputIterator2 last2,
    OutputIterator result,
    BinaryPredicate comp );
"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InputIterator1</span>, <span class="hljs-title">class</span> <span class="hljs-title">InputIterator2</span>, <span class="hljs-title">class</span> <span class="hljs-title">OutputIterator</span>&gt;
<span class="hljs-title">OutputIterator</span> <span class="hljs-title">set_union</span>(
    <span class="hljs-title">InputIterator1</span> <span class="hljs-title">first1</span>,
    <span class="hljs-title">InputIterator1</span> <span class="hljs-title">last1</span>,
    <span class="hljs-title">InputIterator2</span> <span class="hljs-title">first2</span>,
    <span class="hljs-title">InputIterator2</span> <span class="hljs-title">last2</span>,
    <span class="hljs-title">OutputIterator</span> <span class="hljs-title">result</span> );</span>

<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InputIterator1</span>, <span class="hljs-title">class</span> <span class="hljs-title">InputIterator2</span>, <span class="hljs-title">class</span> <span class="hljs-title">OutputIterator</span>, <span class="hljs-title">class</span> <span class="hljs-title">BinaryPredicate</span>&gt;
<span class="hljs-title">OutputIterator</span> <span class="hljs-title">set_union</span>(
    <span class="hljs-title">InputIterator1</span> <span class="hljs-title">first1</span>,
    <span class="hljs-title">InputIterator1</span> <span class="hljs-title">last1</span>,
    <span class="hljs-title">InputIterator2</span> <span class="hljs-title">first2</span>,
    <span class="hljs-title">InputIterator2</span> <span class="hljs-title">last2</span>,
    <span class="hljs-title">OutputIterator</span> <span class="hljs-title">result</span>,
    <span class="hljs-title">BinaryPredicate</span> <span class="hljs-title">comp</span> );</span>
</code></pre>
<h3 id="parameters-72" class="heading-with-anchor">Parameters<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#parameters-72"></a></h3>
<p><em>first1</em><br>
An input iterator addressing the position of the first element in the first of two sorted source ranges to be united and sorted into a single range representing the union of the two source ranges.</p>
<p><em>last1</em><br>
An input iterator addressing the position one past the last element in the first of two sorted source ranges to be united and sorted into a single range representing the union of the two source ranges.</p>
<p><em>first2</em><br>
An input iterator addressing the position of the first element in second of two consecutive sorted source ranges to be united and sorted into a single range representing the union of the two source ranges.</p>
<p><em>last2</em><br>
An input iterator addressing the position one past the last element in second of two consecutive sorted source ranges to be united and sorted into a single range representing the union of the two source ranges.</p>
<p><strong>_</strong> <em>Result</em>
An output iterator addressing the position of the first element in the destination range where the two source ranges are to be united into a single sorted range representing the union of the two source ranges.</p>
<p><em>comp</em><br>
User-defined predicate function object that defines the sense in which one element is greater than another. The binary predicate takes two arguments and should return <strong>true</strong> when the first element is less than the second element and <strong>false</strong> otherwise.</p>
<h3 id="return-value-53" class="heading-with-anchor">Return Value<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#return-value-53"></a></h3>
<p>An output iterator addressing the position one past the last element in the sorted destination range representing the union of the two source ranges.</p>
<h3 id="remarks-72" class="heading-with-anchor">Remarks<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#remarks-72"></a></h3>
<p>The sorted source ranges referenced must be valid; all pointers must be dereferenceable and within each sequence the last position must be reachable from the first by incrementation.</p>
<p>The destination range should not overlap either of the source ranges and should be large enough to contain the destination range.</p>
<p>The sorted source ranges must each be arranged as a precondition to the application of the <code>merge</code> algorithm in accordance with the same ordering as is to be used by the algorithm to sort the combined ranges.</p>
<p>The operation is stable as the relative order of elements within each range is preserved in the destination range. The source ranges are not modified by the algorithm <code>merge</code>.</p>
<p>The value types of the input iterators need be less-than comparable to be ordered, so that, given two elements, it may be determined either that they are equivalent (in the sense that neither is less than the other) or that one is less than the other. This results in an ordering between the nonequivalent elements. When there are equivalent elements in both source ranges, the elements in the first range precede the elements from the second source range in the destination range. If the source ranges contain duplicates of an element, then the destination range will contain the maximum number of those elements that occur in both source ranges.</p>
<p>The complexity of the algorithm is linear with at most 2 * ( ( <em>last1 - first1</em>) - ( <em>last2 - first2</em>) ) - 1 comparisons.</p>
<h3 id="example-54" class="heading-with-anchor">Example<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#example-54"></a></h3>
<div class="codeHeader" id="code-try-150" data-bi-name="code-header"><span class="language">C++</span>
			<button class="action" data-bi-name="copy">
				<span class="docon docon-edit-copy" role="presentation"></span>
				<span>Copy</span>
			</button></div><pre><code class="lang-cpp" data-author-content="// alg_set_union.cpp
// compile with: /EHsc
#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;functional&gt;      // For greater&lt;int&gt;( )
#include &lt;iostream&gt;

// Return whether modulus of elem1 is less than modulus of elem2
bool mod_lesser ( int elem1, int elem2 )
{
   if ( elem1 &lt; 0 )
      elem1 = - elem1;
   if ( elem2 &lt; 0 )
      elem2 = - elem2;
   return elem1 &lt; elem2;
}

int main()
{
   using namespace std;
   vector &lt;int&gt; v1a, v1b, v1 ( 12 );
   vector &lt;int&gt;::iterator Iter1a, Iter1b, Iter1, Result1;

   // Constructing vectors v1a &amp; v1b with default less than ordering
   int i;
   for ( i = -1 ; i &lt;= 3 ; i++ )
   {
      v1a.push_back(  i );
   }

   int ii;
   for ( ii =-3 ; ii &lt;= 1 ; ii++ )
   {
      v1b.push_back(  ii  );
   }

   cout &lt;&lt; &quot;Original vector v1a with range sorted by the\n &quot;
        &lt;&lt;  &quot;binary predicate less than is  v1a = ( &quot; ;
   for ( Iter1a = v1a.begin( ) ; Iter1a != v1a.end( ) ; Iter1a++ )
      cout &lt;&lt; *Iter1a &lt;&lt; &quot; &quot;;
   cout &lt;&lt; &quot;).&quot; &lt;&lt; endl;

   cout &lt;&lt; &quot;Original vector v1b with range sorted by the\n &quot;
        &lt;&lt;  &quot;binary predicate less than is  v1b = ( &quot; ;
   for ( Iter1b = v1b.begin( ) ; Iter1b != v1b.end( ) ; Iter1b++ )
      cout &lt;&lt; *Iter1b &lt;&lt; &quot; &quot;;
   cout &lt;&lt; &quot;).&quot; &lt;&lt; endl;

   // Constructing vectors v2a &amp; v2b with ranges sorted by greater
   vector &lt;int&gt; v2a ( v1a ) , v2b ( v1b ) , v2 ( v1 );
   vector &lt;int&gt;::iterator Iter2a,  Iter2b, Iter2, Result2;
   sort ( v2a.begin( ), v2a.end( ), greater&lt;int&gt;( ) );
   sort ( v2b.begin( ), v2b.end( ), greater&lt;int&gt;( ) );

   cout &lt;&lt; &quot;Original vector v2a with range sorted by the\n &quot;
        &lt;&lt;  &quot;binary predicate greater is   v2a =  ( &quot; ;
   for ( Iter2a = v2a.begin( ) ; Iter2a != v2a.end( ) ; Iter2a++ )
      cout &lt;&lt; *Iter2a &lt;&lt; &quot; &quot;;
   cout &lt;&lt; &quot;).&quot; &lt;&lt; endl;

   cout &lt;&lt; &quot;Original vector v2b with range sorted by the\n &quot;
        &lt;&lt;  &quot;binary predicate greater is   v2b =  ( &quot; ;
   for ( Iter2b = v2b.begin( ) ; Iter2b != v2b.end( ) ; Iter2b++ )
      cout &lt;&lt; *Iter2b &lt;&lt; &quot; &quot;;
   cout &lt;&lt; &quot;).&quot; &lt;&lt; endl;

   // Constructing vectors v3a &amp; v3b with ranges sorted by mod_lesser
   vector &lt;int&gt; v3a ( v1a ), v3b ( v1b ) ,  v3 ( v1 );
   vector &lt;int&gt;::iterator Iter3a, Iter3b, Iter3, Result3;
   sort ( v3a.begin( ), v3a.end( ), mod_lesser );
   sort ( v3b.begin( ), v3b.end( ), mod_lesser  );

   cout &lt;&lt; &quot;Original vector v3a with range sorted by the\n &quot;
        &lt;&lt;  &quot;binary predicate mod_lesser is   v3a =  ( &quot; ;
   for ( Iter3a = v3a.begin( ) ; Iter3a != v3a.end( ) ; Iter3a++ )
      cout &lt;&lt; *Iter3a &lt;&lt; &quot; &quot;;
   cout &lt;&lt; &quot;).&quot; &lt;&lt; endl;

   cout &lt;&lt; &quot;Original vector v3b with range sorted by the\n &quot;
        &lt;&lt;  &quot;binary predicate mod_lesser is   v3b =  ( &quot; ;
   for ( Iter3b = v3b.begin( ) ; Iter3b != v3b.end( ) ; Iter3b++ )
      cout &lt;&lt; *Iter3b &lt;&lt; &quot; &quot;;
   cout &lt;&lt; &quot;).&quot; &lt;&lt; endl;

   // To combine into a union in ascending order with the default
    // binary predicate less &lt;int&gt;( )
   Result1 = set_union ( v1a.begin( ), v1a.end( ),
      v1b.begin( ), v1b.end( ), v1.begin( ) );
   cout &lt;&lt; &quot;Union of source ranges with default order,&quot;
        &lt;&lt; &quot;\n vector v1mod =  ( &quot; ;
   for ( Iter1 = v1.begin( ) ; Iter1 != Result1 ; Iter1++ )
      cout &lt;&lt; *Iter1 &lt;&lt; &quot; &quot;;
   cout &lt;&lt; &quot;).&quot; &lt;&lt; endl;

   // To combine into a union in descending order, specify binary
   // predicate greater&lt;int&gt;( )
   Result2 = set_union (  v2a.begin( ), v2a.end( ),
      v2b.begin( ), v2b.end( ),v2.begin( ), greater &lt;int&gt;( ) );
   cout &lt;&lt; &quot;Union of source ranges with binary predicate greater &quot;
        &lt;&lt; &quot;specified,\n vector v2mod  = ( &quot; ;
   for ( Iter2 = v2.begin( ) ; Iter2 != Result2 ; Iter2++ )
      cout &lt;&lt; *Iter2 &lt;&lt; &quot; &quot;;
   cout &lt;&lt; &quot;).&quot; &lt;&lt; endl;

   // To combine into a union applying a user-defined
   // binary predicate mod_lesser
   Result3 = set_union ( v3a.begin( ), v3a.end( ),
      v3b.begin( ), v3b.end( ), v3.begin( ), mod_lesser );
   cout &lt;&lt; &quot;Union of source ranges with binary predicate &quot;
        &lt;&lt; &quot;mod_lesser specified,\n vector v3mod  = ( &quot; ; ;
   for ( Iter3 = v3.begin( ) ; Iter3 != Result3 ; Iter3++ )
      cout &lt;&lt; *Iter3 &lt;&lt; &quot; &quot;;
   cout &lt;&lt; &quot;).&quot; &lt;&lt; endl;
}
"><span class="hljs-comment">// alg_set_union.cpp</span>
<span class="hljs-comment">// compile with: /EHsc</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;functional&gt;      // For greater&lt;int&gt;( )</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span>

<span class="hljs-comment">// Return whether modulus of elem1 is less than modulus of elem2</span>
<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">mod_lesser</span> <span class="hljs-params">( <span class="hljs-keyword">int</span> elem1, <span class="hljs-keyword">int</span> elem2 )</span>
</span>{
   <span class="hljs-keyword">if</span> ( elem1 &lt; <span class="hljs-number">0</span> )
      elem1 = - elem1;
   <span class="hljs-keyword">if</span> ( elem2 &lt; <span class="hljs-number">0</span> )
      elem2 = - elem2;
   <span class="hljs-keyword">return</span> elem1 &lt; elem2;
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
   <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;
   <span class="hljs-built_in">vector</span> &lt;<span class="hljs-keyword">int</span>&gt; v1a, v1b, v1 ( <span class="hljs-number">12</span> );
   <span class="hljs-built_in">vector</span> &lt;<span class="hljs-keyword">int</span>&gt;::iterator Iter1a, Iter1b, Iter1, Result1;

   <span class="hljs-comment">// Constructing vectors v1a &amp; v1b with default less than ordering</span>
   <span class="hljs-keyword">int</span> i;
   <span class="hljs-keyword">for</span> ( i = <span class="hljs-number">-1</span> ; i &lt;= <span class="hljs-number">3</span> ; i++ )
   {
      v1a.push_back(  i );
   }

   <span class="hljs-keyword">int</span> ii;
   <span class="hljs-keyword">for</span> ( ii =<span class="hljs-number">-3</span> ; ii &lt;= <span class="hljs-number">1</span> ; ii++ )
   {
      v1b.push_back(  ii  );
   }

   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Original vector v1a with range sorted by the\n "</span>
        &lt;&lt;  <span class="hljs-string">"binary predicate less than is  v1a = ( "</span> ;
   <span class="hljs-keyword">for</span> ( Iter1a = v1a.begin( ) ; Iter1a != v1a.end( ) ; Iter1a++ )
      <span class="hljs-built_in">cout</span> &lt;&lt; *Iter1a &lt;&lt; <span class="hljs-string">" "</span>;
   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">")."</span> &lt;&lt; <span class="hljs-built_in">endl</span>;

   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Original vector v1b with range sorted by the\n "</span>
        &lt;&lt;  <span class="hljs-string">"binary predicate less than is  v1b = ( "</span> ;
   <span class="hljs-keyword">for</span> ( Iter1b = v1b.begin( ) ; Iter1b != v1b.end( ) ; Iter1b++ )
      <span class="hljs-built_in">cout</span> &lt;&lt; *Iter1b &lt;&lt; <span class="hljs-string">" "</span>;
   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">")."</span> &lt;&lt; <span class="hljs-built_in">endl</span>;

   <span class="hljs-comment">// Constructing vectors v2a &amp; v2b with ranges sorted by greater</span>
   <span class="hljs-built_in">vector</span> &lt;<span class="hljs-keyword">int</span>&gt; v2a ( v1a ) , v2b ( v1b ) , v2 ( v1 );
   <span class="hljs-built_in">vector</span> &lt;<span class="hljs-keyword">int</span>&gt;::iterator Iter2a,  Iter2b, Iter2, Result2;
   sort ( v2a.begin( ), v2a.end( ), greater&lt;<span class="hljs-keyword">int</span>&gt;( ) );
   sort ( v2b.begin( ), v2b.end( ), greater&lt;<span class="hljs-keyword">int</span>&gt;( ) );

   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Original vector v2a with range sorted by the\n "</span>
        &lt;&lt;  <span class="hljs-string">"binary predicate greater is   v2a =  ( "</span> ;
   <span class="hljs-keyword">for</span> ( Iter2a = v2a.begin( ) ; Iter2a != v2a.end( ) ; Iter2a++ )
      <span class="hljs-built_in">cout</span> &lt;&lt; *Iter2a &lt;&lt; <span class="hljs-string">" "</span>;
   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">")."</span> &lt;&lt; <span class="hljs-built_in">endl</span>;

   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Original vector v2b with range sorted by the\n "</span>
        &lt;&lt;  <span class="hljs-string">"binary predicate greater is   v2b =  ( "</span> ;
   <span class="hljs-keyword">for</span> ( Iter2b = v2b.begin( ) ; Iter2b != v2b.end( ) ; Iter2b++ )
      <span class="hljs-built_in">cout</span> &lt;&lt; *Iter2b &lt;&lt; <span class="hljs-string">" "</span>;
   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">")."</span> &lt;&lt; <span class="hljs-built_in">endl</span>;

   <span class="hljs-comment">// Constructing vectors v3a &amp; v3b with ranges sorted by mod_lesser</span>
   <span class="hljs-built_in">vector</span> &lt;<span class="hljs-keyword">int</span>&gt; v3a ( v1a ), v3b ( v1b ) ,  v3 ( v1 );
   <span class="hljs-built_in">vector</span> &lt;<span class="hljs-keyword">int</span>&gt;::iterator Iter3a, Iter3b, Iter3, Result3;
   sort ( v3a.begin( ), v3a.end( ), mod_lesser );
   sort ( v3b.begin( ), v3b.end( ), mod_lesser  );

   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Original vector v3a with range sorted by the\n "</span>
        &lt;&lt;  <span class="hljs-string">"binary predicate mod_lesser is   v3a =  ( "</span> ;
   <span class="hljs-keyword">for</span> ( Iter3a = v3a.begin( ) ; Iter3a != v3a.end( ) ; Iter3a++ )
      <span class="hljs-built_in">cout</span> &lt;&lt; *Iter3a &lt;&lt; <span class="hljs-string">" "</span>;
   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">")."</span> &lt;&lt; <span class="hljs-built_in">endl</span>;

   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Original vector v3b with range sorted by the\n "</span>
        &lt;&lt;  <span class="hljs-string">"binary predicate mod_lesser is   v3b =  ( "</span> ;
   <span class="hljs-keyword">for</span> ( Iter3b = v3b.begin( ) ; Iter3b != v3b.end( ) ; Iter3b++ )
      <span class="hljs-built_in">cout</span> &lt;&lt; *Iter3b &lt;&lt; <span class="hljs-string">" "</span>;
   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">")."</span> &lt;&lt; <span class="hljs-built_in">endl</span>;

   <span class="hljs-comment">// To combine into a union in ascending order with the default</span>
    <span class="hljs-comment">// binary predicate less &lt;int&gt;( )</span>
   Result1 = set_union ( v1a.begin( ), v1a.end( ),
      v1b.begin( ), v1b.end( ), v1.begin( ) );
   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Union of source ranges with default order,"</span>
        &lt;&lt; <span class="hljs-string">"\n vector v1mod =  ( "</span> ;
   <span class="hljs-keyword">for</span> ( Iter1 = v1.begin( ) ; Iter1 != Result1 ; Iter1++ )
      <span class="hljs-built_in">cout</span> &lt;&lt; *Iter1 &lt;&lt; <span class="hljs-string">" "</span>;
   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">")."</span> &lt;&lt; <span class="hljs-built_in">endl</span>;

   <span class="hljs-comment">// To combine into a union in descending order, specify binary</span>
   <span class="hljs-comment">// predicate greater&lt;int&gt;( )</span>
   Result2 = set_union (  v2a.begin( ), v2a.end( ),
      v2b.begin( ), v2b.end( ),v2.begin( ), greater &lt;<span class="hljs-keyword">int</span>&gt;( ) );
   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Union of source ranges with binary predicate greater "</span>
        &lt;&lt; <span class="hljs-string">"specified,\n vector v2mod  = ( "</span> ;
   <span class="hljs-keyword">for</span> ( Iter2 = v2.begin( ) ; Iter2 != Result2 ; Iter2++ )
      <span class="hljs-built_in">cout</span> &lt;&lt; *Iter2 &lt;&lt; <span class="hljs-string">" "</span>;
   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">")."</span> &lt;&lt; <span class="hljs-built_in">endl</span>;

   <span class="hljs-comment">// To combine into a union applying a user-defined</span>
   <span class="hljs-comment">// binary predicate mod_lesser</span>
   Result3 = set_union ( v3a.begin( ), v3a.end( ),
      v3b.begin( ), v3b.end( ), v3.begin( ), mod_lesser );
   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Union of source ranges with binary predicate "</span>
        &lt;&lt; <span class="hljs-string">"mod_lesser specified,\n vector v3mod  = ( "</span> ; ;
   <span class="hljs-keyword">for</span> ( Iter3 = v3.begin( ) ; Iter3 != Result3 ; Iter3++ )
      <span class="hljs-built_in">cout</span> &lt;&lt; *Iter3 &lt;&lt; <span class="hljs-string">" "</span>;
   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">")."</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
}
</code></pre>
<h2 id="shuffle" class="heading-with-anchor">  shuffle<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#shuffle"></a></h2>
<p>Shuffles (rearranges) elements for a given range by using a random number generator.</p>
<div class="codeHeader" id="code-try-151" data-bi-name="code-header"><span class="language">C++</span>
			<button class="action" data-bi-name="copy">
				<span class="docon docon-edit-copy" role="presentation"></span>
				<span>Copy</span>
			</button></div><pre><code class="lang-cpp" data-author-content="template&lt;class RandomAccessIterator, class UniformRandomNumberGenerator&gt;
void shuffle(RandomAccessIterator first,
    RandomAccessIterator last,
    UniformRandomNumberGenerator&amp;&amp; gen);
"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RandomAccessIterator</span>, <span class="hljs-title">class</span> <span class="hljs-title">UniformRandomNumberGenerator</span>&gt;
<span class="hljs-title">void</span> <span class="hljs-title">shuffle</span>(<span class="hljs-title">RandomAccessIterator</span> <span class="hljs-title">first</span>,
    <span class="hljs-title">RandomAccessIterator</span> <span class="hljs-title">last</span>,
    <span class="hljs-title">UniformRandomNumberGenerator</span>&amp;&amp; <span class="hljs-title">gen</span>);</span>
</code></pre>
<h3 id="parameters-73" class="heading-with-anchor">Parameters<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#parameters-73"></a></h3>
<p><em>first</em><br>
An iterator to the first element in the range to be shuffled, inclusive. Must meet the requirements of <code>RandomAccessIterator</code> and <code>ValueSwappable</code>.</p>
<p><em>last</em><br>
An iterator to the last element in the range to be shuffled, exclusive. Must meet the requirements of <code>RandomAccessIterator</code> and <code>ValueSwappable</code>.</p>
<p><em>gen</em><br>
The random number generator that the <code>shuffle()</code> function will use for the operation. Must meet the requirements of a <code>UniformRandomNumberGenerator</code>.</p>
<h3 id="remarks-73" class="heading-with-anchor">Remarks<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#remarks-73"></a></h3>
<p>For more information, and a code sample that uses <code>shuffle()</code>, see <a href="https://docs.microsoft.com/en-us/cpp/standard-library/random?view=vs-2019" data-linktype="relative-path">&lt;random&gt;</a>.</p>
<h2 id="sort" class="heading-with-anchor">  sort<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#sort"></a></h2>
<p>Arranges the elements in a specified range into a nondescending order or according to an ordering criterion specified by a binary predicate.</p>
<div class="codeHeader" id="code-try-152" data-bi-name="code-header"><span class="language">C++</span>
			<button class="action" data-bi-name="copy">
				<span class="docon docon-edit-copy" role="presentation"></span>
				<span>Copy</span>
			</button></div><pre><code class="lang-cpp" data-author-content="template&lt;class RandomAccessIterator&gt;
   void sort(
      RandomAccessIterator first,
      RandomAccessIterator last);

template&lt;class RandomAccessIterator, class Predicate&gt;
   void sort(
      RandomAccessIterator first,
      RandomAccessIterator last,
      Predicate comp);
"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RandomAccessIterator</span>&gt;
   <span class="hljs-title">void</span> <span class="hljs-title">sort</span>(
      <span class="hljs-title">RandomAccessIterator</span> <span class="hljs-title">first</span>,
      <span class="hljs-title">RandomAccessIterator</span> <span class="hljs-title">last</span>);</span>

<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RandomAccessIterator</span>, <span class="hljs-title">class</span> <span class="hljs-title">Predicate</span>&gt;
   <span class="hljs-title">void</span> <span class="hljs-title">sort</span>(
      <span class="hljs-title">RandomAccessIterator</span> <span class="hljs-title">first</span>,
      <span class="hljs-title">RandomAccessIterator</span> <span class="hljs-title">last</span>,
      <span class="hljs-title">Predicate</span> <span class="hljs-title">comp</span>);</span>
</code></pre>
<h3 id="parameters-74" class="heading-with-anchor">Parameters<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#parameters-74"></a></h3>
<p><em>first</em><br>
A random-access iterator addressing the position of the first element in the range to be sorted.</p>
<p><em>last</em><br>
A random-access iterator addressing the position one past the final element in the range to be sorted.</p>
<p><em>comp</em><br>
User-defined predicate function object that defines the comparison criterion to be satisfied by successive elements in the ordering. This binary predicate takes two arguments and returns <strong>true</strong> if the two arguments are in order and <strong>false</strong> otherwise. This comparator function must impose a strict weak ordering on pairs of elements from the sequence. For more information, see <a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithms?view=vs-2019" data-linktype="relative-path">Algorithms</a>.</p>
<h3 id="remarks-74" class="heading-with-anchor">Remarks<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#remarks-74"></a></h3>
<p>The range referenced must be valid; all pointers must be dereferenceable and within the sequence the last position is reachable from the first by incrementation.</p>
<p>Elements are equivalent, but not necessarily equal, if neither is less than the other. The <code>sort</code> algorithm is not stable and so does not guarantee that the relative ordering of equivalent elements will be preserved. The algorithm <code>stable_sort</code> does preserve this original ordering.</p>
<p>The average of a sort complexity is  <em>O</em>( <em>N</em> log  <em>N</em>), where  <em>N</em> =  <em>last - first</em>.</p>
<h3 id="example-55" class="heading-with-anchor">Example<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#example-55"></a></h3>
<div class="codeHeader" id="code-try-153" data-bi-name="code-header"><span class="language">C++</span>
			<button class="action" data-bi-name="copy">
				<span class="docon docon-edit-copy" role="presentation"></span>
				<span>Copy</span>
			</button></div><pre><code class="lang-cpp" data-author-content="// alg_sort.cpp
// compile with: /EHsc
#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;functional&gt;      // For greater&lt;int&gt;( )
#include &lt;iostream&gt;

// Return whether first element is greater than the second
bool UDgreater ( int elem1, int elem2 )
{
   return elem1 &gt; elem2;
}

int main()
{
   using namespace std;
   vector &lt;int&gt; v1;
   vector &lt;int&gt;::iterator Iter1;

   int i;
   for ( i = 0 ; i &lt;= 5 ; i++ )
   {
      v1.push_back( 2 * i );
   }

   int ii;
   for ( ii = 0 ; ii &lt;= 5 ; ii++ )
   {
      v1.push_back( 2 * ii + 1 );
   }

   cout &lt;&lt; &quot;Original vector v1 = ( &quot; ;
   for ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ; Iter1++ )
      cout &lt;&lt; *Iter1 &lt;&lt; &quot; &quot;;
   cout &lt;&lt; &quot;)&quot; &lt;&lt; endl;

   sort( v1.begin( ), v1.end( ) );
   cout &lt;&lt; &quot;Sorted vector v1 = ( &quot; ;
   for ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ; Iter1++ )
      cout &lt;&lt; *Iter1 &lt;&lt; &quot; &quot;;
   cout &lt;&lt; &quot;)&quot; &lt;&lt; endl;

   // To sort in descending order. specify binary predicate
   sort( v1.begin( ), v1.end( ), greater&lt;int&gt;( ) );
   cout &lt;&lt; &quot;Resorted (greater) vector v1 = ( &quot; ;
   for ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ; Iter1++ )
      cout &lt;&lt; *Iter1 &lt;&lt; &quot; &quot;;
   cout &lt;&lt; &quot;)&quot; &lt;&lt; endl;

   // A user-defined (UD) binary predicate can also be used
   sort( v1.begin( ), v1.end( ), UDgreater );
   cout &lt;&lt; &quot;Resorted (UDgreater) vector v1 = ( &quot; ;
   for ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ; Iter1++ )
      cout &lt;&lt; *Iter1 &lt;&lt; &quot; &quot;;
   cout &lt;&lt; &quot;)&quot; &lt;&lt; endl;
}
"><span class="hljs-comment">// alg_sort.cpp</span>
<span class="hljs-comment">// compile with: /EHsc</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;functional&gt;      // For greater&lt;int&gt;( )</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span>

<span class="hljs-comment">// Return whether first element is greater than the second</span>
<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">UDgreater</span> <span class="hljs-params">( <span class="hljs-keyword">int</span> elem1, <span class="hljs-keyword">int</span> elem2 )</span>
</span>{
   <span class="hljs-keyword">return</span> elem1 &gt; elem2;
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
   <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;
   <span class="hljs-built_in">vector</span> &lt;<span class="hljs-keyword">int</span>&gt; v1;
   <span class="hljs-built_in">vector</span> &lt;<span class="hljs-keyword">int</span>&gt;::iterator Iter1;

   <span class="hljs-keyword">int</span> i;
   <span class="hljs-keyword">for</span> ( i = <span class="hljs-number">0</span> ; i &lt;= <span class="hljs-number">5</span> ; i++ )
   {
      v1.push_back( <span class="hljs-number">2</span> * i );
   }

   <span class="hljs-keyword">int</span> ii;
   <span class="hljs-keyword">for</span> ( ii = <span class="hljs-number">0</span> ; ii &lt;= <span class="hljs-number">5</span> ; ii++ )
   {
      v1.push_back( <span class="hljs-number">2</span> * ii + <span class="hljs-number">1</span> );
   }

   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Original vector v1 = ( "</span> ;
   <span class="hljs-keyword">for</span> ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ; Iter1++ )
      <span class="hljs-built_in">cout</span> &lt;&lt; *Iter1 &lt;&lt; <span class="hljs-string">" "</span>;
   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">")"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;

   sort( v1.begin( ), v1.end( ) );
   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Sorted vector v1 = ( "</span> ;
   <span class="hljs-keyword">for</span> ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ; Iter1++ )
      <span class="hljs-built_in">cout</span> &lt;&lt; *Iter1 &lt;&lt; <span class="hljs-string">" "</span>;
   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">")"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;

   <span class="hljs-comment">// To sort in descending order. specify binary predicate</span>
   sort( v1.begin( ), v1.end( ), greater&lt;<span class="hljs-keyword">int</span>&gt;( ) );
   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Resorted (greater) vector v1 = ( "</span> ;
   <span class="hljs-keyword">for</span> ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ; Iter1++ )
      <span class="hljs-built_in">cout</span> &lt;&lt; *Iter1 &lt;&lt; <span class="hljs-string">" "</span>;
   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">")"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;

   <span class="hljs-comment">// A user-defined (UD) binary predicate can also be used</span>
   sort( v1.begin( ), v1.end( ), UDgreater );
   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Resorted (UDgreater) vector v1 = ( "</span> ;
   <span class="hljs-keyword">for</span> ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ; Iter1++ )
      <span class="hljs-built_in">cout</span> &lt;&lt; *Iter1 &lt;&lt; <span class="hljs-string">" "</span>;
   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">")"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
}
</code></pre>
<div class="codeHeader" id="code-try-154" data-bi-name="code-header"><span class="language">Output</span>
			<button class="action" data-bi-name="copy">
				<span class="docon docon-edit-copy" role="presentation"></span>
				<span>Copy</span>
			</button></div><pre><code class="lang-Output" data-author-content="Original vector v1 = ( 0 2 4 6 8 10 1 3 5 7 9 11 )
Sorted vector v1 = ( 0 1 2 3 4 5 6 7 8 9 10 11 )
Resorted (greater) vector v1 = ( 11 10 9 8 7 6 5 4 3 2 1 0 )
Resorted (UDgreater) vector v1 = ( 11 10 9 8 7 6 5 4 3 2 1 0 )
">Original vector v1 = ( 0 2 4 6 8 10 1 3 5 7 9 11 )
Sorted vector v1 = ( 0 1 2 3 4 5 6 7 8 9 10 11 )
Resorted (greater) vector v1 = ( 11 10 9 8 7 6 5 4 3 2 1 0 )
Resorted (UDgreater) vector v1 = ( 11 10 9 8 7 6 5 4 3 2 1 0 )
</code></pre>
<h2 id="sort_heap" class="heading-with-anchor">  sort_heap<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#sort_heap"></a></h2>
<p>Converts a heap into a sorted range.</p>
<div class="codeHeader" id="code-try-155" data-bi-name="code-header"><span class="language">C++</span>
			<button class="action" data-bi-name="copy">
				<span class="docon docon-edit-copy" role="presentation"></span>
				<span>Copy</span>
			</button></div><pre><code class="lang-cpp" data-author-content="template&lt;class RandomAccessIterator&gt;
   void sort_heap(
      RandomAccessIterator first,
      RandomAccessIterator last);

template&lt;class RandomAccessIterator, class Predicate&gt;
   void sort_heap(
      RandomAccessIterator first,
      RandomAccessIterator last,
      Predicate comp);
"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RandomAccessIterator</span>&gt;
   <span class="hljs-title">void</span> <span class="hljs-title">sort_heap</span>(
      <span class="hljs-title">RandomAccessIterator</span> <span class="hljs-title">first</span>,
      <span class="hljs-title">RandomAccessIterator</span> <span class="hljs-title">last</span>);</span>

<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RandomAccessIterator</span>, <span class="hljs-title">class</span> <span class="hljs-title">Predicate</span>&gt;
   <span class="hljs-title">void</span> <span class="hljs-title">sort_heap</span>(
      <span class="hljs-title">RandomAccessIterator</span> <span class="hljs-title">first</span>,
      <span class="hljs-title">RandomAccessIterator</span> <span class="hljs-title">last</span>,
      <span class="hljs-title">Predicate</span> <span class="hljs-title">comp</span>);</span>
</code></pre>
<h3 id="parameters-75" class="heading-with-anchor">Parameters<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#parameters-75"></a></h3>
<p><em>first</em><br>
A random-access iterator addressing the position of the first element in the target heap.</p>
<p><em>last</em><br>
A random-access iterator addressing the position one past the final element in the target heap.</p>
<p><em>comp</em><br>
User-defined predicate function object that defines sense in which one element is less than another. A binary predicate takes two arguments and returns <strong>true</strong> when satisfied and <strong>false</strong> when not satisfied.</p>
<h3 id="remarks-75" class="heading-with-anchor">Remarks<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#remarks-75"></a></h3>
<p>Heaps have two properties:</p>
<ul>
<li><p>The first element is always the largest.</p>
</li>
<li><p>Elements may be added or removed in logarithmic time.</p>
</li>
</ul>
<p>After the application if this algorithm, the range it was applied to is no longer a heap.</p>
<p>This is not a stable sort because the relative order of equivalent elements is not necessarily preserved.</p>
<p>Heaps are an ideal way to implement priority queues and they are used in the implementation of the C++ Standard Library container adaptor <a href="https://docs.microsoft.com/en-us/cpp/standard-library/priority-queue-class?view=vs-2019" data-linktype="relative-path">priority_queue Class</a>.</p>
<p>The range referenced must be valid; all pointers must be dereferenceable and within the sequence the last position is reachable from the first by incrementation.</p>
<p>The complexity is at most  <em>N</em> log  <em>N</em>, where  <em>N</em> = ( <em>last - first</em>).</p>
<h3 id="example-56" class="heading-with-anchor">Example<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#example-56"></a></h3>
<div class="codeHeader" id="code-try-156" data-bi-name="code-header"><span class="language">C++</span>
			<button class="action" data-bi-name="copy">
				<span class="docon docon-edit-copy" role="presentation"></span>
				<span>Copy</span>
			</button></div><pre><code class="lang-cpp" data-author-content="// alg_sort_heap.cpp
// compile with: /EHsc
#include &lt;algorithm&gt;
#include &lt;functional&gt;
#include &lt;iostream&gt;
#include &lt;ostream&gt;
#include &lt;string&gt;
#include &lt;vector&gt;
using namespace std;

void print(const string&amp; s, const vector&lt;int&gt;&amp; v) {
    cout &lt;&lt; s &lt;&lt; &quot;: ( &quot;;

    for (auto i = v.begin(); i != v.end(); ++i) {
        cout &lt;&lt; *i &lt;&lt; &quot; &quot;;
    }

    cout &lt;&lt; &quot;)&quot; &lt;&lt; endl;
}

int main() {
    vector&lt;int&gt; v;
    for (int i = 1; i &lt;= 9; ++i) {
        v.push_back(i);
    }
    print(&quot;Initially&quot;, v);

    random_shuffle(v.begin(), v.end());
    print(&quot;After random_shuffle&quot;, v);

    make_heap(v.begin(), v.end());
    print(&quot;     After make_heap&quot;, v);

    sort_heap(v.begin(), v.end());
    print(&quot;     After sort_heap&quot;, v);

    random_shuffle(v.begin(), v.end());
    print(&quot;             After random_shuffle&quot;, v);

    make_heap(v.begin(), v.end(), greater&lt;int&gt;());
    print(&quot;After make_heap with greater&lt;int&gt;&quot;, v);

    sort_heap(v.begin(), v.end(), greater&lt;int&gt;());
    print(&quot;After sort_heap with greater&lt;int&gt;&quot;, v);
}
"><span class="hljs-comment">// alg_sort_heap.cpp</span>
<span class="hljs-comment">// compile with: /EHsc</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;functional&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;ostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span>&amp; s, <span class="hljs-keyword">const</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; v)</span> </span>{
    <span class="hljs-built_in">cout</span> &lt;&lt; s &lt;&lt; <span class="hljs-string">": ( "</span>;

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> i = v.begin(); i != v.end(); ++i) {
        <span class="hljs-built_in">cout</span> &lt;&lt; *i &lt;&lt; <span class="hljs-string">" "</span>;
    }

    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">")"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; v;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">9</span>; ++i) {
        v.push_back(i);
    }
    print(<span class="hljs-string">"Initially"</span>, v);

    random_shuffle(v.begin(), v.end());
    print(<span class="hljs-string">"After random_shuffle"</span>, v);

    make_heap(v.begin(), v.end());
    print(<span class="hljs-string">"     After make_heap"</span>, v);

    sort_heap(v.begin(), v.end());
    print(<span class="hljs-string">"     After sort_heap"</span>, v);

    random_shuffle(v.begin(), v.end());
    print(<span class="hljs-string">"             After random_shuffle"</span>, v);

    make_heap(v.begin(), v.end(), greater&lt;<span class="hljs-keyword">int</span>&gt;());
    print(<span class="hljs-string">"After make_heap with greater&lt;int&gt;"</span>, v);

    sort_heap(v.begin(), v.end(), greater&lt;<span class="hljs-keyword">int</span>&gt;());
    print(<span class="hljs-string">"After sort_heap with greater&lt;int&gt;"</span>, v);
}
</code></pre>
<h2 id="stable_partition" class="heading-with-anchor">  stable_partition<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#stable_partition"></a></h2>
<p>Classifies elements in a range into two disjoint sets, with those elements satisfying a unary predicate preceding those that fail to satisfy it, preserving the relative order of equivalent elements.</p>
<div class="codeHeader" id="code-try-157" data-bi-name="code-header"><span class="language">C++</span>
			<button class="action" data-bi-name="copy">
				<span class="docon docon-edit-copy" role="presentation"></span>
				<span>Copy</span>
			</button></div><pre><code class="lang-cpp" data-author-content="template&lt;class BidirectionalIterator, class Predicate&gt;
BidirectionalIterator stable_partition(
    BidirectionalIterator first,
    BidirectionalIterator last,
    Predicate pred );
"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BidirectionalIterator</span>, <span class="hljs-title">class</span> <span class="hljs-title">Predicate</span>&gt;
<span class="hljs-title">BidirectionalIterator</span> <span class="hljs-title">stable_partition</span>(
    <span class="hljs-title">BidirectionalIterator</span> <span class="hljs-title">first</span>,
    <span class="hljs-title">BidirectionalIterator</span> <span class="hljs-title">last</span>,
    <span class="hljs-title">Predicate</span> <span class="hljs-title">pred</span> );</span>
</code></pre>
<h3 id="parameters-76" class="heading-with-anchor">Parameters<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#parameters-76"></a></h3>
<p><em>first</em><br>
A bidirectional iterator addressing the position of the first element in the range to be partitioned.</p>
<p><em>last</em><br>
A bidirectional iterator addressing the position one past the final element in the range to be partitioned.</p>
<p><em>_Pred</em><br>
User-defined predicate function object that defines the condition to be satisfied if an element is to be classified. A predicate takes single argument and returns <strong>true</strong> or <strong>false</strong>.</p>
<h3 id="return-value-54" class="heading-with-anchor">Return Value<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#return-value-54"></a></h3>
<p>A bidirectional iterator addressing the position of the first element in the range to not satisfy the predicate condition.</p>
<h3 id="remarks-76" class="heading-with-anchor">Remarks<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#remarks-76"></a></h3>
<p>The range referenced must be valid; all pointers must be dereferenceable and within the sequence the last position is reachable from the first by incrementation.</p>
<p>Elements  <em>a</em> and  <em>b</em> are equivalent, but not necessarily equal, if both  <em>Pr</em> ( <em>a</em>,  <em>b</em>) is false and  <em>Pr</em> ( <em>b</em>,  <em>a</em>) if false, where  <em>Pr</em> is the parameter-specified predicate. The <code>stable_ partition</code> algorithm is stable and guarantees that the relative ordering of equivalent elements will be preserved. The algorithm <code>partition</code> does not necessarily preserve this original ordering.</p>
<h3 id="example-57" class="heading-with-anchor">Example<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#example-57"></a></h3>
<div class="codeHeader" id="code-try-158" data-bi-name="code-header"><span class="language">C++</span>
			<button class="action" data-bi-name="copy">
				<span class="docon docon-edit-copy" role="presentation"></span>
				<span>Copy</span>
			</button></div><pre><code class="lang-cpp" data-author-content="// alg_stable_partition.cpp
// compile with: /EHsc
#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;iostream&gt;

bool greater5 ( int value ) {
   return value &gt; 5;
}

int main() {
   using namespace std;
   vector &lt;int&gt; v1, v2;
   vector &lt;int&gt;::iterator Iter1, Iter2, result;

   int i;
   for ( i = 0 ; i &lt;= 10 ; i++ )
      v1.push_back( i );

   int ii;
   for ( ii = 0 ; ii &lt;= 4 ; ii++ )
      v1.push_back( 5 );

   random_shuffle(v1.begin( ), v1.end( ) );

   cout &lt;&lt; &quot;Vector v1 is ( &quot; ;
   for ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ; Iter1++ )
      cout &lt;&lt; *Iter1 &lt;&lt; &quot; &quot;;
   cout &lt;&lt; &quot;).&quot; &lt;&lt; endl;

   // Partition the range with predicate greater10
   result = stable_partition (v1.begin( ), v1.end( ), greater5 );
   cout &lt;&lt; &quot;The partitioned set of elements in v1 is:\n ( &quot; ;
   for ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ; Iter1++ )
      cout &lt;&lt; *Iter1 &lt;&lt; &quot; &quot;;
   cout &lt;&lt; &quot;).&quot; &lt;&lt; endl;

   cout &lt;&lt; &quot;The first element in v1 to fail to satisfy the&quot;
        &lt;&lt; &quot;\n predicate greater5 is: &quot; &lt;&lt; *result &lt;&lt; &quot;.&quot; &lt;&lt; endl;
}
"><span class="hljs-comment">// alg_stable_partition.cpp</span>
<span class="hljs-comment">// compile with: /EHsc</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span>

<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">greater5</span> <span class="hljs-params">( <span class="hljs-keyword">int</span> value )</span> </span>{
   <span class="hljs-keyword">return</span> value &gt; <span class="hljs-number">5</span>;
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
   <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;
   <span class="hljs-built_in">vector</span> &lt;<span class="hljs-keyword">int</span>&gt; v1, v2;
   <span class="hljs-built_in">vector</span> &lt;<span class="hljs-keyword">int</span>&gt;::iterator Iter1, Iter2, result;

   <span class="hljs-keyword">int</span> i;
   <span class="hljs-keyword">for</span> ( i = <span class="hljs-number">0</span> ; i &lt;= <span class="hljs-number">10</span> ; i++ )
      v1.push_back( i );

   <span class="hljs-keyword">int</span> ii;
   <span class="hljs-keyword">for</span> ( ii = <span class="hljs-number">0</span> ; ii &lt;= <span class="hljs-number">4</span> ; ii++ )
      v1.push_back( <span class="hljs-number">5</span> );

   random_shuffle(v1.begin( ), v1.end( ) );

   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Vector v1 is ( "</span> ;
   <span class="hljs-keyword">for</span> ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ; Iter1++ )
      <span class="hljs-built_in">cout</span> &lt;&lt; *Iter1 &lt;&lt; <span class="hljs-string">" "</span>;
   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">")."</span> &lt;&lt; <span class="hljs-built_in">endl</span>;

   <span class="hljs-comment">// Partition the range with predicate greater10</span>
   result = stable_partition (v1.begin( ), v1.end( ), greater5 );
   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"The partitioned set of elements in v1 is:\n ( "</span> ;
   <span class="hljs-keyword">for</span> ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ; Iter1++ )
      <span class="hljs-built_in">cout</span> &lt;&lt; *Iter1 &lt;&lt; <span class="hljs-string">" "</span>;
   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">")."</span> &lt;&lt; <span class="hljs-built_in">endl</span>;

   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"The first element in v1 to fail to satisfy the"</span>
        &lt;&lt; <span class="hljs-string">"\n predicate greater5 is: "</span> &lt;&lt; *result &lt;&lt; <span class="hljs-string">"."</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
}
</code></pre>
<h2 id="stable_sort" class="heading-with-anchor">  stable_sort<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#stable_sort"></a></h2>
<p>Arranges the elements in a specified range into a nondescending order or according to an ordering criterion specified by a binary predicate and preserves the relative ordering of equivalent elements.</p>
<div class="codeHeader" id="code-try-159" data-bi-name="code-header"><span class="language">C++</span>
			<button class="action" data-bi-name="copy">
				<span class="docon docon-edit-copy" role="presentation"></span>
				<span>Copy</span>
			</button></div><pre><code class="lang-cpp" data-author-content="template&lt;class BidirectionalIterator&gt;
void stable_sort( BidirectionalIterator first, BidirectionalIterator last );

template&lt;class BidirectionalIterator, class BinaryPredicate&gt;
void stable_sort(
    BidirectionalIterator first,
    BidirectionalIterator last,
    BinaryPredicate comp );
"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BidirectionalIterator</span>&gt;
<span class="hljs-title">void</span> <span class="hljs-title">stable_sort</span>( <span class="hljs-title">BidirectionalIterator</span> <span class="hljs-title">first</span>, <span class="hljs-title">BidirectionalIterator</span> <span class="hljs-title">last</span> );</span>

<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BidirectionalIterator</span>, <span class="hljs-title">class</span> <span class="hljs-title">BinaryPredicate</span>&gt;
<span class="hljs-title">void</span> <span class="hljs-title">stable_sort</span>(
    <span class="hljs-title">BidirectionalIterator</span> <span class="hljs-title">first</span>,
    <span class="hljs-title">BidirectionalIterator</span> <span class="hljs-title">last</span>,
    <span class="hljs-title">BinaryPredicate</span> <span class="hljs-title">comp</span> );</span>
</code></pre>
<h3 id="parameters-77" class="heading-with-anchor">Parameters<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#parameters-77"></a></h3>
<p><em>first</em><br>
A bidirectional iterator addressing the position of the first element in the range to be sorted.</p>
<p><em>last</em><br>
A bidirectional iterator addressing the position one past the final element in the range to be sorted.</p>
<p><em>comp</em><br>
User-defined predicate function object that defines the comparison criterion to be satisfied by successive elements in the ordering. A binary predicate takes two arguments and returns <strong>true</strong> when satisfied and <strong>false</strong> when not satisfied.</p>
<h3 id="remarks-77" class="heading-with-anchor">Remarks<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#remarks-77"></a></h3>
<p>The range referenced must be valid; all pointers must be dereferenceable and within the sequence the last position is reachable from the first by incrementation.</p>
<p>Elements are equivalent, but not necessarily equal, if neither is less than the other. The <code>sort</code> algorithm is stable and guarantees that the relative ordering of equivalent elements will be preserved.</p>
<p>The run-time complexity of <code>stable_sort</code> depends on the amount of memory available, but the best case (given sufficient memory) is  <em>O</em>( <em>N</em> log  <em>N</em>) and the worst case is  <em>O</em>(  <em>N</em> ( log  <em>N</em> )2 ), where  <em>N</em> =  <em>last - First.</em> Usually, the <code>sort</code> algorithm is significantly faster than <code>stable_sort</code>.</p>
<h3 id="example-58" class="heading-with-anchor">Example<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#example-58"></a></h3>
<div class="codeHeader" id="code-try-160" data-bi-name="code-header"><span class="language">C++</span>
			<button class="action" data-bi-name="copy">
				<span class="docon docon-edit-copy" role="presentation"></span>
				<span>Copy</span>
			</button></div><pre><code class="lang-cpp" data-author-content="// alg_stable_sort.cpp
// compile with: /EHsc
#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;functional&gt;      // For greater&lt;int&gt;( )
#include &lt;iostream&gt;

// Return whether first element is greater than the second
bool UDgreater (int elem1, int elem2 )
{
   return elem1 &gt; elem2;
}

int main()
{
   using namespace std;
   vector &lt;int&gt; v1;
   vector &lt;int&gt;::iterator Iter1;

   int i;
   for ( i = 0 ; i &lt;= 5 ; i++ )
   {
      v1.push_back( 2 * i );
   }

   for ( i = 0 ; i &lt;= 5 ; i++ )
   {
      v1.push_back( 2 * i  );
   }

   cout &lt;&lt; &quot;Original vector v1 = ( &quot; ;
   for ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ; Iter1++ )
      cout &lt;&lt; *Iter1 &lt;&lt; &quot; &quot;;
   cout &lt;&lt; &quot;)&quot; &lt;&lt; endl;

   stable_sort(v1.begin( ), v1.end( ) );
   cout &lt;&lt; &quot;Sorted vector v1 = ( &quot; ;
   for ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ; Iter1++ )
      cout &lt;&lt; *Iter1 &lt;&lt; &quot; &quot;;
   cout &lt;&lt; &quot;)&quot; &lt;&lt; endl;

   // To sort in descending order, specify binary predicate
   stable_sort(v1.begin( ), v1.end( ), greater&lt;int&gt;( ) );
   cout &lt;&lt; &quot;Resorted (greater) vector v1 = ( &quot; ;
   for ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ; Iter1++ )
      cout &lt;&lt; *Iter1 &lt;&lt; &quot; &quot;;
   cout &lt;&lt; &quot;)&quot; &lt;&lt; endl;

   // A user-defined (UD) binary predicate can also be used
   stable_sort(v1.begin( ), v1.end( ), UDgreater );
   cout &lt;&lt; &quot;Resorted (UDgreater) vector v1 = ( &quot; ;
   for ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ; Iter1++ )
      cout &lt;&lt; *Iter1 &lt;&lt; &quot; &quot;;
   cout &lt;&lt; &quot;)&quot; &lt;&lt; endl;
}
"><span class="hljs-comment">// alg_stable_sort.cpp</span>
<span class="hljs-comment">// compile with: /EHsc</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;functional&gt;      // For greater&lt;int&gt;( )</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span>

<span class="hljs-comment">// Return whether first element is greater than the second</span>
<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">UDgreater</span> <span class="hljs-params">(<span class="hljs-keyword">int</span> elem1, <span class="hljs-keyword">int</span> elem2 )</span>
</span>{
   <span class="hljs-keyword">return</span> elem1 &gt; elem2;
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
   <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;
   <span class="hljs-built_in">vector</span> &lt;<span class="hljs-keyword">int</span>&gt; v1;
   <span class="hljs-built_in">vector</span> &lt;<span class="hljs-keyword">int</span>&gt;::iterator Iter1;

   <span class="hljs-keyword">int</span> i;
   <span class="hljs-keyword">for</span> ( i = <span class="hljs-number">0</span> ; i &lt;= <span class="hljs-number">5</span> ; i++ )
   {
      v1.push_back( <span class="hljs-number">2</span> * i );
   }

   <span class="hljs-keyword">for</span> ( i = <span class="hljs-number">0</span> ; i &lt;= <span class="hljs-number">5</span> ; i++ )
   {
      v1.push_back( <span class="hljs-number">2</span> * i  );
   }

   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Original vector v1 = ( "</span> ;
   <span class="hljs-keyword">for</span> ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ; Iter1++ )
      <span class="hljs-built_in">cout</span> &lt;&lt; *Iter1 &lt;&lt; <span class="hljs-string">" "</span>;
   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">")"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;

   stable_sort(v1.begin( ), v1.end( ) );
   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Sorted vector v1 = ( "</span> ;
   <span class="hljs-keyword">for</span> ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ; Iter1++ )
      <span class="hljs-built_in">cout</span> &lt;&lt; *Iter1 &lt;&lt; <span class="hljs-string">" "</span>;
   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">")"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;

   <span class="hljs-comment">// To sort in descending order, specify binary predicate</span>
   stable_sort(v1.begin( ), v1.end( ), greater&lt;<span class="hljs-keyword">int</span>&gt;( ) );
   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Resorted (greater) vector v1 = ( "</span> ;
   <span class="hljs-keyword">for</span> ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ; Iter1++ )
      <span class="hljs-built_in">cout</span> &lt;&lt; *Iter1 &lt;&lt; <span class="hljs-string">" "</span>;
   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">")"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;

   <span class="hljs-comment">// A user-defined (UD) binary predicate can also be used</span>
   stable_sort(v1.begin( ), v1.end( ), UDgreater );
   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Resorted (UDgreater) vector v1 = ( "</span> ;
   <span class="hljs-keyword">for</span> ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ; Iter1++ )
      <span class="hljs-built_in">cout</span> &lt;&lt; *Iter1 &lt;&lt; <span class="hljs-string">" "</span>;
   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">")"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
}
</code></pre>
<div class="codeHeader" id="code-try-161" data-bi-name="code-header"><span class="language">Output</span>
			<button class="action" data-bi-name="copy">
				<span class="docon docon-edit-copy" role="presentation"></span>
				<span>Copy</span>
			</button></div><pre><code class="lang-Output" data-author-content="Original vector v1 = ( 0 2 4 6 8 10 0 2 4 6 8 10 )
Sorted vector v1 = ( 0 0 2 2 4 4 6 6 8 8 10 10 )
Resorted (greater) vector v1 = ( 10 10 8 8 6 6 4 4 2 2 0 0 )
Resorted (UDgreater) vector v1 = ( 10 10 8 8 6 6 4 4 2 2 0 0 )
">Original vector v1 = ( 0 2 4 6 8 10 0 2 4 6 8 10 )
Sorted vector v1 = ( 0 0 2 2 4 4 6 6 8 8 10 10 )
Resorted (greater) vector v1 = ( 10 10 8 8 6 6 4 4 2 2 0 0 )
Resorted (UDgreater) vector v1 = ( 10 10 8 8 6 6 4 4 2 2 0 0 )
</code></pre>
<h2 id="swap" class="heading-with-anchor">  swap<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#swap"></a></h2>
<p>The first override exchanges the values of two objects. The second override exchanges the values between two arrays of objects.</p>
<div class="codeHeader" id="code-try-162" data-bi-name="code-header"><span class="language">C++</span>
			<button class="action" data-bi-name="copy">
				<span class="docon docon-edit-copy" role="presentation"></span>
				<span>Copy</span>
			</button></div><pre><code class="lang-cpp" data-author-content="template&lt;class Type&gt;
   void swap(
      Type&amp; left,
      Type&amp; right);
template&lt;class Type, size_t N&gt;
   void swap(
      Type (&amp; left)[N],
      Type (&amp; right)[N]);\r
"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Type</span>&gt;
   <span class="hljs-title">void</span> <span class="hljs-title">swap</span>(
      <span class="hljs-title">Type</span>&amp; <span class="hljs-title">left</span>,
      <span class="hljs-title">Type</span>&amp; <span class="hljs-title">right</span>);</span>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Type</span>, <span class="hljs-title">size_t</span> <span class="hljs-title">N</span>&gt;
   <span class="hljs-title">void</span> <span class="hljs-title">swap</span>(
      <span class="hljs-title">Type</span> (&amp; <span class="hljs-title">left</span>)[<span class="hljs-title">N</span>],
      <span class="hljs-title">Type</span> (&amp; <span class="hljs-title">right</span>)[<span class="hljs-title">N</span>]);</span>\r
</code></pre>
<h3 id="parameters-78" class="heading-with-anchor">Parameters<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#parameters-78"></a></h3>
<p><em>left</em><br>
For the first override, the first object to have its contents exchanged. For the second override, the first array of objects to have its contents exchanged.</p>
<p><em>right</em><br>
For the first override, the second object to have its contents exchanged. For the second override, the second array of objects to have its contents exchanged.</p>
<h3 id="remarks-78" class="heading-with-anchor">Remarks<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#remarks-78"></a></h3>
<p>The first overload is designed to operate on individual objects. The second overload swaps the contents of objects between two arrays.</p>
<h3 id="example-59" class="heading-with-anchor">Example<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#example-59"></a></h3>
<div class="codeHeader" id="code-try-163" data-bi-name="code-header"><span class="language">C++</span>
			<button class="action" data-bi-name="copy">
				<span class="docon docon-edit-copy" role="presentation"></span>
				<span>Copy</span>
			</button></div><pre><code class="lang-cpp" data-author-content="// alg_swap.cpp
// compile with: /EHsc
#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;iostream&gt;

int main()
{
   using namespace std;
   vector &lt;int&gt; v1, v2;
   vector &lt;int&gt;::iterator Iter1, Iter2, result;

   for ( int i = 0 ; i &lt;= 10 ; i++ )
   {
      v1.push_back( i );
   }

   for ( int ii = 0 ; ii &lt;= 4 ; ii++ )
   {
      v2.push_back( 5 );
   }

   cout &lt;&lt; &quot;Vector v1 is ( &quot; ;
   for ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ; Iter1++ )
      cout &lt;&lt; *Iter1 &lt;&lt; &quot; &quot;;
   cout &lt;&lt; &quot;).&quot; &lt;&lt; endl;

   cout &lt;&lt; &quot;Vector v2 is ( &quot; ;
   for ( Iter2 = v2.begin( ) ; Iter2 != v2.end( ) ; Iter2++ )
      cout &lt;&lt; *Iter2 &lt;&lt; &quot; &quot;;
   cout &lt;&lt; &quot;).&quot; &lt;&lt; endl;

   swap( v1, v2 );

   cout &lt;&lt; &quot;Vector v1 is ( &quot; ;
   for ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ; Iter1++ )
      cout &lt;&lt; *Iter1 &lt;&lt; &quot; &quot;;
   cout &lt;&lt; &quot;).&quot; &lt;&lt; endl;

   cout &lt;&lt; &quot;Vector v2 is ( &quot; ;
   for ( Iter2 = v2.begin( ) ; Iter2 != v2.end( ) ; Iter2++ )
      cout &lt;&lt; *Iter2 &lt;&lt; &quot; &quot;;
   cout &lt;&lt; &quot;).&quot; &lt;&lt; endl;
}
"><span class="hljs-comment">// alg_swap.cpp</span>
<span class="hljs-comment">// compile with: /EHsc</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span>

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
   <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;
   <span class="hljs-built_in">vector</span> &lt;<span class="hljs-keyword">int</span>&gt; v1, v2;
   <span class="hljs-built_in">vector</span> &lt;<span class="hljs-keyword">int</span>&gt;::iterator Iter1, Iter2, result;

   <span class="hljs-keyword">for</span> ( <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span> ; i &lt;= <span class="hljs-number">10</span> ; i++ )
   {
      v1.push_back( i );
   }

   <span class="hljs-keyword">for</span> ( <span class="hljs-keyword">int</span> ii = <span class="hljs-number">0</span> ; ii &lt;= <span class="hljs-number">4</span> ; ii++ )
   {
      v2.push_back( <span class="hljs-number">5</span> );
   }

   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Vector v1 is ( "</span> ;
   <span class="hljs-keyword">for</span> ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ; Iter1++ )
      <span class="hljs-built_in">cout</span> &lt;&lt; *Iter1 &lt;&lt; <span class="hljs-string">" "</span>;
   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">")."</span> &lt;&lt; <span class="hljs-built_in">endl</span>;

   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Vector v2 is ( "</span> ;
   <span class="hljs-keyword">for</span> ( Iter2 = v2.begin( ) ; Iter2 != v2.end( ) ; Iter2++ )
      <span class="hljs-built_in">cout</span> &lt;&lt; *Iter2 &lt;&lt; <span class="hljs-string">" "</span>;
   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">")."</span> &lt;&lt; <span class="hljs-built_in">endl</span>;

   swap( v1, v2 );

   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Vector v1 is ( "</span> ;
   <span class="hljs-keyword">for</span> ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ; Iter1++ )
      <span class="hljs-built_in">cout</span> &lt;&lt; *Iter1 &lt;&lt; <span class="hljs-string">" "</span>;
   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">")."</span> &lt;&lt; <span class="hljs-built_in">endl</span>;

   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Vector v2 is ( "</span> ;
   <span class="hljs-keyword">for</span> ( Iter2 = v2.begin( ) ; Iter2 != v2.end( ) ; Iter2++ )
      <span class="hljs-built_in">cout</span> &lt;&lt; *Iter2 &lt;&lt; <span class="hljs-string">" "</span>;
   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">")."</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
}
</code></pre>
<div class="codeHeader" id="code-try-164" data-bi-name="code-header"><span class="language">Output</span>
			<button class="action" data-bi-name="copy">
				<span class="docon docon-edit-copy" role="presentation"></span>
				<span>Copy</span>
			</button></div><pre><code class="lang-Output" data-author-content="Vector v1 is ( 0 1 2 3 4 5 6 7 8 9 10 ).
Vector v2 is ( 5 5 5 5 5 ).
Vector v1 is ( 5 5 5 5 5 ).
Vector v2 is ( 0 1 2 3 4 5 6 7 8 9 10 ).
">Vector v1 is ( 0 1 2 3 4 5 6 7 8 9 10 ).
Vector v2 is ( 5 5 5 5 5 ).
Vector v1 is ( 5 5 5 5 5 ).
Vector v2 is ( 0 1 2 3 4 5 6 7 8 9 10 ).
</code></pre>
<h2 id="swap_ranges" class="heading-with-anchor">  swap_ranges<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#swap_ranges"></a></h2>
<p>Exchanges the elements of one range with the elements of another, equal sized range.</p>
<div class="codeHeader" id="code-try-165" data-bi-name="code-header"><span class="language">C++</span>
			<button class="action" data-bi-name="copy">
				<span class="docon docon-edit-copy" role="presentation"></span>
				<span>Copy</span>
			</button></div><pre><code class="lang-cpp" data-author-content="template&lt;class ForwardIterator1, class ForwardIterator2&gt;
ForwardIterator2 swap_ranges(
   ForwardIterator1 first1,
   ForwardIterator1 last1,
   ForwardIterator2 first2 );
"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ForwardIterator1</span>, <span class="hljs-title">class</span> <span class="hljs-title">ForwardIterator2</span>&gt;
<span class="hljs-title">ForwardIterator2</span> <span class="hljs-title">swap_ranges</span>(
   <span class="hljs-title">ForwardIterator1</span> <span class="hljs-title">first1</span>,
   <span class="hljs-title">ForwardIterator1</span> <span class="hljs-title">last1</span>,
   <span class="hljs-title">ForwardIterator2</span> <span class="hljs-title">first2</span> );</span>
</code></pre>
<h3 id="parameters-79" class="heading-with-anchor">Parameters<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#parameters-79"></a></h3>
<p><em>first1</em><br>
A forward iterator pointing to the first position of the first range whose elements are to be exchanged.</p>
<p><em>last1</em><br>
A forward iterator pointing to one past the final position of the first range whose elements are to be exchanged.</p>
<p><em>first2</em><br>
A forward iterator pointing to the first position of the second range whose elements are to be exchanged.</p>
<h3 id="return-value-55" class="heading-with-anchor">Return Value<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#return-value-55"></a></h3>
<p>A forward iterator pointing to one past the final position of the second range whose elements are to be exchanged.</p>
<h3 id="remarks-79" class="heading-with-anchor">Remarks<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#remarks-79"></a></h3>
<p>The ranges referenced must be valid; all pointers must be dereferenceable and within each sequence the last position is reachable from the first by incrementation. The second range has to be as large as the first range.</p>
<p>The complexity is linear with <em>last1</em> - <em>first1</em> swaps performed. If elements from containers of the same type are being swapped, them the <code>swap</code> member function from that container should be used, because the member function typically has constant complexity.</p>
<h3 id="example-60" class="heading-with-anchor">Example<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#example-60"></a></h3>
<div class="codeHeader" id="code-try-166" data-bi-name="code-header"><span class="language">C++</span>
			<button class="action" data-bi-name="copy">
				<span class="docon docon-edit-copy" role="presentation"></span>
				<span>Copy</span>
			</button></div><pre><code class="lang-cpp" data-author-content="// alg_swap_ranges.cpp
// compile with: /EHsc
#include &lt;vector&gt;
#include &lt;deque&gt;
#include &lt;algorithm&gt;
#include &lt;iostream&gt;

int main()
{
   using namespace std;
   vector &lt;int&gt; v1;
   deque &lt;int&gt; d1;
   vector &lt;int&gt;::iterator v1Iter1;
   deque&lt;int&gt;::iterator d1Iter1;

   int i;
   for ( i = 0 ; i &lt;= 5 ; i++ )
   {
      v1.push_back( i );
   }

   int ii;
   for ( ii =4 ; ii &lt;= 9 ; ii++ )
   {
      d1.push_back( 6 );
   }

   cout &lt;&lt; &quot;Vector v1 is ( &quot; ;
   for ( v1Iter1 = v1.begin( ) ; v1Iter1 != v1.end( ) ;v1Iter1 ++ )
      cout &lt;&lt; *v1Iter1  &lt;&lt; &quot; &quot;;
   cout &lt;&lt; &quot;).&quot; &lt;&lt; endl;

   cout &lt;&lt; &quot;Deque d1 is  ( &quot; ;
   for ( d1Iter1 = d1.begin( ) ; d1Iter1 != d1.end( ) ;d1Iter1 ++ )
      cout &lt;&lt; *d1Iter1  &lt;&lt; &quot; &quot;;
   cout &lt;&lt; &quot;).&quot; &lt;&lt; endl;

   swap_ranges ( v1.begin( ), v1.end( ), d1.begin( ) );

   cout &lt;&lt; &quot;After the swap_range, vector v1 is ( &quot; ;
   for ( v1Iter1 = v1.begin( ) ; v1Iter1 != v1.end( ) ;v1Iter1 ++ )
      cout &lt;&lt; *v1Iter1 &lt;&lt; &quot; &quot;;
   cout &lt;&lt; &quot;).&quot; &lt;&lt; endl;

   cout &lt;&lt; &quot;After the swap_range deque d1 is   ( &quot; ;
   for ( d1Iter1 = d1.begin( ) ; d1Iter1 != d1.end( ) ;d1Iter1 ++ )
      cout &lt;&lt; *d1Iter1 &lt;&lt; &quot; &quot;;
   cout &lt;&lt; &quot;).&quot; &lt;&lt; endl;
}
"><span class="hljs-comment">// alg_swap_ranges.cpp</span>
<span class="hljs-comment">// compile with: /EHsc</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;deque&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span>

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
   <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;
   <span class="hljs-built_in">vector</span> &lt;<span class="hljs-keyword">int</span>&gt; v1;
   <span class="hljs-built_in">deque</span> &lt;<span class="hljs-keyword">int</span>&gt; d1;
   <span class="hljs-built_in">vector</span> &lt;<span class="hljs-keyword">int</span>&gt;::iterator v1Iter1;
   <span class="hljs-built_in">deque</span>&lt;<span class="hljs-keyword">int</span>&gt;::iterator d1Iter1;

   <span class="hljs-keyword">int</span> i;
   <span class="hljs-keyword">for</span> ( i = <span class="hljs-number">0</span> ; i &lt;= <span class="hljs-number">5</span> ; i++ )
   {
      v1.push_back( i );
   }

   <span class="hljs-keyword">int</span> ii;
   <span class="hljs-keyword">for</span> ( ii =<span class="hljs-number">4</span> ; ii &lt;= <span class="hljs-number">9</span> ; ii++ )
   {
      d1.push_back( <span class="hljs-number">6</span> );
   }

   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Vector v1 is ( "</span> ;
   <span class="hljs-keyword">for</span> ( v1Iter1 = v1.begin( ) ; v1Iter1 != v1.end( ) ;v1Iter1 ++ )
      <span class="hljs-built_in">cout</span> &lt;&lt; *v1Iter1  &lt;&lt; <span class="hljs-string">" "</span>;
   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">")."</span> &lt;&lt; <span class="hljs-built_in">endl</span>;

   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Deque d1 is  ( "</span> ;
   <span class="hljs-keyword">for</span> ( d1Iter1 = d1.begin( ) ; d1Iter1 != d1.end( ) ;d1Iter1 ++ )
      <span class="hljs-built_in">cout</span> &lt;&lt; *d1Iter1  &lt;&lt; <span class="hljs-string">" "</span>;
   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">")."</span> &lt;&lt; <span class="hljs-built_in">endl</span>;

   swap_ranges ( v1.begin( ), v1.end( ), d1.begin( ) );

   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"After the swap_range, vector v1 is ( "</span> ;
   <span class="hljs-keyword">for</span> ( v1Iter1 = v1.begin( ) ; v1Iter1 != v1.end( ) ;v1Iter1 ++ )
      <span class="hljs-built_in">cout</span> &lt;&lt; *v1Iter1 &lt;&lt; <span class="hljs-string">" "</span>;
   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">")."</span> &lt;&lt; <span class="hljs-built_in">endl</span>;

   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"After the swap_range deque d1 is   ( "</span> ;
   <span class="hljs-keyword">for</span> ( d1Iter1 = d1.begin( ) ; d1Iter1 != d1.end( ) ;d1Iter1 ++ )
      <span class="hljs-built_in">cout</span> &lt;&lt; *d1Iter1 &lt;&lt; <span class="hljs-string">" "</span>;
   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">")."</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
}
</code></pre>
<div class="codeHeader" id="code-try-167" data-bi-name="code-header"><span class="language">Output</span>
			<button class="action" data-bi-name="copy">
				<span class="docon docon-edit-copy" role="presentation"></span>
				<span>Copy</span>
			</button></div><pre><code class="lang-Output" data-author-content="Vector v1 is ( 0 1 2 3 4 5 ).
Deque d1 is  ( 6 6 6 6 6 6 ).
After the swap_range, vector v1 is ( 6 6 6 6 6 6 ).
After the swap_range deque d1 is   ( 0 1 2 3 4 5 ).
">Vector v1 is ( 0 1 2 3 4 5 ).
Deque d1 is  ( 6 6 6 6 6 6 ).
After the swap_range, vector v1 is ( 6 6 6 6 6 6 ).
After the swap_range deque d1 is   ( 0 1 2 3 4 5 ).
</code></pre>
<h2 id="transform" class="heading-with-anchor">  transform<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#transform"></a></h2>
<p>Applies a specified function object to each element in a source range or to a pair of elements from two source ranges and copies the return values of the function object into a destination range.</p>
<div class="codeHeader" id="code-try-168" data-bi-name="code-header"><span class="language">C++</span>
			<button class="action" data-bi-name="copy">
				<span class="docon docon-edit-copy" role="presentation"></span>
				<span>Copy</span>
			</button></div><pre><code class="lang-cpp" data-author-content="template&lt;class InputIterator, class OutputIterator, class UnaryFunction&gt;
OutputIterator transform(
    InputIterator first1,
    InputIterator last1,
    OutputIterator result,
    UnaryFunction func );

template&lt;class InputIterator1, class InputIterator2, class OutputIterator, class BinaryFunction&gt;
OutputIterator transform(
    InputIterator1 first1,
    InputIterator1 last1,
    InputIterator2 first2,
    OutputIterator result,
    BinaryFunction func );
"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InputIterator</span>, <span class="hljs-title">class</span> <span class="hljs-title">OutputIterator</span>, <span class="hljs-title">class</span> <span class="hljs-title">UnaryFunction</span>&gt;
<span class="hljs-title">OutputIterator</span> <span class="hljs-title">transform</span>(
    <span class="hljs-title">InputIterator</span> <span class="hljs-title">first1</span>,
    <span class="hljs-title">InputIterator</span> <span class="hljs-title">last1</span>,
    <span class="hljs-title">OutputIterator</span> <span class="hljs-title">result</span>,
    <span class="hljs-title">UnaryFunction</span> <span class="hljs-title">func</span> );</span>

<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InputIterator1</span>, <span class="hljs-title">class</span> <span class="hljs-title">InputIterator2</span>, <span class="hljs-title">class</span> <span class="hljs-title">OutputIterator</span>, <span class="hljs-title">class</span> <span class="hljs-title">BinaryFunction</span>&gt;
<span class="hljs-title">OutputIterator</span> <span class="hljs-title">transform</span>(
    <span class="hljs-title">InputIterator1</span> <span class="hljs-title">first1</span>,
    <span class="hljs-title">InputIterator1</span> <span class="hljs-title">last1</span>,
    <span class="hljs-title">InputIterator2</span> <span class="hljs-title">first2</span>,
    <span class="hljs-title">OutputIterator</span> <span class="hljs-title">result</span>,
    <span class="hljs-title">BinaryFunction</span> <span class="hljs-title">func</span> );</span>
</code></pre>
<h3 id="parameters-80" class="heading-with-anchor">Parameters<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#parameters-80"></a></h3>
<p><em>first1</em><br>
An input iterator addressing the position of the first element in the first source range to be operated on.</p>
<p><em>last1</em><br>
An input iterator addressing the position one past the final element in the first source range operated on.</p>
<p><em>first2</em><br>
An input iterator addressing the position of the first element in the second source range to be operated on.</p>
<p><em>result</em><br>
An output iterator addressing the position of the first element in the destination range.</p>
<p><em>_Func</em><br>
User-defined unary function object used in the first version of the algorithm that is applied to each element in the first source range or A user-defined (UD) binary function object used in the second version of the algorithm that is applied pairwise, in a forward order, to the two source ranges.</p>
<h3 id="return-value-56" class="heading-with-anchor">Return Value<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#return-value-56"></a></h3>
<p>An output iterator addressing the position one past the final element in the destination range that is receiving the output elements transformed by the function object.</p>
<h3 id="remarks-80" class="heading-with-anchor">Remarks<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#remarks-80"></a></h3>
<p>The ranges referenced must be valid; all pointers must be dereferenceable and within each sequence the last position must be reachable from the first by incrementation. The destination range must be large enough to contain the transformed source range.</p>
<p>If <em>result</em> is set equal to  <em>first1</em> in the first version of the algorithm, then the source and destination ranges will be the same and the sequence will be modified in place. But the <em>result</em> may not address a position within the range [<code>first1</code> + 1, <code>last1</code>).</p>
<p>The complexity is linear with at most (<code>last1</code> - <code>first1</code>) comparisons.</p>
<h3 id="example-61" class="heading-with-anchor">Example<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#example-61"></a></h3>
<div class="codeHeader" id="code-try-169" data-bi-name="code-header"><span class="language">C++</span>
			<button class="action" data-bi-name="copy">
				<span class="docon docon-edit-copy" role="presentation"></span>
				<span>Copy</span>
			</button></div><pre><code class="lang-cpp" data-author-content="// alg_transform.cpp
// compile with: /EHsc
#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;functional&gt;
#include &lt;iostream&gt;

// The function object multiplies an element by a Factor
template &lt;class Type&gt;
class MultValue
{
   private:
      Type Factor;   // The value to multiply by
   public:
      // Constructor initializes the value to multiply by
      MultValue ( const Type&amp; val ) : Factor ( val ) {
      }

      // The function call for the element to be multiplied
      Type operator( ) ( Type&amp; elem ) const
      {
         return elem * Factor;
      }
};

int main()
{
   using namespace std;
   vector &lt;int&gt; v1, v2 ( 7 ), v3 ( 7 );
   vector &lt;int&gt;::iterator Iter1, Iter2 , Iter3;

   // Constructing vector v1
   int i;
   for ( i = -4 ; i &lt;= 2 ; i++ )
   {
      v1.push_back(  i );
   }

   cout &lt;&lt; &quot;Original vector  v1 = ( &quot; ;
   for ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ; Iter1++ )
      cout &lt;&lt; *Iter1 &lt;&lt; &quot; &quot;;
   cout &lt;&lt; &quot;).&quot; &lt;&lt; endl;

   // Modifying the vector v1 in place
   transform (v1.begin( ), v1.end( ), v1.begin( ), MultValue&lt;int&gt; ( 2 ) );
   cout &lt;&lt; &quot;The elements of the vector v1 multiplied by 2 in place gives:&quot;
        &lt;&lt; &quot;\n v1mod = ( &quot; ;
   for ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ; Iter1++ )
      cout &lt;&lt; *Iter1 &lt;&lt; &quot; &quot;;
   cout &lt;&lt; &quot;).&quot; &lt;&lt; endl;

   // Using transform to multiply each element by a factor of 5
   transform ( v1.begin( ), v1.end( ), v2.begin( ), MultValue&lt;int&gt; ( 5 ) );

   cout &lt;&lt; &quot;Multiplying the elements of the vector v1mod\n &quot;
        &lt;&lt;  &quot;by the factor 5 &amp; copying to v2 gives:\n v2 = ( &quot; ;
   for ( Iter2 = v2.begin( ) ; Iter2 != v2.end( ) ; Iter2++ )
      cout &lt;&lt; *Iter2 &lt;&lt; &quot; &quot;;
   cout &lt;&lt; &quot;).&quot; &lt;&lt; endl;

   // The second version of transform used to multiply the
   // elements of the vectors v1mod &amp; v2 pairwise
   transform ( v1.begin( ), v1.end( ),  v2.begin( ), v3.begin( ),
      multiplies &lt;int&gt;( ) );

   cout &lt;&lt; &quot;Multiplying elements of the vectors v1mod and v2 pairwise &quot;
        &lt;&lt;  &quot;gives:\n v3 = ( &quot; ;
   for ( Iter3 = v3.begin( ) ; Iter3 != v3.end( ) ; Iter3++ )
      cout &lt;&lt; *Iter3 &lt;&lt; &quot; &quot;;
   cout &lt;&lt; &quot;).&quot; &lt;&lt; endl;
}
"><span class="hljs-comment">// alg_transform.cpp</span>
<span class="hljs-comment">// compile with: /EHsc</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;functional&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span>

<span class="hljs-comment">// The function object multiplies an element by a Factor</span>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Type</span>&gt;
<span class="hljs-title">class</span> <span class="hljs-title">MultValue</span>
{</span>
   <span class="hljs-keyword">private</span>:
      Type Factor;   <span class="hljs-comment">// The value to multiply by</span>
   <span class="hljs-keyword">public</span>:
      <span class="hljs-comment">// Constructor initializes the value to multiply by</span>
      MultValue ( <span class="hljs-keyword">const</span> Type&amp; val ) : Factor ( val ) {
      }

      <span class="hljs-comment">// The function call for the element to be multiplied</span>
      <span class="hljs-function">Type <span class="hljs-title">operator</span><span class="hljs-params">( )</span> <span class="hljs-params">( Type&amp; elem )</span> <span class="hljs-keyword">const</span>
      </span>{
         <span class="hljs-keyword">return</span> elem * Factor;
      }
};

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
   <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;
   <span class="hljs-built_in">vector</span> &lt;<span class="hljs-keyword">int</span>&gt; v1, v2 ( <span class="hljs-number">7</span> ), v3 ( <span class="hljs-number">7</span> );
   <span class="hljs-built_in">vector</span> &lt;<span class="hljs-keyword">int</span>&gt;::iterator Iter1, Iter2 , Iter3;

   <span class="hljs-comment">// Constructing vector v1</span>
   <span class="hljs-keyword">int</span> i;
   <span class="hljs-keyword">for</span> ( i = <span class="hljs-number">-4</span> ; i &lt;= <span class="hljs-number">2</span> ; i++ )
   {
      v1.push_back(  i );
   }

   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Original vector  v1 = ( "</span> ;
   <span class="hljs-keyword">for</span> ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ; Iter1++ )
      <span class="hljs-built_in">cout</span> &lt;&lt; *Iter1 &lt;&lt; <span class="hljs-string">" "</span>;
   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">")."</span> &lt;&lt; <span class="hljs-built_in">endl</span>;

   <span class="hljs-comment">// Modifying the vector v1 in place</span>
   transform (v1.begin( ), v1.end( ), v1.begin( ), MultValue&lt;<span class="hljs-keyword">int</span>&gt; ( <span class="hljs-number">2</span> ) );
   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"The elements of the vector v1 multiplied by 2 in place gives:"</span>
        &lt;&lt; <span class="hljs-string">"\n v1mod = ( "</span> ;
   <span class="hljs-keyword">for</span> ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ; Iter1++ )
      <span class="hljs-built_in">cout</span> &lt;&lt; *Iter1 &lt;&lt; <span class="hljs-string">" "</span>;
   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">")."</span> &lt;&lt; <span class="hljs-built_in">endl</span>;

   <span class="hljs-comment">// Using transform to multiply each element by a factor of 5</span>
   transform ( v1.begin( ), v1.end( ), v2.begin( ), MultValue&lt;<span class="hljs-keyword">int</span>&gt; ( <span class="hljs-number">5</span> ) );

   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Multiplying the elements of the vector v1mod\n "</span>
        &lt;&lt;  <span class="hljs-string">"by the factor 5 &amp; copying to v2 gives:\n v2 = ( "</span> ;
   <span class="hljs-keyword">for</span> ( Iter2 = v2.begin( ) ; Iter2 != v2.end( ) ; Iter2++ )
      <span class="hljs-built_in">cout</span> &lt;&lt; *Iter2 &lt;&lt; <span class="hljs-string">" "</span>;
   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">")."</span> &lt;&lt; <span class="hljs-built_in">endl</span>;

   <span class="hljs-comment">// The second version of transform used to multiply the</span>
   <span class="hljs-comment">// elements of the vectors v1mod &amp; v2 pairwise</span>
   transform ( v1.begin( ), v1.end( ),  v2.begin( ), v3.begin( ),
      multiplies &lt;<span class="hljs-keyword">int</span>&gt;( ) );

   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Multiplying elements of the vectors v1mod and v2 pairwise "</span>
        &lt;&lt;  <span class="hljs-string">"gives:\n v3 = ( "</span> ;
   <span class="hljs-keyword">for</span> ( Iter3 = v3.begin( ) ; Iter3 != v3.end( ) ; Iter3++ )
      <span class="hljs-built_in">cout</span> &lt;&lt; *Iter3 &lt;&lt; <span class="hljs-string">" "</span>;
   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">")."</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
}
</code></pre>
<div class="codeHeader" id="code-try-170" data-bi-name="code-header"><span class="language">Output</span>
			<button class="action" data-bi-name="copy">
				<span class="docon docon-edit-copy" role="presentation"></span>
				<span>Copy</span>
			</button></div><pre><code class="lang-Output" data-author-content="Original vector  v1 = ( -4 -3 -2 -1 0 1 2 ).
The elements of the vector v1 multiplied by 2 in place gives:
v1mod = ( -8 -6 -4 -2 0 2 4 ).
Multiplying the elements of the vector v1mod
by the factor 5 &amp; copying to v2 gives:
v2 = ( -40 -30 -20 -10 0 10 20 ).
Multiplying elements of the vectors v1mod and v2 pairwise gives:
v3 = ( 320 180 80 20 0 20 80 ).
">Original vector  v1 = ( -4 -3 -2 -1 0 1 2 ).
The elements of the vector v1 multiplied by 2 in place gives:
v1mod = ( -8 -6 -4 -2 0 2 4 ).
Multiplying the elements of the vector v1mod
by the factor 5 &amp; copying to v2 gives:
v2 = ( -40 -30 -20 -10 0 10 20 ).
Multiplying elements of the vectors v1mod and v2 pairwise gives:
v3 = ( 320 180 80 20 0 20 80 ).
</code></pre>
<h2 id="unique" class="heading-with-anchor">  unique<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#unique"></a></h2>
<p>Removes duplicate elements that are adjacent to each other in a specified range.</p>
<div class="codeHeader" id="code-try-171" data-bi-name="code-header"><span class="language">C++</span>
			<button class="action" data-bi-name="copy">
				<span class="docon docon-edit-copy" role="presentation"></span>
				<span>Copy</span>
			</button></div><pre><code class="lang-cpp" data-author-content="template&lt;class ForwardIterator&gt;
   ForwardIterator unique(
      ForwardIterator first,
      ForwardIterator last);

template&lt;class ForwardIterator, class Predicate&gt;
   ForwardIterator unique(
      ForwardIterator first,
      ForwardIterator last,
      Predicate comp);
"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ForwardIterator</span>&gt;
   <span class="hljs-title">ForwardIterator</span> <span class="hljs-title">unique</span>(
      <span class="hljs-title">ForwardIterator</span> <span class="hljs-title">first</span>,
      <span class="hljs-title">ForwardIterator</span> <span class="hljs-title">last</span>);</span>

<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ForwardIterator</span>, <span class="hljs-title">class</span> <span class="hljs-title">Predicate</span>&gt;
   <span class="hljs-title">ForwardIterator</span> <span class="hljs-title">unique</span>(
      <span class="hljs-title">ForwardIterator</span> <span class="hljs-title">first</span>,
      <span class="hljs-title">ForwardIterator</span> <span class="hljs-title">last</span>,
      <span class="hljs-title">Predicate</span> <span class="hljs-title">comp</span>);</span>
</code></pre>
<h3 id="parameters-81" class="heading-with-anchor">Parameters<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#parameters-81"></a></h3>
<p><em>first</em><br>
A forward iterator addressing the position of the first element in the range to be scanned for duplicate removal.</p>
<p><em>last</em><br>
A forward iterator addressing the position one past the final element in the range to be scanned for duplicate removal.</p>
<p><em>comp</em><br>
User-defined predicate function object that defines the condition to be satisfied if two elements are to be taken as equivalent. A binary predicate takes two arguments and returns <strong>true</strong> when satisfied and <strong>false</strong> when not satisfied.</p>
<h3 id="return-value-57" class="heading-with-anchor">Return Value<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#return-value-57"></a></h3>
<p>A forward iterator to the new end of the modified sequence that contains no consecutive duplicates, addressing the position one past the last element not removed.</p>
<h3 id="remarks-81" class="heading-with-anchor">Remarks<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#remarks-81"></a></h3>
<p>Both forms of the algorithm remove the second duplicate of a consecutive pair of equal elements.</p>
<p>The operation of the algorithm is stable so that the relative order of the undeleted elements is not changed.</p>
<p>The range referenced must be valid; all pointers must be dereferenceable and within the sequence the last position is reachable from the first by incrementation. he number of elements in the sequence is not changed by the algorithm <code>unique</code> and the elements beyond the end of the modified sequence are dereferenceable but not specified.</p>
<p>The complexity is linear, requiring (<code>last</code> - <code>first</code>) - 1 comparisons.</p>
<p>List provides a more efficient member function "unique", which may perform better.</p>
<p>These algorithms cannot be used on an associative container.</p>
<h3 id="example-62" class="heading-with-anchor">Example<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#example-62"></a></h3>
<div class="codeHeader" id="code-try-172" data-bi-name="code-header"><span class="language">C++</span>
			<button class="action" data-bi-name="copy">
				<span class="docon docon-edit-copy" role="presentation"></span>
				<span>Copy</span>
			</button></div><pre><code class="lang-cpp" data-author-content="// alg_unique.cpp
// compile with: /EHsc
#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;functional&gt;
#include &lt;iostream&gt;
#include &lt;ostream&gt;

using namespace std;

// Return whether modulus of elem1 is equal to modulus of elem2
bool mod_equal ( int elem1, int elem2 )
{
   if ( elem1 &lt; 0 )
      elem1 = - elem1;
   if ( elem2 &lt; 0 )
      elem2 = - elem2;
   return elem1 == elem2;
};

int main()
{
   vector &lt;int&gt; v1;
   vector &lt;int&gt;::iterator v1_Iter1, v1_Iter2, v1_Iter3,
         v1_NewEnd1, v1_NewEnd2, v1_NewEnd3;

   int i;
   for ( i = 0 ; i &lt;= 3 ; i++ )
   {
      v1.push_back( 5 );
      v1.push_back( -5 );
   }

   int ii;
   for ( ii = 0 ; ii &lt;= 3 ; ii++ )
   {
      v1.push_back( 4 );
   }
   v1.push_back( 7 );

   cout &lt;&lt; &quot;Vector v1 is ( &quot; ;
   for ( v1_Iter1 = v1.begin( ) ; v1_Iter1 != v1.end( ) ; v1_Iter1++ )
      cout &lt;&lt; *v1_Iter1 &lt;&lt; &quot; &quot;;
   cout &lt;&lt; &quot;).&quot; &lt;&lt; endl;

   // Remove consecutive duplicates
   v1_NewEnd1 = unique ( v1.begin( ), v1.end( ) );

   cout &lt;&lt; &quot;Removing adjacent duplicates from vector v1 gives\n ( &quot; ;
   for ( v1_Iter1 = v1.begin( ) ; v1_Iter1 != v1_NewEnd1 ; v1_Iter1++ )
      cout &lt;&lt; *v1_Iter1 &lt;&lt; &quot; &quot;;
   cout &lt;&lt; &quot;).&quot; &lt;&lt; endl;

   // Remove consecutive duplicates under the binary prediate mod_equals
   v1_NewEnd2 = unique ( v1.begin( ), v1_NewEnd1 , mod_equal );

   cout &lt;&lt; &quot;Removing adjacent duplicates from vector v1 under the\n &quot;
        &lt;&lt; &quot; binary predicate mod_equal gives\n ( &quot; ;
   for ( v1_Iter2 = v1.begin( ) ; v1_Iter2 != v1_NewEnd2 ; v1_Iter2++ )
      cout &lt;&lt; *v1_Iter2 &lt;&lt; &quot; &quot;;
   cout &lt;&lt; &quot;).&quot; &lt;&lt; endl;

   // Remove elements if preceded by an element that was greater
   v1_NewEnd3 = unique ( v1.begin( ), v1_NewEnd2, greater&lt;int&gt;( ) );

   cout &lt;&lt; &quot;Removing adjacent elements satisfying the binary\n &quot;
        &lt;&lt; &quot; predicate mod_equal from vector v1 gives ( &quot; ;
   for ( v1_Iter3 = v1.begin( ) ; v1_Iter3 != v1_NewEnd3 ; v1_Iter3++ )
      cout &lt;&lt; *v1_Iter3 &lt;&lt; &quot; &quot;;
   cout &lt;&lt; &quot;).&quot; &lt;&lt; endl;
}
"><span class="hljs-comment">// alg_unique.cpp</span>
<span class="hljs-comment">// compile with: /EHsc</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;functional&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;ostream&gt;</span></span>

<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;

<span class="hljs-comment">// Return whether modulus of elem1 is equal to modulus of elem2</span>
<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">mod_equal</span> <span class="hljs-params">( <span class="hljs-keyword">int</span> elem1, <span class="hljs-keyword">int</span> elem2 )</span>
</span>{
   <span class="hljs-keyword">if</span> ( elem1 &lt; <span class="hljs-number">0</span> )
      elem1 = - elem1;
   <span class="hljs-keyword">if</span> ( elem2 &lt; <span class="hljs-number">0</span> )
      elem2 = - elem2;
   <span class="hljs-keyword">return</span> elem1 == elem2;
};

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
   <span class="hljs-built_in">vector</span> &lt;<span class="hljs-keyword">int</span>&gt; v1;
   <span class="hljs-built_in">vector</span> &lt;<span class="hljs-keyword">int</span>&gt;::iterator v1_Iter1, v1_Iter2, v1_Iter3,
         v1_NewEnd1, v1_NewEnd2, v1_NewEnd3;

   <span class="hljs-keyword">int</span> i;
   <span class="hljs-keyword">for</span> ( i = <span class="hljs-number">0</span> ; i &lt;= <span class="hljs-number">3</span> ; i++ )
   {
      v1.push_back( <span class="hljs-number">5</span> );
      v1.push_back( <span class="hljs-number">-5</span> );
   }

   <span class="hljs-keyword">int</span> ii;
   <span class="hljs-keyword">for</span> ( ii = <span class="hljs-number">0</span> ; ii &lt;= <span class="hljs-number">3</span> ; ii++ )
   {
      v1.push_back( <span class="hljs-number">4</span> );
   }
   v1.push_back( <span class="hljs-number">7</span> );

   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Vector v1 is ( "</span> ;
   <span class="hljs-keyword">for</span> ( v1_Iter1 = v1.begin( ) ; v1_Iter1 != v1.end( ) ; v1_Iter1++ )
      <span class="hljs-built_in">cout</span> &lt;&lt; *v1_Iter1 &lt;&lt; <span class="hljs-string">" "</span>;
   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">")."</span> &lt;&lt; <span class="hljs-built_in">endl</span>;

   <span class="hljs-comment">// Remove consecutive duplicates</span>
   v1_NewEnd1 = unique ( v1.begin( ), v1.end( ) );

   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Removing adjacent duplicates from vector v1 gives\n ( "</span> ;
   <span class="hljs-keyword">for</span> ( v1_Iter1 = v1.begin( ) ; v1_Iter1 != v1_NewEnd1 ; v1_Iter1++ )
      <span class="hljs-built_in">cout</span> &lt;&lt; *v1_Iter1 &lt;&lt; <span class="hljs-string">" "</span>;
   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">")."</span> &lt;&lt; <span class="hljs-built_in">endl</span>;

   <span class="hljs-comment">// Remove consecutive duplicates under the binary prediate mod_equals</span>
   v1_NewEnd2 = unique ( v1.begin( ), v1_NewEnd1 , mod_equal );

   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Removing adjacent duplicates from vector v1 under the\n "</span>
        &lt;&lt; <span class="hljs-string">" binary predicate mod_equal gives\n ( "</span> ;
   <span class="hljs-keyword">for</span> ( v1_Iter2 = v1.begin( ) ; v1_Iter2 != v1_NewEnd2 ; v1_Iter2++ )
      <span class="hljs-built_in">cout</span> &lt;&lt; *v1_Iter2 &lt;&lt; <span class="hljs-string">" "</span>;
   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">")."</span> &lt;&lt; <span class="hljs-built_in">endl</span>;

   <span class="hljs-comment">// Remove elements if preceded by an element that was greater</span>
   v1_NewEnd3 = unique ( v1.begin( ), v1_NewEnd2, greater&lt;<span class="hljs-keyword">int</span>&gt;( ) );

   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Removing adjacent elements satisfying the binary\n "</span>
        &lt;&lt; <span class="hljs-string">" predicate mod_equal from vector v1 gives ( "</span> ;
   <span class="hljs-keyword">for</span> ( v1_Iter3 = v1.begin( ) ; v1_Iter3 != v1_NewEnd3 ; v1_Iter3++ )
      <span class="hljs-built_in">cout</span> &lt;&lt; *v1_Iter3 &lt;&lt; <span class="hljs-string">" "</span>;
   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">")."</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
}
</code></pre>
<div class="codeHeader" id="code-try-173" data-bi-name="code-header"><span class="language">Output</span>
			<button class="action" data-bi-name="copy">
				<span class="docon docon-edit-copy" role="presentation"></span>
				<span>Copy</span>
			</button></div><pre><code class="lang-Output" data-author-content="Vector v1 is ( 5 -5 5 -5 5 -5 5 -5 4 4 4 4 7 ).
Removing adjacent duplicates from vector v1 gives
( 5 -5 5 -5 5 -5 5 -5 4 7 ).
Removing adjacent duplicates from vector v1 under the
  binary predicate mod_equal gives
( 5 4 7 ).
Removing adjacent elements satisfying the binary
  predicate mod_equal from vector v1 gives ( 5 7 ).
">Vector v1 is ( 5 -5 5 -5 5 -5 5 -5 4 4 4 4 7 ).
Removing adjacent duplicates from vector v1 gives
( 5 -5 5 -5 5 -5 5 -5 4 7 ).
Removing adjacent duplicates from vector v1 under the
  binary predicate mod_equal gives
( 5 4 7 ).
Removing adjacent elements satisfying the binary
  predicate mod_equal from vector v1 gives ( 5 7 ).
</code></pre>
<h2 id="unique_copy" class="heading-with-anchor">  unique_copy<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#unique_copy"></a></h2>
<p>Copies elements from a source range into a destination range except for the duplicate elements that are adjacent to each other.</p>
<div class="codeHeader" id="code-try-174" data-bi-name="code-header"><span class="language">C++</span>
			<button class="action" data-bi-name="copy">
				<span class="docon docon-edit-copy" role="presentation"></span>
				<span>Copy</span>
			</button></div><pre><code class="lang-cpp" data-author-content="template&lt;class InputIterator, class OutputIterator&gt;
OutputIterator unique_copy( InputIterator first,
    InputIterator last,
    OutputIterator result );

template&lt;class InputIterator, class OutputIterator, class BinaryPredicate&gt;
OutputIterator unique_copy( InputIterator first,
    InputIterator last,
    OutputIterator result,
    BinaryPredicate comp );
"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InputIterator</span>, <span class="hljs-title">class</span> <span class="hljs-title">OutputIterator</span>&gt;
<span class="hljs-title">OutputIterator</span> <span class="hljs-title">unique_copy</span>( <span class="hljs-title">InputIterator</span> <span class="hljs-title">first</span>,
    <span class="hljs-title">InputIterator</span> <span class="hljs-title">last</span>,
    <span class="hljs-title">OutputIterator</span> <span class="hljs-title">result</span> );</span>

<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InputIterator</span>, <span class="hljs-title">class</span> <span class="hljs-title">OutputIterator</span>, <span class="hljs-title">class</span> <span class="hljs-title">BinaryPredicate</span>&gt;
<span class="hljs-title">OutputIterator</span> <span class="hljs-title">unique_copy</span>( <span class="hljs-title">InputIterator</span> <span class="hljs-title">first</span>,
    <span class="hljs-title">InputIterator</span> <span class="hljs-title">last</span>,
    <span class="hljs-title">OutputIterator</span> <span class="hljs-title">result</span>,
    <span class="hljs-title">BinaryPredicate</span> <span class="hljs-title">comp</span> );</span>
</code></pre>
<h3 id="parameters-82" class="heading-with-anchor">Parameters<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#parameters-82"></a></h3>
<p><em>first</em><br>
A forward iterator addressing the position of the first element in the source range to be copied.</p>
<p><em>last</em><br>
A forward iterator addressing the position one past the final element in the source range to be copied.</p>
<p><em>result</em><br>
An output iterator addressing the position of the first element in the destination range that is receiving the copy with consecutive duplicates removed.</p>
<p><em>comp</em><br>
User-defined predicate function object that defines the condition to be satisfied if two elements are to be taken as equivalent. A binary predicate takes two arguments and returns <strong>true</strong> when satisfied and <strong>false</strong> when not satisfied.</p>
<h3 id="return-value-58" class="heading-with-anchor">Return Value<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#return-value-58"></a></h3>
<p>An output iterator addressing the position one past the final element in the destination range that is receiving the copy with consecutive duplicates removed.</p>
<h3 id="remarks-82" class="heading-with-anchor">Remarks<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#remarks-82"></a></h3>
<p>Both forms of the algorithm remove the second duplicate of a consecutive pair of equal elements.</p>
<p>The operation of the algorithm is stable so that the relative order of the undeleted elements is not changed.</p>
<p>The ranges referenced must be valid; all pointers must be dereferenceable and within a sequence the last position is reachable from the first by incrementation.</p>
<p>The complexity is linear, requiring (<code>last</code> - <code>first</code>) comparisons.</p>
<h3 id="example-63" class="heading-with-anchor">Example<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#example-63"></a></h3>
<div class="codeHeader" id="code-try-175" data-bi-name="code-header"><span class="language">C++</span>
			<button class="action" data-bi-name="copy">
				<span class="docon docon-edit-copy" role="presentation"></span>
				<span>Copy</span>
			</button></div><pre><code class="lang-cpp" data-author-content="// alg_unique_copy.cpp
// compile with: /EHsc
#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;functional&gt;
#include &lt;iostream&gt;
#include &lt;ostream&gt;

using namespace std;

// Return whether modulus of elem1 is equal to modulus of elem2
bool mod_equal ( int elem1, int elem2 ) {
   if ( elem1 &lt; 0 )
      elem1 = - elem1;
   if ( elem2 &lt; 0 )
      elem2 = - elem2;
   return elem1 == elem2;
};

int main() {
   vector &lt;int&gt; v1;
   vector &lt;int&gt;::iterator v1_Iter1, v1_Iter2,
         v1_NewEnd1, v1_NewEnd2;

   int i;
   for ( i = 0 ; i &lt;= 1 ; i++ ) {
      v1.push_back( 5 );
      v1.push_back( -5 );
   }

   int ii;
   for ( ii = 0 ; ii &lt;= 2 ; ii++ )
      v1.push_back( 4 );
   v1.push_back( 7 );

   int iii;
   for ( iii = 0 ; iii &lt;= 5 ; iii++ )
      v1.push_back( 10 );

   cout &lt;&lt; &quot;Vector v1 is\n ( &quot; ;
   for ( v1_Iter1 = v1.begin( ) ; v1_Iter1 != v1.end( ) ; v1_Iter1++ )
      cout &lt;&lt; *v1_Iter1 &lt;&lt; &quot; &quot;;
   cout &lt;&lt; &quot;).&quot; &lt;&lt; endl;

   // Copy first half to second, removing consecutive duplicates
   v1_NewEnd1 = unique_copy ( v1.begin( ), v1.begin( ) + 8, v1.begin( ) + 8 );

   cout &lt;&lt; &quot;Copying the first half of the vector to the second half\n &quot;
        &lt;&lt; &quot;while removing adjacent duplicates gives\n ( &quot; ;
   for ( v1_Iter1 = v1.begin( ) ; v1_Iter1 != v1_NewEnd1 ; v1_Iter1++ )
      cout &lt;&lt; *v1_Iter1 &lt;&lt; &quot; &quot;;
   cout &lt;&lt; &quot;).&quot; &lt;&lt; endl;

   int iv;
   for ( iv = 0 ; iv &lt;= 7 ; iv++ )
      v1.push_back( 10 );

   // Remove consecutive duplicates under the binary prediate mod_equals
   v1_NewEnd2 = unique_copy ( v1.begin( ), v1.begin( ) + 14,
      v1.begin( ) + 14 , mod_equal );

   cout &lt;&lt; &quot;Copying the first half of the vector to the second half\n &quot;
        &lt;&lt; &quot; removing adjacent duplicates under mod_equals gives\n ( &quot; ;
   for ( v1_Iter2 = v1.begin( ) ; v1_Iter2 != v1_NewEnd2 ; v1_Iter2++ )
      cout &lt;&lt; *v1_Iter2 &lt;&lt; &quot; &quot;;
   cout &lt;&lt; &quot;).&quot; &lt;&lt; endl;
}
"><span class="hljs-comment">// alg_unique_copy.cpp</span>
<span class="hljs-comment">// compile with: /EHsc</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;functional&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;ostream&gt;</span></span>

<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;

<span class="hljs-comment">// Return whether modulus of elem1 is equal to modulus of elem2</span>
<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">mod_equal</span> <span class="hljs-params">( <span class="hljs-keyword">int</span> elem1, <span class="hljs-keyword">int</span> elem2 )</span> </span>{
   <span class="hljs-keyword">if</span> ( elem1 &lt; <span class="hljs-number">0</span> )
      elem1 = - elem1;
   <span class="hljs-keyword">if</span> ( elem2 &lt; <span class="hljs-number">0</span> )
      elem2 = - elem2;
   <span class="hljs-keyword">return</span> elem1 == elem2;
};

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
   <span class="hljs-built_in">vector</span> &lt;<span class="hljs-keyword">int</span>&gt; v1;
   <span class="hljs-built_in">vector</span> &lt;<span class="hljs-keyword">int</span>&gt;::iterator v1_Iter1, v1_Iter2,
         v1_NewEnd1, v1_NewEnd2;

   <span class="hljs-keyword">int</span> i;
   <span class="hljs-keyword">for</span> ( i = <span class="hljs-number">0</span> ; i &lt;= <span class="hljs-number">1</span> ; i++ ) {
      v1.push_back( <span class="hljs-number">5</span> );
      v1.push_back( <span class="hljs-number">-5</span> );
   }

   <span class="hljs-keyword">int</span> ii;
   <span class="hljs-keyword">for</span> ( ii = <span class="hljs-number">0</span> ; ii &lt;= <span class="hljs-number">2</span> ; ii++ )
      v1.push_back( <span class="hljs-number">4</span> );
   v1.push_back( <span class="hljs-number">7</span> );

   <span class="hljs-keyword">int</span> iii;
   <span class="hljs-keyword">for</span> ( iii = <span class="hljs-number">0</span> ; iii &lt;= <span class="hljs-number">5</span> ; iii++ )
      v1.push_back( <span class="hljs-number">10</span> );

   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Vector v1 is\n ( "</span> ;
   <span class="hljs-keyword">for</span> ( v1_Iter1 = v1.begin( ) ; v1_Iter1 != v1.end( ) ; v1_Iter1++ )
      <span class="hljs-built_in">cout</span> &lt;&lt; *v1_Iter1 &lt;&lt; <span class="hljs-string">" "</span>;
   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">")."</span> &lt;&lt; <span class="hljs-built_in">endl</span>;

   <span class="hljs-comment">// Copy first half to second, removing consecutive duplicates</span>
   v1_NewEnd1 = unique_copy ( v1.begin( ), v1.begin( ) + <span class="hljs-number">8</span>, v1.begin( ) + <span class="hljs-number">8</span> );

   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Copying the first half of the vector to the second half\n "</span>
        &lt;&lt; <span class="hljs-string">"while removing adjacent duplicates gives\n ( "</span> ;
   <span class="hljs-keyword">for</span> ( v1_Iter1 = v1.begin( ) ; v1_Iter1 != v1_NewEnd1 ; v1_Iter1++ )
      <span class="hljs-built_in">cout</span> &lt;&lt; *v1_Iter1 &lt;&lt; <span class="hljs-string">" "</span>;
   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">")."</span> &lt;&lt; <span class="hljs-built_in">endl</span>;

   <span class="hljs-keyword">int</span> iv;
   <span class="hljs-keyword">for</span> ( iv = <span class="hljs-number">0</span> ; iv &lt;= <span class="hljs-number">7</span> ; iv++ )
      v1.push_back( <span class="hljs-number">10</span> );

   <span class="hljs-comment">// Remove consecutive duplicates under the binary prediate mod_equals</span>
   v1_NewEnd2 = unique_copy ( v1.begin( ), v1.begin( ) + <span class="hljs-number">14</span>,
      v1.begin( ) + <span class="hljs-number">14</span> , mod_equal );

   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Copying the first half of the vector to the second half\n "</span>
        &lt;&lt; <span class="hljs-string">" removing adjacent duplicates under mod_equals gives\n ( "</span> ;
   <span class="hljs-keyword">for</span> ( v1_Iter2 = v1.begin( ) ; v1_Iter2 != v1_NewEnd2 ; v1_Iter2++ )
      <span class="hljs-built_in">cout</span> &lt;&lt; *v1_Iter2 &lt;&lt; <span class="hljs-string">" "</span>;
   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">")."</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
}
</code></pre>
<h2 id="upper_bound" class="heading-with-anchor">  upper_bound<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#upper_bound"></a></h2>
<p>Finds the position of the first element in an ordered range that has a value that is greater than a specified value, where the ordering criterion may be specified by a binary predicate.</p>
<div class="codeHeader" id="code-try-176" data-bi-name="code-header"><span class="language">C++</span>
			<button class="action" data-bi-name="copy">
				<span class="docon docon-edit-copy" role="presentation"></span>
				<span>Copy</span>
			</button></div><pre><code class="lang-cpp" data-author-content="template&lt;class ForwardIterator, class Type&gt;
   ForwardIterator upper_bound(
      ForwardIterator first,
      ForwardIterator last,
      const Type&amp; value);

template&lt;class ForwardIterator, class Type, class Predicate&gt;
   ForwardIterator upper_bound(
      ForwardIterator first,
      ForwardIterator last,
      const Type&amp; value,
      Predicate comp);
"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ForwardIterator</span>, <span class="hljs-title">class</span> <span class="hljs-title">Type</span>&gt;
   <span class="hljs-title">ForwardIterator</span> <span class="hljs-title">upper_bound</span>(
      <span class="hljs-title">ForwardIterator</span> <span class="hljs-title">first</span>,
      <span class="hljs-title">ForwardIterator</span> <span class="hljs-title">last</span>,
      <span class="hljs-title">const</span> <span class="hljs-title">Type</span>&amp; <span class="hljs-title">value</span>);</span>

<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ForwardIterator</span>, <span class="hljs-title">class</span> <span class="hljs-title">Type</span>, <span class="hljs-title">class</span> <span class="hljs-title">Predicate</span>&gt;
   <span class="hljs-title">ForwardIterator</span> <span class="hljs-title">upper_bound</span>(
      <span class="hljs-title">ForwardIterator</span> <span class="hljs-title">first</span>,
      <span class="hljs-title">ForwardIterator</span> <span class="hljs-title">last</span>,
      <span class="hljs-title">const</span> <span class="hljs-title">Type</span>&amp; <span class="hljs-title">value</span>,
      <span class="hljs-title">Predicate</span> <span class="hljs-title">comp</span>);</span>
</code></pre>
<h3 id="parameters-83" class="heading-with-anchor">Parameters<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#parameters-83"></a></h3>
<p><em>first</em><br>
The position of the first element in the range to be searched.</p>
<p><em>last</em><br>
The position one past the final element in the range to be searched.</p>
<p><em>value</em><br>
The value in the ordered range that needs to be exceeded by the value of the element addressed by the iterator returned.</p>
<p><em>comp</em><br>
User-defined predicate function object that defines sense in which one element is less than another. A binary predicate takes two arguments and returns <strong>true</strong> when satisfied and <strong>false</strong> when not satisfied.</p>
<h3 id="return-value-59" class="heading-with-anchor">Return Value<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#return-value-59"></a></h3>
<p>A forward iterator to the position of the first element that has a value greater than a specified value.</p>
<h3 id="remarks-83" class="heading-with-anchor">Remarks<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#remarks-83"></a></h3>
<p>The sorted source range referenced must be valid; all iterators must be dereferenceable and within the sequence the last position must be reachable from the first by incrementation.</p>
<p>A sorted range is a precondition of the use of <code>upper_bound</code> and where the ordering criterion is the same as specified by the binary predicate.</p>
<p>The range is not modified by <code>upper_bound</code>.</p>
<p>The value types of the forward iterators need be less-than comparable to be ordered, so that, given two elements, it may be determined either that they are equivalent (in the sense that neither is less than the other) or that one is less than the other. This results in an ordering between the nonequivalent elements</p>
<p>The complexity of the algorithm is logarithmic for random-access iterators and linear otherwise, with the number of steps proportional to (<code>last - first</code>).</p>
<h3 id="example-64" class="heading-with-anchor">Example<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#example-64"></a></h3>
<div class="codeHeader" id="code-try-177" data-bi-name="code-header"><span class="language">C++</span>
			<button class="action" data-bi-name="copy">
				<span class="docon docon-edit-copy" role="presentation"></span>
				<span>Copy</span>
			</button></div><pre><code class="lang-cpp" data-author-content="// alg_upper_bound.cpp
// compile with: /EHsc
#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;functional&gt;      // greater&lt;int&gt;( )
#include &lt;iostream&gt;

// Return whether modulus of elem1 is less than modulus of elem2
bool mod_lesser( int elem1, int elem2 )
{
    if ( elem1 &lt; 0 )
        elem1 = - elem1;
    if ( elem2 &lt; 0 )
        elem2 = - elem2;
    return elem1 &lt; elem2;
}

int main()
{
    using namespace std;

    vector&lt;int&gt; v1;
    // Constructing vector v1 with default less-than ordering
    for ( auto i = -1 ; i &lt;= 4 ; ++i )
    {
        v1.push_back(  i );
    }

    for ( auto ii =-3 ; ii &lt;= 0 ; ++ii )
    {
        v1.push_back(  ii  );
    }

    cout &lt;&lt; &quot;Starting vector v1 = ( &quot; ;
    for (const auto &amp;Iter : v1)
        cout &lt;&lt; Iter &lt;&lt; &quot; &quot;;
    cout &lt;&lt; &quot;).&quot; &lt;&lt; endl;

    sort(v1.begin(), v1.end());
    cout &lt;&lt; &quot;Original vector v1 with range sorted by the\n &quot;
        &lt;&lt; &quot;binary predicate less than is v1 = ( &quot; ;
    for (const auto &amp;Iter : v1)
        cout &lt;&lt; Iter &lt;&lt; &quot; &quot;;
    cout &lt;&lt; &quot;).&quot; &lt;&lt; endl;

    // Constructing vector v2 with range sorted by greater
    vector&lt;int&gt; v2(v1);

    sort(v2.begin(), v2.end(), greater&lt;int&gt;());

    cout &lt;&lt; &quot;Original vector v2 with range sorted by the\n &quot;
        &lt;&lt; &quot;binary predicate greater is v2 = ( &quot; ;
    for (const auto &amp;Iter : v2)
        cout &lt;&lt; Iter &lt;&lt; &quot; &quot;;
    cout &lt;&lt; &quot;).&quot; &lt;&lt; endl;

    // Constructing vectors v3 with range sorted by mod_lesser
    vector&lt;int&gt; v3(v1);
    sort(v3.begin(), v3.end(), mod_lesser);

    cout &lt;&lt; &quot;Original vector v3 with range sorted by the\n &quot;
        &lt;&lt;  &quot;binary predicate mod_lesser is v3 = ( &quot; ;
    for (const auto &amp;Iter : v3)
        cout &lt;&lt; Iter &lt;&lt; &quot; &quot;;
    cout &lt;&lt; &quot;).&quot; &lt;&lt; endl;

    // Demonstrate upper_bound

    vector&lt;int&gt;::iterator Result;

    // upper_bound of 3 in v1 with default binary predicate less&lt;int&gt;()
    Result = upper_bound(v1.begin(), v1.end(), 3);
    cout &lt;&lt; &quot;The upper_bound in v1 for the element with a value of 3 is: &quot;
        &lt;&lt; *Result &lt;&lt; &quot;.&quot; &lt;&lt; endl;

    // upper_bound of 3 in v2 with the binary predicate greater&lt;int&gt;( )
    Result = upper_bound(v2.begin(), v2.end(), 3, greater&lt;int&gt;());
    cout &lt;&lt; &quot;The upper_bound in v2 for the element with a value of 3 is: &quot;
        &lt;&lt; *Result &lt;&lt; &quot;.&quot; &lt;&lt; endl;

    // upper_bound of 3 in v3 with the binary predicate  mod_lesser
    Result = upper_bound(v3.begin(), v3.end(), 3,  mod_lesser);
    cout &lt;&lt; &quot;The upper_bound in v3 for the element with a value of 3 is: &quot;
        &lt;&lt; *Result &lt;&lt; &quot;.&quot; &lt;&lt; endl;
}
"><span class="hljs-comment">// alg_upper_bound.cpp</span>
<span class="hljs-comment">// compile with: /EHsc</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;functional&gt;      // greater&lt;int&gt;( )</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span>

<span class="hljs-comment">// Return whether modulus of elem1 is less than modulus of elem2</span>
<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">mod_lesser</span><span class="hljs-params">( <span class="hljs-keyword">int</span> elem1, <span class="hljs-keyword">int</span> elem2 )</span>
</span>{
    <span class="hljs-keyword">if</span> ( elem1 &lt; <span class="hljs-number">0</span> )
        elem1 = - elem1;
    <span class="hljs-keyword">if</span> ( elem2 &lt; <span class="hljs-number">0</span> )
        elem2 = - elem2;
    <span class="hljs-keyword">return</span> elem1 &lt; elem2;
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;

    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; v1;
    <span class="hljs-comment">// Constructing vector v1 with default less-than ordering</span>
    <span class="hljs-keyword">for</span> ( <span class="hljs-keyword">auto</span> i = <span class="hljs-number">-1</span> ; i &lt;= <span class="hljs-number">4</span> ; ++i )
    {
        v1.push_back(  i );
    }

    <span class="hljs-keyword">for</span> ( <span class="hljs-keyword">auto</span> ii =<span class="hljs-number">-3</span> ; ii &lt;= <span class="hljs-number">0</span> ; ++ii )
    {
        v1.push_back(  ii  );
    }

    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Starting vector v1 = ( "</span> ;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> &amp;Iter : v1)
        <span class="hljs-built_in">cout</span> &lt;&lt; Iter &lt;&lt; <span class="hljs-string">" "</span>;
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">")."</span> &lt;&lt; <span class="hljs-built_in">endl</span>;

    sort(v1.begin(), v1.end());
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Original vector v1 with range sorted by the\n "</span>
        &lt;&lt; <span class="hljs-string">"binary predicate less than is v1 = ( "</span> ;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> &amp;Iter : v1)
        <span class="hljs-built_in">cout</span> &lt;&lt; Iter &lt;&lt; <span class="hljs-string">" "</span>;
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">")."</span> &lt;&lt; <span class="hljs-built_in">endl</span>;

    <span class="hljs-comment">// Constructing vector v2 with range sorted by greater</span>
    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; v2(v1);

    sort(v2.begin(), v2.end(), greater&lt;<span class="hljs-keyword">int</span>&gt;());

    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Original vector v2 with range sorted by the\n "</span>
        &lt;&lt; <span class="hljs-string">"binary predicate greater is v2 = ( "</span> ;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> &amp;Iter : v2)
        <span class="hljs-built_in">cout</span> &lt;&lt; Iter &lt;&lt; <span class="hljs-string">" "</span>;
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">")."</span> &lt;&lt; <span class="hljs-built_in">endl</span>;

    <span class="hljs-comment">// Constructing vectors v3 with range sorted by mod_lesser</span>
    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; v3(v1);
    sort(v3.begin(), v3.end(), mod_lesser);

    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Original vector v3 with range sorted by the\n "</span>
        &lt;&lt;  <span class="hljs-string">"binary predicate mod_lesser is v3 = ( "</span> ;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> &amp;Iter : v3)
        <span class="hljs-built_in">cout</span> &lt;&lt; Iter &lt;&lt; <span class="hljs-string">" "</span>;
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">")."</span> &lt;&lt; <span class="hljs-built_in">endl</span>;

    <span class="hljs-comment">// Demonstrate upper_bound</span>

    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;::iterator Result;

    <span class="hljs-comment">// upper_bound of 3 in v1 with default binary predicate less&lt;int&gt;()</span>
    Result = upper_bound(v1.begin(), v1.end(), <span class="hljs-number">3</span>);
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"The upper_bound in v1 for the element with a value of 3 is: "</span>
        &lt;&lt; *Result &lt;&lt; <span class="hljs-string">"."</span> &lt;&lt; <span class="hljs-built_in">endl</span>;

    <span class="hljs-comment">// upper_bound of 3 in v2 with the binary predicate greater&lt;int&gt;( )</span>
    Result = upper_bound(v2.begin(), v2.end(), <span class="hljs-number">3</span>, greater&lt;<span class="hljs-keyword">int</span>&gt;());
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"The upper_bound in v2 for the element with a value of 3 is: "</span>
        &lt;&lt; *Result &lt;&lt; <span class="hljs-string">"."</span> &lt;&lt; <span class="hljs-built_in">endl</span>;

    <span class="hljs-comment">// upper_bound of 3 in v3 with the binary predicate  mod_lesser</span>
    Result = upper_bound(v3.begin(), v3.end(), <span class="hljs-number">3</span>,  mod_lesser);
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"The upper_bound in v3 for the element with a value of 3 is: "</span>
        &lt;&lt; *Result &lt;&lt; <span class="hljs-string">"."</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
}
</code></pre>
<h2 id="see-also" class="heading-with-anchor">See also<a class="docon docon-link heading-anchor" tabindex="-1" aria-hidden="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#see-also"></a></h2>
<p><a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm?view=vs-2019" data-linktype="relative-path">&lt;algorithm&gt;</a><br></p>

						<!-- </content> -->

						</main>

						<!-- feedback section -->



<section class="feedback-section" data-bi-name="feedback-section">


	<h2 id="feedback">Feedback</h2>

	<div class="alert choose-feedback-type">
		<p id="send-feedback-about">Send feedback about:</p>

		<div class="choose-feedback-buttons">
			<a class="button feedback-type-product has-margin-bottom-small" aria-describedby="send-feedback-about" href="https://developercommunity.visualstudio.com/spaces/62/index.html" data-bi-name="product-feedback">
				<span>This product</span>
				<span class="icon docon docon-navigate-external" aria-hidden="true"></span>
			</a>

			<div class="field has-addons is-inline-flex has-margin-bottom-small">
				<div class="control has-margin-top-none has-margin-bottom-none">
					<button class="button feedback-sign-in-button has-text-wrap" aria-describedby="send-feedback-about" data-bi-name="feedback-sign-in">
						<span class="icon docon docon-brand-github" aria-hidden="true"></span>
						<span>This page</span>
					</button>
				</div>
				<div class="control dropdown has-caret has-margin-top-none has-margin-bottom-none" auto-align="">
					<button class="button dropdown-trigger is-full-height" aria-describedby="send-feedback-about" aria-haspopup="true" aria-expanded="false" aria-controls="fbm0" aria-label="Additional feedback options" data-bi-name="documentation-feedback-menu">
						<span class="icon docon docon-chevron-down-light" aria-hidden="true"></span>
					</button>
					<div id="fbm0" class="dropdown-menu documentation-feedback-menu">
						You may also leave feedback directly on <a data-bi-name="create-issue-on-github" href="https://github.com/MicrosoftDocs/cpp-docs/issues/new?title=&amp;body=%0A%0A%5BEnter%20feedback%20here%5D%0A%0A%0A---%0A%23%23%23%23%20Document%20Details%0A%0A%E2%9A%A0%20*Do%20not%20edit%20this%20section.%20It%20is%20required%20for%20docs.microsoft.com%20%E2%9E%9F%20GitHub%20issue%20linking.*%0A%0A*%20ID%3A%20ab2345d5-8891-8d5d-5a8c-b7b4382d4541%0A*%20Version%20Independent%20ID%3A%2003684e91-dbcd-5acc-b86d-7099dac5b473%0A*%20Content%3A%20%5B%26lt%3Balgorithm%26gt%3B%20functions%5D(https%3A%2F%2Fdocs.microsoft.com%2Fen-us%2Fcpp%2Fstandard-library%2Falgorithm-functions%3Fview%3Dvs-2019%23for_each)%0A*%20Content%20Source%3A%20%5Bdocs%2Fstandard-library%2Falgorithm-functions.md%5D(https%3A%2F%2Fgithub.com%2FMicrosoft%2Fcpp-docs%2Fblob%2Fmaster%2Fdocs%2Fstandard-library%2Falgorithm-functions.md)%0A*%20Product%3A%20**visual-cpp**%0A*%20Technology%3A%20**cpp-standard-libraries**%0A*%20GitHub%20Login%3A%20%40corob-msft%0A*%20Microsoft%20Alias%3A%20**corob**">GitHub <span class="docon docon-navigate-external" aria-hidden="true"></span></a>.					</div>
				</div>
			</div>

			<div class="field has-addons is-inline-flex has-margin-bottom-small" hidden="">
				<div class="control has-margin-top-none has-margin-bottom-none">
					<button class="button feedback-form-toggle" aria-describedby="send-feedback-about" aria-expanded="false" aria-controls="feedback-form" data-bi-name="documentation-feedback">
This page					</button>
				</div>
				<div class="control dropdown has-caret has-margin-top-none has-margin-bottom-none" auto-align="">
					<button class="button dropdown-trigger" aria-describedby="send-feedback-about" aria-haspopup="true" aria-expanded="false" aria-controls="fbm1" aria-label="Additional feedback options" data-bi-name="documentation-feedback-menu">
						<span class="icon docon docon-chevron-down-light" aria-hidden="true"></span>
					</button>
					<div id="fbm1" class="dropdown-menu documentation-feedback-menu">
						You may also leave feedback directly on <a data-bi-name="create-issue-on-github" href="https://github.com/MicrosoftDocs/cpp-docs/issues/new?title=&amp;body=%0A%0A%5BEnter%20feedback%20here%5D%0A%0A%0A---%0A%23%23%23%23%20Document%20Details%0A%0A%E2%9A%A0%20*Do%20not%20edit%20this%20section.%20It%20is%20required%20for%20docs.microsoft.com%20%E2%9E%9F%20GitHub%20issue%20linking.*%0A%0A*%20ID%3A%20ab2345d5-8891-8d5d-5a8c-b7b4382d4541%0A*%20Version%20Independent%20ID%3A%2003684e91-dbcd-5acc-b86d-7099dac5b473%0A*%20Content%3A%20%5B%26lt%3Balgorithm%26gt%3B%20functions%5D(https%3A%2F%2Fdocs.microsoft.com%2Fen-us%2Fcpp%2Fstandard-library%2Falgorithm-functions%3Fview%3Dvs-2019%23for_each)%0A*%20Content%20Source%3A%20%5Bdocs%2Fstandard-library%2Falgorithm-functions.md%5D(https%3A%2F%2Fgithub.com%2FMicrosoft%2Fcpp-docs%2Fblob%2Fmaster%2Fdocs%2Fstandard-library%2Falgorithm-functions.md)%0A*%20Product%3A%20**visual-cpp**%0A*%20Technology%3A%20**cpp-standard-libraries**%0A*%20GitHub%20Login%3A%20%40corob-msft%0A*%20Microsoft%20Alias%3A%20**corob**">GitHub <span class="docon docon-navigate-external" aria-hidden="true"></span></a>.					</div>
				</div>
			</div>
		</div>
	</div>

	<form class="feedback-form" id="feedback-form" accept-charset="UTF-8" autocomplete="off" action="javascript:" hidden="">
		<h3 class="feedback-form-heading current-user">
			<img class="avatar" alt="Avatar" width="36" height="36" aria-hidden="true" src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTIwIiBoZWlnaHQ9IjEyMCIgdmlld0JveD0iMCAwIDEyMCAxMjAiIGZpbGw9InRyYW5zcGFyZW50IiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciPjwvc3ZnPg==">
			<span class="username" aria-hidden="true"></span>
			<span class="visually-hidden">Liquid error: Can't find the localized string giveDocumentationFeedback for template Conceptual.</span>
		</h3>

		<label>
			<span class="visually-hidden">Issue Title</span>
			<input class="input is-radiusless has-margin-bottom-small" name="title" type="text" placeholder="Issue Title" required="" pattern=".*\w.*">
		</label>
		<label>
			<span class="visually-hidden">Leave a comment</span>
			<textarea name="body" placeholder="Leave a comment" class="textarea is-radiusless" required=""></textarea>
		</label>

		<div class="action-container">
			<button class="button is-primary" type="submit" name="submit">Submit feedback</button>
		</div>
	</form>

	<div class="feedback-status alert is-loading">
		<p>Loading feedback...</p>
	</div>

	<div class="feedback-tab-group tabGroup" data-tab-group-independent="" hidden="" data-bi-name="tab-group">
		<ul role="tablist">
			<li role="presentation">
				<a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#tabpanel-issues-open" role="tab" aria-controls="tabpanel-issues-open" data-tab="issues-open" aria-label="Open Issues" data-bi-name="tab" aria-selected="true" tabindex="0"></a>
			</li>
			<li role="presentation">
				<a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#tabpanel-issues-closed" role="tab" aria-controls="tabpanel-issues-closed" data-tab="issues-closed" aria-label="Closed Issues" data-bi-name="tab" aria-selected="false" tabindex="-1"></a>
			</li>
		</ul>
		<section id="tabpanel-issues-open" role="tabpanel" data-tab="issues-open">
			<div class="no-issues-placeholder">There are no open issues</div>
			<ul class="github-issues-list" aria-label="Open Issues"></ul>
		</section>
		<section id="tabpanel-issues-closed" role="tabpanel" data-tab="issues-closed" hidden="hidden" aria-hidden="true">
			<div class="no-issues-placeholder">There are no closed issues</div>
			<ul class="github-issues-list" aria-label="Closed Issues"></ul>
		</section>
	</div>
	<div class="action-container">
		<a class="view-on-github" href="https://github.com/MicrosoftDocs/cpp-docs/issues?utf8=%E2%9C%93&amp;q=%2203684e91-dbcd-5acc-b86d-7099dac5b473%22&amp;in=body" data-bi-name="view-on-github" hidden="">
			<span class="docon docon-brand-github" aria-hidden="true"></span>
			<span>View on GitHub</span>
			<span class="docon docon-navigate-external" aria-hidden="true"></span>
		</a>
	</div>
</section>
						<!-- end feedback section -->

						<div class="footerContainer is-visible-interactive has-default-focus ">
<footer id="footer-interactive" data-bi-name="footer" class="footer-layout">

    <a data-mscc-ic="false" class="locale-selector-link" href="https://docs.microsoft.com/en-us/locale?target=https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#for_each" data-bi-name="select-locale"><span class="icon docon docon-world is-size-4 has-margin-right-small" aria-hidden="true"></span><span class="local-selector-link-text">English (United States)</span></a>

    <ul class="links" data-bi-name="footerlinks">
		<li><a data-mscc-ic="false" href="https://docs.microsoft.com/previous-versions/" data-bi-name="archivelink">Previous Version Docs</a></li>
		<li><a data-mscc-ic="false" href="https://docs.microsoft.com/teamblog" data-bi-name="bloglink">Blog</a></li>
		<li><a data-mscc-ic="false" href="https://docs.microsoft.com/contribute" data-bi-name="contributorGuide">Contribute</a></li>
			<li><a data-mscc-ic="false" href="https://go.microsoft.com/fwlink/?LinkId=521839" data-bi-name="privacy">Privacy &amp; Cookies</a></li>
		<li><a data-mscc-ic="false" href="https://docs.microsoft.com/en-us/legal/termsofuse" data-bi-name="termsofuse">Terms of Use</a></li>
		<li><a data-mscc-ic="false" href="https://aka.ms/sitefeedback" data-bi-name="feedback">Site Feedback</a></li>
		<li><a data-mscc-ic="false" href="https://www.microsoft.com/en-us/legal/intellectualproperty/Trademarks/EN-US.aspx" data-bi-name="trademarks">Trademarks</a></li>
    </ul>
</footer>
						</div>
					</div>

					<!--end of div.columns -->

				</div>

			<!--end of .primary-holder -->
			</section>

				<div id="left-container" class="left-container column is-one-third-tablet is-one-quarter-desktop">
					<nav class="sidebar" id="sidebar" data-bi-name="left toc" role="navigation" aria-label="Main Navigation" style="width: 275.391px; top: 24px; bottom: 24px;">
						<button class="sidebar-header has-inner-focus" type="button" aria-label="Close" data-bi-name="contents-collapse">
							<span>Contents</span>
							<span class="docon docon-navigate-close" aria-hidden="true"></span>
						</button>
						<div id="sidebarContent">
							<div class="filterHolder">
							<div class="moniker-picker" data-bi-name="moniker-picker">
		<button class="products has-inner-focus" id="ax-0" aria-haspopup="true" aria-controls="ax-1" aria-expanded="false">
			<span class="visually-hidden">Selected Version</span>
			<span aria-hidden="true">Visual Studio 2019</span>
		</button>
		<div class="products" id="ax-1" role="menu" aria-labelledby="ax-0" style="z-index: 5000">
			<span aria-hidden="true">Version</span>
			<ul aria-label="Product"><li><a class="preserve-view has-inner-focus" role="menuitem" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019" aria-label="Visual Studio 2019" data-default="true" tabindex="-1">2019</a></li><li><a class="preserve-view has-inner-focus" role="menuitem" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2017" aria-label="Visual Studio 2017" data-default="false" tabindex="-1">2017</a></li><li><a class="preserve-view has-inner-focus" role="menuitem" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2015" aria-label="Visual Studio 2015" data-default="false" tabindex="-1">2015</a></li></ul>
		</div></div><form class="tocFilter" aria-label="Filter table of contents"><input class="input is-size-7" placeholder="Filter by title" aria-label="Filter" data-bi-name="toc-filter" id="toc-filter" type="search" aria-controls="filterResults"><a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#" title="Clear Filter" class="clearInput"><span class="visually-hidden">Clear Filter</span></a></form><div class="emptyFilterMessage">No results</div></div>
							<nav class="toc" role="application" aria-label="Table of contents" id="filterResults"><ul role="tree" onclick="msDocs.functions.stopSomePropagation(event, &quot;top&quot;)" class="noSibs"><li role="group" data-moniker="vs-2015 vs-2017 vs-2019" aria-expanded="true" aria-label="c++ standard library reference " onclick="event.stopPropagation();msDocs.functions.toggleAriaExpanded(this)"><a onclick="msDocs.functions.stopSomePropagation(event, &quot;left&quot;)" tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/cpp-standard-library-reference?view=vs-2019" data-text="c++ standard library reference ">C++ Standard Library Reference</a><ul role="tree" onclick="msDocs.functions.stopSomePropagation(event, &quot;top&quot;)"><li role="group" data-moniker="vs-2015 vs-2017 vs-2019" aria-expanded="true" aria-label="c++ standard library header files " tabindex="0" onclick="event.stopPropagation();msDocs.functions.toggleAriaExpanded(this)"><a onclick="msDocs.functions.stopSomePropagation(event, &quot;left&quot;)" tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/cpp-standard-library-header-files?view=vs-2019" data-text="c++ standard library header files ">C++ Standard Library Header Files</a><ul role="tree" onclick="msDocs.functions.stopSomePropagation(event, &quot;top&quot;)"><li role="group" data-moniker="vs-2015 vs-2017 vs-2019" aria-expanded="true" aria-label="&amp;lt;algorithm&amp;gt; " tabindex="0" onclick="event.stopPropagation();msDocs.functions.toggleAriaExpanded(this)" class="noSubs"><a onclick="msDocs.functions.stopSomePropagation(event, &quot;left&quot;)" tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm?view=vs-2019" data-text="&amp;lt;algorithm&amp;gt; ">&lt;algorithm&gt;</a><ul role="tree" onclick="msDocs.functions.stopSomePropagation(event, &quot;top&quot;)"><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019" class="selectedHolder"><a onclick="msDocs.functions.stopSomePropagation(event, &quot;left&quot;)" tabindex="0" class="selected" aria-current="page" data-showme="true" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019" data-text="&amp;lt;algorithm&amp;gt; functions ">&lt;algorithm&gt; functions</a></li></ul></li><li role="group" data-moniker="vs-2015 vs-2017 vs-2019" aria-expanded="false" aria-label="&amp;lt;allocators&amp;gt; " tabindex="0" onclick="event.stopPropagation();msDocs.functions.toggleAriaExpanded(this)" class="noSubs"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/allocators-header?view=vs-2019" data-text="&amp;lt;allocators&amp;gt; ">&lt;allocators&gt;</a><ul role="tree" onclick="msDocs.functions.stopSomePropagation(event, &quot;top&quot;)"><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a onclick="msDocs.functions.stopSomePropagation(event, &quot;left&quot;)" tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/allocators-functions?view=vs-2019" data-text="&amp;lt;allocators&amp;gt; functions ">&lt;allocators&gt; functions</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/allocators-operators?view=vs-2019" data-text="&amp;lt;allocators&amp;gt; operators ">&lt;allocators&gt; operators</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/allocator-base-class?view=vs-2019" data-text="allocator_base class ">allocator_base Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/allocator-chunklist-class?view=vs-2019" data-text="allocator_chunklist class ">allocator_chunklist Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/allocator-fixed-size-class?view=vs-2019" data-text="allocator_fixed_size class ">allocator_fixed_size Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/allocator-newdel-class?view=vs-2019" data-text="allocator_newdel class ">allocator_newdel Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/allocator-suballoc-class?view=vs-2019" data-text="allocator_suballoc class ">allocator_suballoc Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/allocator-unbounded-class?view=vs-2019" data-text="allocator_unbounded class ">allocator_unbounded Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/allocator-variable-size-class?view=vs-2019" data-text="allocator_variable_size class ">allocator_variable_size Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/cache-chunklist-class?view=vs-2019" data-text="cache_chunklist class ">cache_chunklist Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/cache-freelist-class?view=vs-2019" data-text="cache_freelist class ">cache_freelist Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/cache-suballoc-class?view=vs-2019" data-text="cache_suballoc class ">cache_suballoc Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/freelist-class?view=vs-2019" data-text="freelist class ">freelist Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/max-fixed-size-class?view=vs-2019" data-text="max_fixed_size class ">max_fixed_size Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/max-none-class?view=vs-2019" data-text="max_none class ">max_none Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/max-unbounded-class?view=vs-2019" data-text="max_unbounded class ">max_unbounded Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/max-variable-size-class?view=vs-2019" data-text="max_variable_size class ">max_variable_size Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/rts-alloc-class?view=vs-2019" data-text="rts_alloc class ">rts_alloc Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/sync-none-class?view=vs-2019" data-text="sync_none class ">sync_none Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/sync-per-container-class?view=vs-2019" data-text="sync_per_container class ">sync_per_container Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/sync-per-thread-class?view=vs-2019" data-text="sync_per_thread class ">sync_per_thread Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/sync-shared-class?view=vs-2019" data-text="sync_shared class ">sync_shared Class</a></li></ul></li><li role="group" data-moniker="vs-2015 vs-2017 vs-2019" aria-expanded="false" aria-label="&amp;lt;array&amp;gt; " tabindex="0" onclick="event.stopPropagation();msDocs.functions.toggleAriaExpanded(this)" class="noSubs"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/array?view=vs-2019" data-text="&amp;lt;array&amp;gt; ">&lt;array&gt;</a><ul role="tree" onclick="msDocs.functions.stopSomePropagation(event, &quot;top&quot;)"><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a onclick="msDocs.functions.stopSomePropagation(event, &quot;left&quot;)" tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/array-functions?view=vs-2019" data-text="&amp;lt;array&amp;gt; functions ">&lt;array&gt; functions</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/array-operators?view=vs-2019" data-text="&amp;lt;array&amp;gt; operators ">&lt;array&gt; operators</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/array-class-stl?view=vs-2019" data-text="array class (c++ standard library) ">array Class (C++ Standard Library)</a></li></ul></li><li role="group" data-moniker="vs-2015 vs-2017 vs-2019" aria-expanded="false" aria-label="&amp;lt;atomic&amp;gt; " tabindex="0" onclick="event.stopPropagation();msDocs.functions.toggleAriaExpanded(this)" class="noSubs"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/atomic?view=vs-2019" data-text="&amp;lt;atomic&amp;gt; ">&lt;atomic&gt;</a><ul role="tree" onclick="msDocs.functions.stopSomePropagation(event, &quot;top&quot;)"><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a onclick="msDocs.functions.stopSomePropagation(event, &quot;left&quot;)" tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/atomic-structure?view=vs-2019" data-text="atomic structure ">atomic Structure</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/atomic-flag-structure?view=vs-2019" data-text="atomic_flag structure ">atomic_flag Structure</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/atomic-functions?view=vs-2019" data-text="&amp;lt;atomic&amp;gt; functions ">&lt;atomic&gt; functions</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/atomic-enums?view=vs-2019" data-text="&amp;lt;atomic&amp;gt; enums ">&lt;atomic&gt; enums</a></li></ul></li><li role="group" data-moniker="vs-2015 vs-2017 vs-2019" aria-expanded="false" aria-label="&amp;lt;bitset&amp;gt; " tabindex="0" onclick="event.stopPropagation();msDocs.functions.toggleAriaExpanded(this)" class="noSubs"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/bitset?view=vs-2019" data-text="&amp;lt;bitset&amp;gt; ">&lt;bitset&gt;</a><ul role="tree" onclick="msDocs.functions.stopSomePropagation(event, &quot;top&quot;)"><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a onclick="msDocs.functions.stopSomePropagation(event, &quot;left&quot;)" tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/bitset-operators?view=vs-2019" data-text="&amp;lt;bitset&amp;gt; operators ">&lt;bitset&gt; operators</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/bitset-class?view=vs-2019" data-text="bitset class ">bitset Class</a></li></ul></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/cassert?view=vs-2019" data-text="&amp;lt;cassert&amp;gt; ">&lt;cassert&gt;</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/ccomplex?view=vs-2019" data-text="&amp;lt;ccomplex&amp;gt; ">&lt;ccomplex&gt;</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/cctype?view=vs-2019" data-text="&amp;lt;cctype&amp;gt; ">&lt;cctype&gt;</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/cerrno?view=vs-2019" data-text="&amp;lt;cerrno&amp;gt; ">&lt;cerrno&gt;</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/cfenv?view=vs-2019" data-text="&amp;lt;cfenv&amp;gt; ">&lt;cfenv&gt;</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/cfloat?view=vs-2019" data-text="&amp;lt;cfloat&amp;gt; ">&lt;cfloat&gt;</a></li><li role="group" data-moniker="vs-2015 vs-2017 vs-2019" aria-expanded="false" aria-label="&amp;lt;chrono&amp;gt; " tabindex="0" onclick="event.stopPropagation();msDocs.functions.toggleAriaExpanded(this)" class="noSubs"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/chrono?view=vs-2019" data-text="&amp;lt;chrono&amp;gt; ">&lt;chrono&gt;</a><ul role="tree" onclick="msDocs.functions.stopSomePropagation(event, &quot;top&quot;)"><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a onclick="msDocs.functions.stopSomePropagation(event, &quot;left&quot;)" tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/chrono-functions?view=vs-2019" data-text="&amp;lt;chrono&amp;gt; functions ">&lt;chrono&gt; functions</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/chrono-operators?view=vs-2019" data-text="&amp;lt;chrono&amp;gt; operators ">&lt;chrono&gt; operators</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/chrono-literals?view=vs-2019" data-text="chrono literals ">chrono literals</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/common-type-structure?view=vs-2019" data-text="common_type structure ">common_type Structure</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/duration-class?view=vs-2019" data-text="duration class ">duration Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/duration-values-structure?view=vs-2019" data-text="duration_values structure ">duration_values Structure</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/steady-clock-struct?view=vs-2019" data-text="steady_clock struct ">steady_clock struct</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/system-clock-structure?view=vs-2019" data-text="system_clock structure ">system_clock Structure</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/time-point-class?view=vs-2019" data-text="time_point class ">time_point Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/treat-as-floating-point-structure?view=vs-2019" data-text="treat_as_floating_point structure ">treat_as_floating_point Structure</a></li></ul></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/cinttypes?view=vs-2019" data-text="&amp;lt;cinttypes&amp;gt; ">&lt;cinttypes&gt;</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/ciso646?view=vs-2019" data-text="&amp;lt;ciso646&amp;gt; ">&lt;ciso646&gt;</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/climits?view=vs-2019" data-text="&amp;lt;climits&amp;gt; ">&lt;climits&gt;</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/clocale?view=vs-2019" data-text="&amp;lt;clocale&amp;gt; ">&lt;clocale&gt;</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/cmath?view=vs-2019" data-text="&amp;lt;cmath&amp;gt; ">&lt;cmath&gt;</a></li><li role="group" data-moniker="vs-2015 vs-2017 vs-2019" aria-expanded="false" aria-label="&amp;lt;codecvt&amp;gt; " tabindex="0" onclick="event.stopPropagation();msDocs.functions.toggleAriaExpanded(this)" class="noSubs"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/codecvt?view=vs-2019" data-text="&amp;lt;codecvt&amp;gt; ">&lt;codecvt&gt;</a><ul role="tree" onclick="msDocs.functions.stopSomePropagation(event, &quot;top&quot;)"><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a onclick="msDocs.functions.stopSomePropagation(event, &quot;left&quot;)" tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/codecvt-enums?view=vs-2019" data-text="&amp;lt;codecvt&amp;gt; enums ">&lt;codecvt&gt; enums</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/codecvt-utf8-class?view=vs-2019" data-text="codecvt_utf8 ">codecvt_utf8</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/codecvt-utf8-utf16-class?view=vs-2019" data-text="codecvt_utf8_utf16 ">codecvt_utf8_utf16</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/codecvt-utf16-class?view=vs-2019" data-text="codecvt_utf16 ">codecvt_utf16</a></li></ul></li><li role="group" data-moniker="vs-2015 vs-2017 vs-2019" aria-expanded="false" aria-label="&amp;lt;complex&amp;gt; " tabindex="0" onclick="event.stopPropagation();msDocs.functions.toggleAriaExpanded(this)" class="noSubs"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/complex?view=vs-2019" data-text="&amp;lt;complex&amp;gt; ">&lt;complex&gt;</a><ul role="tree" onclick="msDocs.functions.stopSomePropagation(event, &quot;top&quot;)"><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a onclick="msDocs.functions.stopSomePropagation(event, &quot;left&quot;)" tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/complex-functions?view=vs-2019" data-text="&amp;lt;complex&amp;gt; functions ">&lt;complex&gt; functions</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/complex-operators?view=vs-2019" data-text="&amp;lt;complex&amp;gt; operators ">&lt;complex&gt; operators</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/complex-class?view=vs-2019" data-text="complex class ">complex Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/complex-double?view=vs-2019" data-text="complex&amp;lt;double&amp;gt; ">complex&lt;double&gt;</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/complex-float?view=vs-2019" data-text="complex&amp;lt;float&amp;gt; ">complex&lt;float&gt;</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/complex-long-double?view=vs-2019" data-text="complex&amp;lt;long double&amp;gt; ">complex&lt;long double&gt;</a></li></ul></li><li role="group" data-moniker="vs-2015 vs-2017 vs-2019" aria-expanded="false" aria-label="&amp;lt;condition_variable&amp;gt; " tabindex="0" onclick="event.stopPropagation();msDocs.functions.toggleAriaExpanded(this)" class="noSubs"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/condition-variable?view=vs-2019" data-text="&amp;lt;condition_variable&amp;gt; ">&lt;condition_variable&gt;</a><ul role="tree" onclick="msDocs.functions.stopSomePropagation(event, &quot;top&quot;)"><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a onclick="msDocs.functions.stopSomePropagation(event, &quot;left&quot;)" tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/condition-variable-enums?view=vs-2019" data-text="&amp;lt;condition_variable&amp;gt; enums ">&lt;condition_variable&gt; enums</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/condition-variable-class?view=vs-2019" data-text="condition_variable class ">condition_variable Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/condition-variable-any-class?view=vs-2019" data-text="condition_variable_any class ">condition_variable_any Class</a></li></ul></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/csetjmp?view=vs-2019" data-text="&amp;lt;csetjmp&amp;gt; ">&lt;csetjmp&gt;</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/csignal?view=vs-2019" data-text="&amp;lt;csignal&amp;gt; ">&lt;csignal&gt;</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/cstdarg?view=vs-2019" data-text="&amp;lt;cstdarg&amp;gt; ">&lt;cstdarg&gt;</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/cstdbool?view=vs-2019" data-text="&amp;lt;cstdbool&amp;gt; ">&lt;cstdbool&gt;</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/cstddef?view=vs-2019" data-text="&amp;lt;cstddef&amp;gt; ">&lt;cstddef&gt;</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/cstdint?view=vs-2019" data-text="&amp;lt;cstdint&amp;gt; ">&lt;cstdint&gt;</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/cstdio?view=vs-2019" data-text="&amp;lt;cstdio&amp;gt; ">&lt;cstdio&gt;</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/cstdlib?view=vs-2019" data-text="&amp;lt;cstdlib&amp;gt; ">&lt;cstdlib&gt;</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/cstring?view=vs-2019" data-text="&amp;lt;cstring&amp;gt; ">&lt;cstring&gt;</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/ctgmath?view=vs-2019" data-text="&amp;lt;ctgmath&amp;gt; ">&lt;ctgmath&gt;</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/ctime?view=vs-2019" data-text="&amp;lt;ctime&amp;gt; ">&lt;ctime&gt;</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/cvt-wbuffer?view=vs-2019" data-text="&amp;lt;cvt-wbuffer&amp;gt; ">&lt;cvt-wbuffer&gt;</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/cvt-wstring?view=vs-2019" data-text="&amp;lt;cvt-wstring&amp;gt; ">&lt;cvt-wstring&gt;</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/cwchar?view=vs-2019" data-text="&amp;lt;cwchar&amp;gt; ">&lt;cwchar&gt;</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/cwctype?view=vs-2019" data-text="&amp;lt;cwctype&amp;gt; ">&lt;cwctype&gt;</a></li><li role="group" data-moniker="vs-2015 vs-2017 vs-2019" aria-expanded="false" aria-label="&amp;lt;deque&amp;gt; " tabindex="0" onclick="event.stopPropagation();msDocs.functions.toggleAriaExpanded(this)" class="noSubs"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/deque?view=vs-2019" data-text="&amp;lt;deque&amp;gt; ">&lt;deque&gt;</a><ul role="tree" onclick="msDocs.functions.stopSomePropagation(event, &quot;top&quot;)"><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a onclick="msDocs.functions.stopSomePropagation(event, &quot;left&quot;)" tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/deque-functions?view=vs-2019" data-text="&amp;lt;deque&amp;gt; functions ">&lt;deque&gt; functions</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/deque-operators?view=vs-2019" data-text="&amp;lt;deque&amp;gt; operators ">&lt;deque&gt; operators</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/deque-class?view=vs-2019" data-text="deque class ">deque Class</a></li></ul></li><li role="group" data-moniker="vs-2015 vs-2017 vs-2019" aria-expanded="false" aria-label="&amp;lt;exception&amp;gt; " tabindex="0" onclick="event.stopPropagation();msDocs.functions.toggleAriaExpanded(this)" class="noSubs"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/exception?view=vs-2019" data-text="&amp;lt;exception&amp;gt; ">&lt;exception&gt;</a><ul role="tree" onclick="msDocs.functions.stopSomePropagation(event, &quot;top&quot;)"><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a onclick="msDocs.functions.stopSomePropagation(event, &quot;left&quot;)" tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/exception-functions?view=vs-2019" data-text="&amp;lt;exception&amp;gt; functions ">&lt;exception&gt; functions</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/exception-typedefs?view=vs-2019" data-text="&amp;lt;exception&amp;gt; typedefs ">&lt;exception&gt; typedefs</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/bad-exception-class?view=vs-2019" data-text="bad_exception class ">bad_exception Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/exception-class?view=vs-2019" data-text="exception class ">exception Class</a></li></ul></li><li role="group" data-moniker="vs-2015 vs-2017 vs-2019" aria-expanded="false" aria-label="&amp;lt;filesystem&amp;gt; " tabindex="0" onclick="event.stopPropagation();msDocs.functions.toggleAriaExpanded(this)" class="noSubs"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/filesystem?view=vs-2019" data-text="&amp;lt;filesystem&amp;gt; ">&lt;filesystem&gt;</a><ul role="tree" onclick="msDocs.functions.stopSomePropagation(event, &quot;top&quot;)"><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a onclick="msDocs.functions.stopSomePropagation(event, &quot;left&quot;)" tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/filesystem-operators?view=vs-2019" data-text="&amp;lt;filesystem&amp;gt; operators ">&lt;filesystem&gt; operators</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/filesystem-functions?view=vs-2019" data-text="&amp;lt;filesystem&amp;gt; functions ">&lt;filesystem&gt; functions</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/filesystem-enumerations?view=vs-2019" data-text="&amp;lt;filesystem&amp;gt; enumerations ">&lt;filesystem&gt; enumerations</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/directory-entry-class?view=vs-2019" data-text="directory_entry class ">directory_entry Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/directory-iterator-class?view=vs-2019" data-text="directory_iterator class ">directory_iterator Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/file-status-class?view=vs-2019" data-text="file_status class ">file_status Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/filesystem-error-class?view=vs-2019" data-text="filesystem_error class ">filesystem_error Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/path-class?view=vs-2019" data-text="path class ">path Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/recursive-directory-iterator-class?view=vs-2019" data-text="recursive_directory_iterator class ">recursive_directory_iterator Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/space-info-structure?view=vs-2019" data-text="space_info structure ">space_info Structure</a></li></ul></li><li role="group" data-moniker="vs-2015 vs-2017 vs-2019" aria-expanded="false" aria-label="&amp;lt;forward_list&amp;gt; " tabindex="0" onclick="event.stopPropagation();msDocs.functions.toggleAriaExpanded(this)" class="noSubs"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/forward-list?view=vs-2019" data-text="&amp;lt;forward_list&amp;gt; ">&lt;forward_list&gt;</a><ul role="tree" onclick="msDocs.functions.stopSomePropagation(event, &quot;top&quot;)"><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a onclick="msDocs.functions.stopSomePropagation(event, &quot;left&quot;)" tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/forward-list-functions?view=vs-2019" data-text="&amp;lt;forward_list&amp;gt; functions ">&lt;forward_list&gt; functions</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/forward-list-operators?view=vs-2019" data-text="&amp;lt;forward_list&amp;gt; operators ">&lt;forward_list&gt; operators</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/forward-list-class?view=vs-2019" data-text="forward_list class ">forward_list Class</a></li></ul></li><li role="group" data-moniker="vs-2015 vs-2017 vs-2019" aria-expanded="false" aria-label="&amp;lt;fstream&amp;gt; " tabindex="0" onclick="event.stopPropagation();msDocs.functions.toggleAriaExpanded(this)" class="noSubs"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/fstream?view=vs-2019" data-text="&amp;lt;fstream&amp;gt; ">&lt;fstream&gt;</a><ul role="tree" onclick="msDocs.functions.stopSomePropagation(event, &quot;top&quot;)"><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a onclick="msDocs.functions.stopSomePropagation(event, &quot;left&quot;)" tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/fstream-typedefs?view=vs-2019" data-text="&amp;lt;fstream&amp;gt; typedefs ">&lt;fstream&gt; typedefs</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/basic-filebuf-class?view=vs-2019" data-text="basic_filebuf class ">basic_filebuf Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/basic-fstream-class?view=vs-2019" data-text="basic_fstream class ">basic_fstream Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/basic-ifstream-class?view=vs-2019" data-text="basic_ifstream class ">basic_ifstream Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/basic-ofstream-class?view=vs-2019" data-text="basic_ofstream class ">basic_ofstream Class</a></li></ul></li><li role="group" data-moniker="vs-2015 vs-2017 vs-2019" aria-expanded="false" aria-label="&amp;lt;functional&amp;gt; " tabindex="0" onclick="event.stopPropagation();msDocs.functions.toggleAriaExpanded(this)" class="noSubs"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/functional?view=vs-2019" data-text="&amp;lt;functional&amp;gt; ">&lt;functional&gt;</a><ul role="tree" onclick="msDocs.functions.stopSomePropagation(event, &quot;top&quot;)"><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a onclick="msDocs.functions.stopSomePropagation(event, &quot;left&quot;)" tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/functional-functions?view=vs-2019" data-text="&amp;lt;functional&amp;gt; functions ">&lt;functional&gt; functions</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/functional-operators?view=vs-2019" data-text="&amp;lt;functional&amp;gt; operators ">&lt;functional&gt; operators</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/1-object?view=vs-2019" data-text="_1 object ">_1 Object</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/bad-function-call-class?view=vs-2019" data-text="bad_function_call class ">bad_function_call Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/binary-function-struct?view=vs-2019" data-text="binary_function struct ">binary_function Struct</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/binary-negate-class?view=vs-2019" data-text="binary_negate class ">binary_negate Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/binder1st-class?view=vs-2019" data-text="binder1st class ">binder1st Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/binder2nd-class?view=vs-2019" data-text="binder2nd class ">binder2nd Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/const-mem-fun-ref-t-class?view=vs-2019" data-text="const_mem_fun_ref_t class ">const_mem_fun_ref_t Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/const-mem-fun-t-class?view=vs-2019" data-text="const_mem_fun_t class ">const_mem_fun_t Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/const-mem-fun1-ref-t-class?view=vs-2019" data-text="const_mem_fun1_ref_t class ">const_mem_fun1_ref_t Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/const-mem-fun1-t-class?view=vs-2019" data-text="const_mem_fun1_t class ">const_mem_fun1_t Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/divides-struct?view=vs-2019" data-text="divides struct ">divides Struct</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/equal-to-struct?view=vs-2019" data-text="equal_to struct ">equal_to Struct</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/function-class?view=vs-2019" data-text="function class ">function Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/greater-struct?view=vs-2019" data-text="greater struct ">greater Struct</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/greater-equal-struct?view=vs-2019" data-text="greater_equal struct ">greater_equal Struct</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/hash-class?view=vs-2019" data-text="hash class ">hash Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/is-bind-expression-class?view=vs-2019" data-text="is_bind_expression class ">is_bind_expression Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/is-placeholder-class?view=vs-2019" data-text="is_placeholder class ">is_placeholder Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/less-struct?view=vs-2019" data-text="less struct ">less Struct</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/less-equal-struct?view=vs-2019" data-text="less_equal struct ">less_equal Struct</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/logical-and-struct?view=vs-2019" data-text="logical_and struct ">logical_and Struct</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/logical-not-struct?view=vs-2019" data-text="logical_not struct ">logical_not Struct</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/logical-or-struct?view=vs-2019" data-text="logical_or struct ">logical_or Struct</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/mem-fun-ref-t-class?view=vs-2019" data-text="mem_fun_ref_t class ">mem_fun_ref_t Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/mem-fun-t-class?view=vs-2019" data-text="mem_fun_t class ">mem_fun_t Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/mem-fun1-ref-t-class?view=vs-2019" data-text="mem_fun1_ref_t class ">mem_fun1_ref_t Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/mem-fun1-t-class?view=vs-2019" data-text="mem_fun1_t class ">mem_fun1_t Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/minus-struct?view=vs-2019" data-text="minus struct ">minus Struct</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/modulus-struct?view=vs-2019" data-text="modulus struct ">modulus Struct</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/multiplies-struct?view=vs-2019" data-text="multiplies struct ">multiplies Struct</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/negate-struct?view=vs-2019" data-text="negate struct ">negate Struct</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/not-equal-to-struct?view=vs-2019" data-text="not_equal_to struct ">not_equal_to Struct</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/plus-struct?view=vs-2019" data-text="plus struct ">plus Struct</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/pointer-to-binary-function-class?view=vs-2019" data-text="pointer_to_binary_function class ">pointer_to_binary_function Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/pointer-to-unary-function-class?view=vs-2019" data-text="pointer_to_unary_function class ">pointer_to_unary_function Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/reference-wrapper-class?view=vs-2019" data-text="reference_wrapper class ">reference_wrapper Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/unary-function-struct?view=vs-2019" data-text="unary_function struct ">unary_function Struct</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/unary-negate-class?view=vs-2019" data-text="unary_negate class ">unary_negate Class</a></li></ul></li><li role="group" data-moniker="vs-2015 vs-2017 vs-2019" aria-expanded="false" aria-label="&amp;lt;future&amp;gt; " tabindex="0" onclick="event.stopPropagation();msDocs.functions.toggleAriaExpanded(this)" class="noSubs"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/future?view=vs-2019" data-text="&amp;lt;future&amp;gt; ">&lt;future&gt;</a><ul role="tree" onclick="msDocs.functions.stopSomePropagation(event, &quot;top&quot;)"><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a onclick="msDocs.functions.stopSomePropagation(event, &quot;left&quot;)" tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/future-functions?view=vs-2019" data-text="&amp;lt;future&amp;gt; functions ">&lt;future&gt; functions</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/future-enums?view=vs-2019" data-text="&amp;lt;future&amp;gt; enums ">&lt;future&gt; enums</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/future-class?view=vs-2019" data-text="future class ">future Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/future-error-class?view=vs-2019" data-text="future_error class ">future_error Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/is-error-code-enum-structure?view=vs-2019" data-text="is_error_code_enum structure ">is_error_code_enum Structure</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/packaged-task-class?view=vs-2019" data-text="packaged_task class ">packaged_task Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/promise-class?view=vs-2019" data-text="promise class ">promise Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/shared-future-class?view=vs-2019" data-text="shared_future class ">shared_future Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/uses-allocator-structure?view=vs-2019" data-text="uses_allocator structure ">uses_allocator Structure</a></li></ul></li><li role="group" data-moniker="vs-2015 vs-2017 vs-2019" aria-expanded="false" aria-label="&amp;lt;hash_map&amp;gt; " tabindex="0" onclick="event.stopPropagation();msDocs.functions.toggleAriaExpanded(this)" class="noSubs"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/hash-map?view=vs-2019" data-text="&amp;lt;hash_map&amp;gt; ">&lt;hash_map&gt;</a><ul role="tree" onclick="msDocs.functions.stopSomePropagation(event, &quot;top&quot;)"><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a onclick="msDocs.functions.stopSomePropagation(event, &quot;left&quot;)" tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/hash-map-functions?view=vs-2019" data-text="&amp;lt;hash_map&amp;gt; functions ">&lt;hash_map&gt; functions</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/hash-map-operators?view=vs-2019" data-text="&amp;lt;hash_map&amp;gt; operators ">&lt;hash_map&gt; operators</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/hash-compare-class?view=vs-2019" data-text="hash_compare class ">hash_compare Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/hash-map-class?view=vs-2019" data-text="hash_map class ">hash_map Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/hash-multimap-class?view=vs-2019" data-text="hash_multimap class ">hash_multimap Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/value-compare-class?view=vs-2019" data-text="value_compare class ">value_compare Class</a></li></ul></li><li role="group" data-moniker="vs-2015 vs-2017 vs-2019" aria-expanded="false" aria-label="&amp;lt;hash_set&amp;gt; " tabindex="0" onclick="event.stopPropagation();msDocs.functions.toggleAriaExpanded(this)" class="noSubs"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/hash-set?view=vs-2019" data-text="&amp;lt;hash_set&amp;gt; ">&lt;hash_set&gt;</a><ul role="tree" onclick="msDocs.functions.stopSomePropagation(event, &quot;top&quot;)"><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a onclick="msDocs.functions.stopSomePropagation(event, &quot;left&quot;)" tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/hash-set-class?view=vs-2019" data-text="hash_set class ">hash_set Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/hash-multiset-class?view=vs-2019" data-text="hash_multiset class ">hash_multiset Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/hash-set-functions?view=vs-2019" data-text="&amp;lt;hash_set&amp;gt; functions ">&lt;hash_set&gt; functions</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/hash-set-operators?view=vs-2019" data-text="&amp;lt;hash_set&amp;gt; operators ">&lt;hash_set&gt; operators</a></li></ul></li><li role="group" data-moniker="vs-2015 vs-2017 vs-2019" aria-expanded="false" aria-label="&amp;lt;initializer_list&amp;gt; " tabindex="0" onclick="event.stopPropagation();msDocs.functions.toggleAriaExpanded(this)" class="noSubs"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/initializer-list?view=vs-2019" data-text="&amp;lt;initializer_list&amp;gt; ">&lt;initializer_list&gt;</a><ul role="tree" onclick="msDocs.functions.stopSomePropagation(event, &quot;top&quot;)"><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a onclick="msDocs.functions.stopSomePropagation(event, &quot;left&quot;)" tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/initializer-list-class?view=vs-2019" data-text="initializer_list class ">initializer_list Class</a></li></ul></li><li role="group" data-moniker="vs-2015 vs-2017 vs-2019" aria-expanded="false" aria-label="&amp;lt;iomanip&amp;gt; " tabindex="0" onclick="event.stopPropagation();msDocs.functions.toggleAriaExpanded(this)" class="noSubs"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/iomanip?view=vs-2019" data-text="&amp;lt;iomanip&amp;gt; ">&lt;iomanip&gt;</a><ul role="tree" onclick="msDocs.functions.stopSomePropagation(event, &quot;top&quot;)"><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a onclick="msDocs.functions.stopSomePropagation(event, &quot;left&quot;)" tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/iomanip-functions?view=vs-2019" data-text="&amp;lt;iomanip&amp;gt; functions ">&lt;iomanip&gt; functions</a></li></ul></li><li role="group" data-moniker="vs-2015 vs-2017 vs-2019" aria-expanded="false" aria-label="&amp;lt;ios&amp;gt; " tabindex="0" onclick="event.stopPropagation();msDocs.functions.toggleAriaExpanded(this)" class="noSubs"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/ios?view=vs-2019" data-text="&amp;lt;ios&amp;gt; ">&lt;ios&gt;</a><ul role="tree" onclick="msDocs.functions.stopSomePropagation(event, &quot;top&quot;)"><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a onclick="msDocs.functions.stopSomePropagation(event, &quot;left&quot;)" tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/ios-functions?view=vs-2019" data-text="&amp;lt;ios&amp;gt; functions ">&lt;ios&gt; functions</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/ios-typedefs?view=vs-2019" data-text="&amp;lt;ios&amp;gt; typedefs ">&lt;ios&gt; typedefs</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/basic-ios-class?view=vs-2019" data-text="basic_ios class ">basic_ios Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/fpos-class?view=vs-2019" data-text="fpos class ">fpos Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/ios-base-class?view=vs-2019" data-text="ios_base class ">ios_base Class</a></li></ul></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/iosfwd?view=vs-2019" data-text="&amp;lt;iosfwd&amp;gt; ">&lt;iosfwd&gt;</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/iostream?view=vs-2019" data-text="&amp;lt;iostream&amp;gt; ">&lt;iostream&gt;</a></li><li role="group" data-moniker="vs-2015 vs-2017 vs-2019" aria-expanded="false" aria-label="&amp;lt;istream&amp;gt; " tabindex="0" onclick="event.stopPropagation();msDocs.functions.toggleAriaExpanded(this)" class="noSubs"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/istream?view=vs-2019" data-text="&amp;lt;istream&amp;gt; ">&lt;istream&gt;</a><ul role="tree" onclick="msDocs.functions.stopSomePropagation(event, &quot;top&quot;)"><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a onclick="msDocs.functions.stopSomePropagation(event, &quot;left&quot;)" tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/istream-functions?view=vs-2019" data-text="&amp;lt;istream&amp;gt; functions ">&lt;istream&gt; functions</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/istream-operators?view=vs-2019" data-text="&amp;lt;istream&amp;gt; operators ">&lt;istream&gt; operators</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/istream-typedefs?view=vs-2019" data-text="&amp;lt;istream&amp;gt; typedefs ">&lt;istream&gt; typedefs</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/basic-iostream-class?view=vs-2019" data-text="basic_iostream class ">basic_iostream Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/basic-istream-class?view=vs-2019" data-text="basic_istream class ">basic_istream Class</a></li></ul></li><li role="group" data-moniker="vs-2015 vs-2017 vs-2019" aria-expanded="false" aria-label="&amp;lt;iterator&amp;gt; " tabindex="0" onclick="event.stopPropagation();msDocs.functions.toggleAriaExpanded(this)" class="noSubs"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/iterator?view=vs-2019" data-text="&amp;lt;iterator&amp;gt; ">&lt;iterator&gt;</a><ul role="tree" onclick="msDocs.functions.stopSomePropagation(event, &quot;top&quot;)"><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a onclick="msDocs.functions.stopSomePropagation(event, &quot;left&quot;)" tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/iterator-functions?view=vs-2019" data-text="&amp;lt;iterator&amp;gt; functions ">&lt;iterator&gt; functions</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/iterator-operators?view=vs-2019" data-text="&amp;lt;iterator&amp;gt; operators ">&lt;iterator&gt; operators</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/back-insert-iterator-class?view=vs-2019" data-text="back_insert_iterator class ">back_insert_iterator Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/bidirectional-iterator-tag-struct?view=vs-2019" data-text="bidirectional_iterator_tag struct ">bidirectional_iterator_tag Struct</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/checked-array-iterator-class?view=vs-2019" data-text="checked_array_iterator class ">checked_array_iterator Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/forward-iterator-tag-struct?view=vs-2019" data-text="forward_iterator_tag struct ">forward_iterator_tag Struct</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/front-insert-iterator-class?view=vs-2019" data-text="front_insert_iterator class ">front_insert_iterator Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/input-iterator-tag-struct?view=vs-2019" data-text="input_iterator_tag struct ">input_iterator_tag Struct</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/insert-iterator-class?view=vs-2019" data-text="insert_iterator class ">insert_iterator Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/istream-iterator-class?view=vs-2019" data-text="istream_iterator class ">istream_iterator Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/istreambuf-iterator-class?view=vs-2019" data-text="istreambuf_iterator class ">istreambuf_iterator Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/iterator-struct?view=vs-2019" data-text="iterator struct ">iterator Struct</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/iterator-traits-struct?view=vs-2019" data-text="iterator_traits struct ">iterator_traits Struct</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/move-iterator-class?view=vs-2019" data-text="move_iterator class ">move_iterator Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/ostream-iterator-class?view=vs-2019" data-text="ostream_iterator class ">ostream_iterator Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/ostreambuf-iterator-class?view=vs-2019" data-text="ostreambuf_iterator class ">ostreambuf_iterator Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/output-iterator-tag-struct?view=vs-2019" data-text="output_iterator_tag struct ">output_iterator_tag Struct</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/random-access-iterator-tag-struct?view=vs-2019" data-text="random_access_iterator_tag struct ">random_access_iterator_tag Struct</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/reverse-iterator-class?view=vs-2019" data-text="reverse_iterator class ">reverse_iterator Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/unchecked-array-iterator-class?view=vs-2019" data-text="unchecked_array_iterator class ">unchecked_array_iterator Class</a></li></ul></li><li role="group" data-moniker="vs-2015 vs-2017 vs-2019" aria-expanded="false" aria-label="&amp;lt;limits&amp;gt; " tabindex="0" onclick="event.stopPropagation();msDocs.functions.toggleAriaExpanded(this)" class="noSubs"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/limits?view=vs-2019" data-text="&amp;lt;limits&amp;gt; ">&lt;limits&gt;</a><ul role="tree" onclick="msDocs.functions.stopSomePropagation(event, &quot;top&quot;)"><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a onclick="msDocs.functions.stopSomePropagation(event, &quot;left&quot;)" tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/limits-enums?view=vs-2019" data-text="&amp;lt;limits&amp;gt; enums ">&lt;limits&gt; enums</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/numeric-limits-class?view=vs-2019" data-text="numeric_limits class ">numeric_limits Class</a></li></ul></li><li role="group" data-moniker="vs-2015 vs-2017 vs-2019" aria-expanded="false" aria-label="&amp;lt;list&amp;gt; " tabindex="0" onclick="event.stopPropagation();msDocs.functions.toggleAriaExpanded(this)" class="noSubs"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/list?view=vs-2019" data-text="&amp;lt;list&amp;gt; ">&lt;list&gt;</a><ul role="tree" onclick="msDocs.functions.stopSomePropagation(event, &quot;top&quot;)"><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a onclick="msDocs.functions.stopSomePropagation(event, &quot;left&quot;)" tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/list-operators?view=vs-2019" data-text="&amp;lt;list&amp;gt; operators ">&lt;list&gt; operators</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/list-class?view=vs-2019" data-text="list class ">list Class</a></li></ul></li><li role="group" data-moniker="vs-2015 vs-2017 vs-2019" aria-expanded="false" aria-label="&amp;lt;locale&amp;gt; " tabindex="0" onclick="event.stopPropagation();msDocs.functions.toggleAriaExpanded(this)" class="noSubs"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/locale?view=vs-2019" data-text="&amp;lt;locale&amp;gt; ">&lt;locale&gt;</a><ul role="tree" onclick="msDocs.functions.stopSomePropagation(event, &quot;top&quot;)"><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a onclick="msDocs.functions.stopSomePropagation(event, &quot;left&quot;)" tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/locale-functions?view=vs-2019" data-text="&amp;lt;locale&amp;gt; functions ">&lt;locale&gt; functions</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/codecvt-class?view=vs-2019" data-text="codecvt class ">codecvt Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/codecvt-base-class?view=vs-2019" data-text="codecvt_base class ">codecvt_base Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/codecvt-byname-class?view=vs-2019" data-text="codecvt_byname class ">codecvt_byname Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/collate-class?view=vs-2019" data-text="collate class ">collate Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/collate-byname-class?view=vs-2019" data-text="collate_byname class ">collate_byname Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/ctype-class?view=vs-2019" data-text="ctype class ">ctype Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/ctype-char-class?view=vs-2019" data-text="ctype&amp;lt;char&amp;gt; class ">ctype&lt;char&gt; Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/ctype-base-class?view=vs-2019" data-text="ctype_base class ">ctype_base Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/ctype-byname-class?view=vs-2019" data-text="ctype_byname class ">ctype_byname Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/locale-class?view=vs-2019" data-text="locale class ">locale Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/messages-class?view=vs-2019" data-text="messages class ">messages Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/messages-base-class?view=vs-2019" data-text="messages_base class ">messages_base Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/messages-byname-class?view=vs-2019" data-text="messages_byname class ">messages_byname Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/money-base-class?view=vs-2019" data-text="money_base class ">money_base Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/money-get-class?view=vs-2019" data-text="money_get class ">money_get Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/money-put-class?view=vs-2019" data-text="money_put class ">money_put Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/moneypunct-class?view=vs-2019" data-text="moneypunct class ">moneypunct Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/moneypunct-byname-class?view=vs-2019" data-text="moneypunct_byname class ">moneypunct_byname Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/num-get-class?view=vs-2019" data-text="num_get class ">num_get Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/num-put-class?view=vs-2019" data-text="num_put class ">num_put Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/numpunct-class?view=vs-2019" data-text="numpunct class ">numpunct Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/numpunct-byname-class?view=vs-2019" data-text="numpunct_byname class ">numpunct_byname Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/time-base-class?view=vs-2019" data-text="time_base class ">time_base Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/time-get-class?view=vs-2019" data-text="time_get class ">time_get Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/time-get-byname-class?view=vs-2019" data-text="time_get_byname class ">time_get_byname Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/time-put-class?view=vs-2019" data-text="time_put class ">time_put Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/time-put-byname-class?view=vs-2019" data-text="time_put_byname class ">time_put_byname Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/wbuffer-convert-class?view=vs-2019" data-text="wbuffer_convert class ">wbuffer_convert Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/wstring-convert-class?view=vs-2019" data-text="wstring_convert class ">wstring_convert Class</a></li></ul></li><li role="group" data-moniker="vs-2015 vs-2017 vs-2019" aria-expanded="false" aria-label="&amp;lt;map&amp;gt; " tabindex="0" onclick="event.stopPropagation();msDocs.functions.toggleAriaExpanded(this)" class="noSubs"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/map?view=vs-2019" data-text="&amp;lt;map&amp;gt; ">&lt;map&gt;</a><ul role="tree" onclick="msDocs.functions.stopSomePropagation(event, &quot;top&quot;)"><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a onclick="msDocs.functions.stopSomePropagation(event, &quot;left&quot;)" tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/map-functions?view=vs-2019" data-text="&amp;lt;map&amp;gt; functions ">&lt;map&gt; functions</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/map-operators?view=vs-2019" data-text="&amp;lt;map&amp;gt; operators ">&lt;map&gt; operators</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/map-class?view=vs-2019" data-text="map class ">map Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/multimap-class?view=vs-2019" data-text="multimap class ">multimap Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/value-compare-class-map?view=vs-2019" data-text="value_compare class (&amp;lt;map&amp;gt;) ">value_compare Class (&lt;map&gt;)</a></li></ul></li><li role="group" data-moniker="vs-2015 vs-2017 vs-2019" aria-expanded="false" aria-label="&amp;lt;memory&amp;gt; " tabindex="0" onclick="event.stopPropagation();msDocs.functions.toggleAriaExpanded(this)" class="noSubs"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/memory?view=vs-2019" data-text="&amp;lt;memory&amp;gt; ">&lt;memory&gt;</a><ul role="tree" onclick="msDocs.functions.stopSomePropagation(event, &quot;top&quot;)"><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a onclick="msDocs.functions.stopSomePropagation(event, &quot;left&quot;)" tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/memory-functions?view=vs-2019" data-text="&amp;lt;memory&amp;gt; functions ">&lt;memory&gt; functions</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/memory-operators?view=vs-2019" data-text="&amp;lt;memory&amp;gt; operators ">&lt;memory&gt; operators</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/memory-enums?view=vs-2019" data-text="&amp;lt;memory&amp;gt; enums ">&lt;memory&gt; enums</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/allocator-class?view=vs-2019" data-text="allocator class ">allocator Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/allocator-void-class?view=vs-2019" data-text="allocator&amp;lt;void&amp;gt; class ">allocator&lt;void&gt; Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/allocator-traits-class?view=vs-2019" data-text="allocator_traits class ">allocator_traits Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/auto-ptr-class?view=vs-2019" data-text="auto_ptr class ">auto_ptr Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/bad-weak-ptr-class?view=vs-2019" data-text="bad_weak_ptr class ">bad_weak_ptr Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/enable-shared-from-this-class?view=vs-2019" data-text="enable_shared_from_this class ">enable_shared_from_this Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/pointer-traits-struct?view=vs-2019" data-text="pointer_traits struct ">pointer_traits Struct</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/raw-storage-iterator-class?view=vs-2019" data-text="raw_storage_iterator class ">raw_storage_iterator Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/shared-ptr-class?view=vs-2019" data-text="shared_ptr class ">shared_ptr Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/unique-ptr-class?view=vs-2019" data-text="unique_ptr class ">unique_ptr Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/weak-ptr-class?view=vs-2019" data-text="weak_ptr class ">weak_ptr Class</a></li></ul></li><li role="group" data-moniker="vs-2015 vs-2017 vs-2019" aria-expanded="false" aria-label="&amp;lt;mutex&amp;gt; " tabindex="0" onclick="event.stopPropagation();msDocs.functions.toggleAriaExpanded(this)" class="noSubs"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/mutex?view=vs-2019" data-text="&amp;lt;mutex&amp;gt; ">&lt;mutex&gt;</a><ul role="tree" onclick="msDocs.functions.stopSomePropagation(event, &quot;top&quot;)"><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a onclick="msDocs.functions.stopSomePropagation(event, &quot;left&quot;)" tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/mutex-functions?view=vs-2019" data-text="&amp;lt;mutex&amp;gt; functions ">&lt;mutex&gt; functions</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/adopt-lock-t-structure?view=vs-2019" data-text="adopt_lock_t structure ">adopt_lock_t Structure</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/defer-lock-t-structure?view=vs-2019" data-text="defer_lock_t structure ">defer_lock_t Structure</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/lock-guard-class?view=vs-2019" data-text="lock_guard class ">lock_guard Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/mutex-class-stl?view=vs-2019" data-text="mutex class (c++ standard library) ">mutex Class (C++ Standard Library)</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/once-flag-structure?view=vs-2019" data-text="once_flag structure ">once_flag Structure</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/recursive-mutex-class?view=vs-2019" data-text="recursive_mutex class ">recursive_mutex Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/recursive-timed-mutex-class?view=vs-2019" data-text="recursive_timed_mutex class ">recursive_timed_mutex Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/timed-mutex-class?view=vs-2019" data-text="timed_mutex class ">timed_mutex Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/try-to-lock-t-structure?view=vs-2019" data-text="try_to_lock_t structure ">try_to_lock_t Structure</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/unique-lock-class?view=vs-2019" data-text="unique_lock class ">unique_lock Class</a></li></ul></li><li role="group" data-moniker="vs-2015 vs-2017 vs-2019" aria-expanded="false" aria-label="&amp;lt;new&amp;gt; " tabindex="0" onclick="event.stopPropagation();msDocs.functions.toggleAriaExpanded(this)" class="noSubs"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/new?view=vs-2019" data-text="&amp;lt;new&amp;gt; ">&lt;new&gt;</a><ul role="tree" onclick="msDocs.functions.stopSomePropagation(event, &quot;top&quot;)"><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a onclick="msDocs.functions.stopSomePropagation(event, &quot;left&quot;)" tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/new-functions?view=vs-2019" data-text="&amp;lt;new&amp;gt; functions ">&lt;new&gt; functions</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/new-typedefs?view=vs-2019" data-text="&amp;lt;new&amp;gt; typedefs ">&lt;new&gt; typedefs</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/new-operators?view=vs-2019" data-text="&amp;lt;new&amp;gt; operators ">&lt;new&gt; operators</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/bad-alloc-class?view=vs-2019" data-text="bad_alloc class ">bad_alloc Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/nothrow-t-structure?view=vs-2019" data-text="nothrow_t structure ">nothrow_t Structure</a></li></ul></li><li role="group" data-moniker="vs-2015 vs-2017 vs-2019" aria-expanded="false" aria-label="&amp;lt;numeric&amp;gt; " tabindex="0" onclick="event.stopPropagation();msDocs.functions.toggleAriaExpanded(this)" class="noSubs"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/numeric?view=vs-2019" data-text="&amp;lt;numeric&amp;gt; ">&lt;numeric&gt;</a><ul role="tree" onclick="msDocs.functions.stopSomePropagation(event, &quot;top&quot;)"><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a onclick="msDocs.functions.stopSomePropagation(event, &quot;left&quot;)" tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/numeric-functions?view=vs-2019" data-text="&amp;lt;numeric&amp;gt; functions ">&lt;numeric&gt; functions</a></li></ul></li><li role="group" data-moniker="vs-2015 vs-2017 vs-2019" aria-expanded="false" aria-label="&amp;lt;ostream&amp;gt; " tabindex="0" onclick="event.stopPropagation();msDocs.functions.toggleAriaExpanded(this)" class="noSubs"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/ostream?view=vs-2019" data-text="&amp;lt;ostream&amp;gt; ">&lt;ostream&gt;</a><ul role="tree" onclick="msDocs.functions.stopSomePropagation(event, &quot;top&quot;)"><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a onclick="msDocs.functions.stopSomePropagation(event, &quot;left&quot;)" tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/basic-ostream-class?view=vs-2019" data-text="basic_ostream class ">basic_ostream Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/ostream-functions?view=vs-2019" data-text="&amp;lt;ostream&amp;gt; functions ">&lt;ostream&gt; functions</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/ostream-operators?view=vs-2019" data-text="&amp;lt;ostream&amp;gt; operators ">&lt;ostream&gt; operators</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/ostream-typedefs?view=vs-2019" data-text="&amp;lt;ostream&amp;gt; typedefs ">&lt;ostream&gt; typedefs</a></li></ul></li><li role="group" data-moniker="vs-2015 vs-2017 vs-2019" aria-expanded="false" aria-label="&amp;lt;queue&amp;gt; " tabindex="0" onclick="event.stopPropagation();msDocs.functions.toggleAriaExpanded(this)" class="noSubs"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/queue?view=vs-2019" data-text="&amp;lt;queue&amp;gt; ">&lt;queue&gt;</a><ul role="tree" onclick="msDocs.functions.stopSomePropagation(event, &quot;top&quot;)"><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a onclick="msDocs.functions.stopSomePropagation(event, &quot;left&quot;)" tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/queue-operators?view=vs-2019" data-text="&amp;lt;queue&amp;gt; operators ">&lt;queue&gt; operators</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/priority-queue-class?view=vs-2019" data-text="priority_queue class ">priority_queue Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/queue-class?view=vs-2019" data-text="queue class ">queue Class</a></li></ul></li><li role="group" data-moniker="vs-2015 vs-2017 vs-2019" aria-expanded="false" aria-label="&amp;lt;random&amp;gt; " tabindex="0" onclick="event.stopPropagation();msDocs.functions.toggleAriaExpanded(this)" class="noSubs"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/random?view=vs-2019" data-text="&amp;lt;random&amp;gt; ">&lt;random&gt;</a><ul role="tree" onclick="msDocs.functions.stopSomePropagation(event, &quot;top&quot;)"><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a onclick="msDocs.functions.stopSomePropagation(event, &quot;left&quot;)" tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/random-functions?view=vs-2019" data-text="&amp;lt;random&amp;gt; functions ">&lt;random&gt; functions</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/bernoulli-distribution-class?view=vs-2019" data-text="bernoulli_distribution class ">bernoulli_distribution Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/binomial-distribution-class?view=vs-2019" data-text="binomial_distribution class ">binomial_distribution Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/cauchy-distribution-class?view=vs-2019" data-text="cauchy_distribution class ">cauchy_distribution Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/chi-squared-distribution-class?view=vs-2019" data-text="chi_squared_distribution class ">chi_squared_distribution Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/discard-block-engine-class?view=vs-2019" data-text="discard_block_engine class ">discard_block_engine Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/discrete-distribution-class?view=vs-2019" data-text="discrete_distribution class ">discrete_distribution Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/exponential-distribution-class?view=vs-2019" data-text="exponential_distribution class ">exponential_distribution Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/extreme-value-distribution-class?view=vs-2019" data-text="extreme_value_distribution class ">extreme_value_distribution Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/fisher-f-distribution-class?view=vs-2019" data-text="fisher_f_distribution class ">fisher_f_distribution Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/gamma-distribution-class?view=vs-2019" data-text="gamma_distribution class ">gamma_distribution Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/geometric-distribution-class?view=vs-2019" data-text="geometric_distribution class ">geometric_distribution Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/independent-bits-engine-class?view=vs-2019" data-text="independent_bits_engine class ">independent_bits_engine Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/linear-congruential-engine-class?view=vs-2019" data-text="linear_congruential_engine class ">linear_congruential_engine Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/lognormal-distribution-class?view=vs-2019" data-text="lognormal_distribution class ">lognormal_distribution Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/mersenne-twister-engine-class?view=vs-2019" data-text="mersenne_twister_engine class ">mersenne_twister_engine Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/negative-binomial-distribution-class?view=vs-2019" data-text="negative_binomial_distribution class ">negative_binomial_distribution Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/normal-distribution-class?view=vs-2019" data-text="normal_distribution class ">normal_distribution Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/piecewise-constant-distribution-class?view=vs-2019" data-text="piecewise_constant_distribution class ">piecewise_constant_distribution Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/piecewise-linear-distribution-class?view=vs-2019" data-text="piecewise_linear_distribution class ">piecewise_linear_distribution Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/poisson-distribution-class?view=vs-2019" data-text="poisson_distribution class ">poisson_distribution Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/random-device-class?view=vs-2019" data-text="random_device class ">random_device Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/seed-seq-class?view=vs-2019" data-text="seed_seq class ">seed_seq Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/shuffle-order-engine-class?view=vs-2019" data-text="shuffle_order_engine class ">shuffle_order_engine Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/student-t-distribution-class?view=vs-2019" data-text="student_t_distribution class ">student_t_distribution Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/subtract-with-carry-engine-class?view=vs-2019" data-text="subtract_with_carry_engine class ">subtract_with_carry_engine Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/uniform-int-distribution-class?view=vs-2019" data-text="uniform_int_distribution class ">uniform_int_distribution Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/uniform-real-distribution-class?view=vs-2019" data-text="uniform_real_distribution class ">uniform_real_distribution Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/weibull-distribution-class?view=vs-2019" data-text="weibull_distribution class ">weibull_distribution Class</a></li></ul></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/ratio?view=vs-2019" data-text="&amp;lt;ratio&amp;gt; ">&lt;ratio&gt;</a></li><li role="group" data-moniker="vs-2015 vs-2017 vs-2019" aria-expanded="false" aria-label="&amp;lt;regex&amp;gt; " tabindex="0" onclick="event.stopPropagation();msDocs.functions.toggleAriaExpanded(this)" class="noSubs"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/regex?view=vs-2019" data-text="&amp;lt;regex&amp;gt; ">&lt;regex&gt;</a><ul role="tree" onclick="msDocs.functions.stopSomePropagation(event, &quot;top&quot;)"><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a onclick="msDocs.functions.stopSomePropagation(event, &quot;left&quot;)" tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/regex-functions?view=vs-2019" data-text="&amp;lt;regex&amp;gt; functions ">&lt;regex&gt; functions</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/regex-operators?view=vs-2019" data-text="&amp;lt;regex&amp;gt; operators ">&lt;regex&gt; operators</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/regex-typedefs?view=vs-2019" data-text="&amp;lt;regex&amp;gt; typedefs ">&lt;regex&gt; typedefs</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/basic-regex-class?view=vs-2019" data-text="basic_regex class ">basic_regex Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/match-results-class?view=vs-2019" data-text="match_results class ">match_results Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/regex-constants-class?view=vs-2019" data-text="regex_constants namespace ">regex_constants namespace</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/regex-error-class?view=vs-2019" data-text="regex_error class ">regex_error Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/regex-iterator-class?view=vs-2019" data-text="regex_iterator class ">regex_iterator Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/regex-token-iterator-class?view=vs-2019" data-text="regex_token_iterator class ">regex_token_iterator Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/regex-traits-class?view=vs-2019" data-text="regex_traits class ">regex_traits Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/regex-traits-char-class?view=vs-2019" data-text="regex_traits&amp;lt;char&amp;gt; class ">regex_traits&lt;char&gt; Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/regex-traits-wchar-t-class?view=vs-2019" data-text="regex_traits&amp;lt;wchar_t&amp;gt; class ">regex_traits&lt;wchar_t&gt; Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/sub-match-class?view=vs-2019" data-text="sub_match class ">sub_match Class</a></li></ul></li><li role="group" data-moniker="vs-2015 vs-2017 vs-2019" aria-expanded="false" aria-label="&amp;lt;scoped_allocator&amp;gt; " tabindex="0" onclick="event.stopPropagation();msDocs.functions.toggleAriaExpanded(this)" class="noSubs"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/scoped-allocator?view=vs-2019" data-text="&amp;lt;scoped_allocator&amp;gt; ">&lt;scoped_allocator&gt;</a><ul role="tree" onclick="msDocs.functions.stopSomePropagation(event, &quot;top&quot;)"><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a onclick="msDocs.functions.stopSomePropagation(event, &quot;left&quot;)" tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/scoped-allocator-operators?view=vs-2019" data-text="&amp;lt;scoped_allocator&amp;gt; operators ">&lt;scoped_allocator&gt; operators</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/scoped-allocator-adaptor-class?view=vs-2019" data-text="scoped_allocator_adaptor class ">scoped_allocator_adaptor Class</a></li></ul></li><li role="group" data-moniker="vs-2015 vs-2017 vs-2019" aria-expanded="false" aria-label="&amp;lt;set&amp;gt; " tabindex="0" onclick="event.stopPropagation();msDocs.functions.toggleAriaExpanded(this)" class="noSubs"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/set?view=vs-2019" data-text="&amp;lt;set&amp;gt; ">&lt;set&gt;</a><ul role="tree" onclick="msDocs.functions.stopSomePropagation(event, &quot;top&quot;)"><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a onclick="msDocs.functions.stopSomePropagation(event, &quot;left&quot;)" tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/set-functions?view=vs-2019" data-text="&amp;lt;set&amp;gt; functions ">&lt;set&gt; functions</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/set-operators?view=vs-2019" data-text="&amp;lt;set&amp;gt; operators ">&lt;set&gt; operators</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/set-class?view=vs-2019" data-text="set class ">set Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/multiset-class?view=vs-2019" data-text="multiset class ">multiset Class</a></li></ul></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/shared-mutex?view=vs-2019" data-text="&amp;lt;shared_mutex&amp;gt; ">&lt;shared_mutex&gt;</a></li><li role="group" data-moniker="vs-2015 vs-2017 vs-2019" aria-expanded="false" aria-label="&amp;lt;sstream&amp;gt; " tabindex="0" onclick="event.stopPropagation();msDocs.functions.toggleAriaExpanded(this)" class="noSubs"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/sstream?view=vs-2019" data-text="&amp;lt;sstream&amp;gt; ">&lt;sstream&gt;</a><ul role="tree" onclick="msDocs.functions.stopSomePropagation(event, &quot;top&quot;)"><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a onclick="msDocs.functions.stopSomePropagation(event, &quot;left&quot;)" tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/sstream-functions?view=vs-2019" data-text="&amp;lt;sstream&amp;gt; functions ">&lt;sstream&gt; functions</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/sstream-typedefs?view=vs-2019" data-text="&amp;lt;sstream&amp;gt; typedefs ">&lt;sstream&gt; typedefs</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/basic-stringbuf-class?view=vs-2019" data-text="basic_stringbuf class ">basic_stringbuf Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/basic-istringstream-class?view=vs-2019" data-text="basic_istringstream class ">basic_istringstream Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/basic-ostringstream-class?view=vs-2019" data-text="basic_ostringstream class ">basic_ostringstream Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/basic-stringstream-class?view=vs-2019" data-text="basic_stringstream class ">basic_stringstream Class</a></li></ul></li><li role="group" data-moniker="vs-2015 vs-2017 vs-2019" aria-expanded="false" aria-label="&amp;lt;stack&amp;gt; " tabindex="0" onclick="event.stopPropagation();msDocs.functions.toggleAriaExpanded(this)" class="noSubs"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/stack?view=vs-2019" data-text="&amp;lt;stack&amp;gt; ">&lt;stack&gt;</a><ul role="tree" onclick="msDocs.functions.stopSomePropagation(event, &quot;top&quot;)"><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a onclick="msDocs.functions.stopSomePropagation(event, &quot;left&quot;)" tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/stack-operators?view=vs-2019" data-text="&amp;lt;stack&amp;gt; operators ">&lt;stack&gt; operators</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/stack-class?view=vs-2019" data-text="stack class ">stack Class</a></li></ul></li><li role="group" data-moniker="vs-2015 vs-2017 vs-2019" aria-expanded="false" aria-label="&amp;lt;stdexcept&amp;gt; " tabindex="0" onclick="event.stopPropagation();msDocs.functions.toggleAriaExpanded(this)" class="noSubs"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/stdexcept?view=vs-2019" data-text="&amp;lt;stdexcept&amp;gt; ">&lt;stdexcept&gt;</a><ul role="tree" onclick="msDocs.functions.stopSomePropagation(event, &quot;top&quot;)"><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a onclick="msDocs.functions.stopSomePropagation(event, &quot;left&quot;)" tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/domain-error-class?view=vs-2019" data-text="domain_error class ">domain_error Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/invalid-argument-class?view=vs-2019" data-text="invalid_argument class ">invalid_argument Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/length-error-class?view=vs-2019" data-text="length_error class ">length_error Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/logic-error-class?view=vs-2019" data-text="logic_error class ">logic_error Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/out-of-range-class?view=vs-2019" data-text="out_of_range class ">out_of_range Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/overflow-error-class?view=vs-2019" data-text="overflow_error class ">overflow_error Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/range-error-class?view=vs-2019" data-text="range_error class ">range_error Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/runtime-error-class?view=vs-2019" data-text="runtime_error class ">runtime_error Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/underflow-error-class?view=vs-2019" data-text="underflow_error class ">underflow_error Class</a></li></ul></li><li role="group" data-moniker="vs-2015 vs-2017 vs-2019" aria-expanded="false" aria-label="&amp;lt;streambuf&amp;gt; " tabindex="0" onclick="event.stopPropagation();msDocs.functions.toggleAriaExpanded(this)" class="noSubs"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/streambuf?view=vs-2019" data-text="&amp;lt;streambuf&amp;gt; ">&lt;streambuf&gt;</a><ul role="tree" onclick="msDocs.functions.stopSomePropagation(event, &quot;top&quot;)"><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a onclick="msDocs.functions.stopSomePropagation(event, &quot;left&quot;)" tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/streambuf-typedefs?view=vs-2019" data-text="&amp;lt;streambuf&amp;gt; typedefs ">&lt;streambuf&gt; typedefs</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/basic-streambuf-class?view=vs-2019" data-text="basic_streambuf class ">basic_streambuf Class</a></li></ul></li><li role="group" data-moniker="vs-2015 vs-2017 vs-2019" aria-expanded="false" aria-label="&amp;lt;string&amp;gt; " tabindex="0" onclick="event.stopPropagation();msDocs.functions.toggleAriaExpanded(this)" class="noSubs"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/string?view=vs-2019" data-text="&amp;lt;string&amp;gt; ">&lt;string&gt;</a><ul role="tree" onclick="msDocs.functions.stopSomePropagation(event, &quot;top&quot;)"><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a onclick="msDocs.functions.stopSomePropagation(event, &quot;left&quot;)" tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/string-functions?view=vs-2019" data-text="&amp;lt;string&amp;gt; functions ">&lt;string&gt; functions</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/string-operators?view=vs-2019" data-text="&amp;lt;string&amp;gt; operators ">&lt;string&gt; operators</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/string-typedefs?view=vs-2019" data-text="&amp;lt;string&amp;gt; typedefs ">&lt;string&gt; typedefs</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/basic-string-class?view=vs-2019" data-text="basic_string class ">basic_string Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/char-traits-struct?view=vs-2019" data-text="char_traits struct ">char_traits Struct</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/char-traits-char-struct?view=vs-2019" data-text="char_traits&amp;lt;char&amp;gt; struct ">char_traits&lt;char&gt; Struct</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/char-traits-char16-t-struct?view=vs-2019" data-text="char_traits&amp;lt;char16_t&amp;gt; struct ">char_traits&lt;char16_t&gt; Struct</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/char-traits-char32-t-struct?view=vs-2019" data-text="char_traits&amp;lt;char32_t&amp;gt; struct ">char_traits&lt;char32_t&gt; Struct</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/char-traits-wchar-t-struct?view=vs-2019" data-text="char_traits&amp;lt;wchar_t&amp;gt; struct ">char_traits&lt;wchar_t&gt; Struct</a></li></ul></li><li role="group" data-moniker="vs-2015 vs-2017 vs-2019" aria-expanded="false" aria-label="&amp;lt;string_view&amp;gt; " tabindex="0" onclick="event.stopPropagation();msDocs.functions.toggleAriaExpanded(this)" class="noSubs"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/string-view?view=vs-2019" data-text="&amp;lt;string_view&amp;gt; ">&lt;string_view&gt;</a><ul role="tree" onclick="msDocs.functions.stopSomePropagation(event, &quot;top&quot;)"><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a onclick="msDocs.functions.stopSomePropagation(event, &quot;left&quot;)" tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/string-view-operators?view=vs-2019" data-text="&amp;lt;string_view&amp;gt; operators ">&lt;string_view&gt; operators</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/string-view-typedefs?view=vs-2019" data-text="&amp;lt;string_view&amp;gt; typedefs ">&lt;string_view&gt; typedefs</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/basic-string-view-class?view=vs-2019" data-text="basic_string_view class ">basic_string_view Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/string-view-hash?view=vs-2019" data-text="hash&amp;lt;string_view&amp;gt; specialization ">hash&lt;string_view&gt; Specialization</a></li></ul></li><li role="group" data-moniker="vs-2015 vs-2017 vs-2019" aria-expanded="false" aria-label="&amp;lt;strstream&amp;gt; " tabindex="0" onclick="event.stopPropagation();msDocs.functions.toggleAriaExpanded(this)" class="noSubs"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/strstream?view=vs-2019" data-text="&amp;lt;strstream&amp;gt; ">&lt;strstream&gt;</a><ul role="tree" onclick="msDocs.functions.stopSomePropagation(event, &quot;top&quot;)"><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a onclick="msDocs.functions.stopSomePropagation(event, &quot;left&quot;)" tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/strstreambuf-class?view=vs-2019" data-text="strstreambuf class ">strstreambuf Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/istrstream-class?view=vs-2019" data-text="istrstream class ">istrstream Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/ostrstream-class?view=vs-2019" data-text="ostrstream class ">ostrstream Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/strstream-class?view=vs-2019" data-text="strstream class ">strstream Class</a></li></ul></li><li role="group" data-moniker="vs-2015 vs-2017 vs-2019" aria-expanded="false" aria-label="&amp;lt;system_error&amp;gt; " tabindex="0" onclick="event.stopPropagation();msDocs.functions.toggleAriaExpanded(this)" class="noSubs"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/system-error?view=vs-2019" data-text="&amp;lt;system_error&amp;gt; ">&lt;system_error&gt;</a><ul role="tree" onclick="msDocs.functions.stopSomePropagation(event, &quot;top&quot;)"><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a onclick="msDocs.functions.stopSomePropagation(event, &quot;left&quot;)" tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/system-error-functions?view=vs-2019" data-text="&amp;lt;system_error&amp;gt; functions ">&lt;system_error&gt; functions</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/system-error-operators?view=vs-2019" data-text="&amp;lt;system_error&amp;gt; operators ">&lt;system_error&gt; operators</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/system-error-enums?view=vs-2019" data-text="&amp;lt;system_error&amp;gt; enums ">&lt;system_error&gt; enums</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/error-category-class?view=vs-2019" data-text="error_category class ">error_category Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/error-code-class?view=vs-2019" data-text="error_code class ">error_code Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/error-condition-class?view=vs-2019" data-text="error_condition class ">error_condition Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/is-error-code-enum-class?view=vs-2019" data-text="is_error_code_enum class ">is_error_code_enum Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/is-error-condition-enum-class?view=vs-2019" data-text="is_error_condition_enum class ">is_error_condition_enum Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/system-error-class?view=vs-2019" data-text="system_error class ">system_error Class</a></li></ul></li><li role="group" data-moniker="vs-2015 vs-2017 vs-2019" aria-expanded="false" aria-label="&amp;lt;thread&amp;gt; " tabindex="0" onclick="event.stopPropagation();msDocs.functions.toggleAriaExpanded(this)" class="noSubs"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/thread?view=vs-2019" data-text="&amp;lt;thread&amp;gt; ">&lt;thread&gt;</a><ul role="tree" onclick="msDocs.functions.stopSomePropagation(event, &quot;top&quot;)"><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a onclick="msDocs.functions.stopSomePropagation(event, &quot;left&quot;)" tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/thread-functions?view=vs-2019" data-text="&amp;lt;thread&amp;gt; functions ">&lt;thread&gt; functions</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/thread-operators?view=vs-2019" data-text="&amp;lt;thread&amp;gt; operators ">&lt;thread&gt; operators</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/hash-structure-stl?view=vs-2019" data-text="hash structure (c++ standard library) ">hash Structure (C++ Standard Library)</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/thread-class?view=vs-2019" data-text="thread class ">thread Class</a></li></ul></li><li role="group" data-moniker="vs-2015 vs-2017 vs-2019" aria-expanded="false" aria-label="&amp;lt;tuple&amp;gt; " tabindex="0" onclick="event.stopPropagation();msDocs.functions.toggleAriaExpanded(this)" class="noSubs"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/tuple?view=vs-2019" data-text="&amp;lt;tuple&amp;gt; ">&lt;tuple&gt;</a><ul role="tree" onclick="msDocs.functions.stopSomePropagation(event, &quot;top&quot;)"><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a onclick="msDocs.functions.stopSomePropagation(event, &quot;left&quot;)" tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/tuple-functions?view=vs-2019" data-text="&amp;lt;tuple&amp;gt; functions ">&lt;tuple&gt; functions</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/tuple-operators?view=vs-2019" data-text="&amp;lt;tuple&amp;gt; operators ">&lt;tuple&gt; operators</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/tuple-class?view=vs-2019" data-text="tuple class ">tuple Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/tuple-element-class-tuple?view=vs-2019" data-text="tuple_element class &amp;lt;tuple&amp;gt; ">tuple_element Class &lt;tuple&gt;</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/tuple-size-class-tuple?view=vs-2019" data-text="tuple_size class &amp;lt;tuple&amp;gt; ">tuple_size Class &lt;tuple&gt;</a></li></ul></li><li role="group" data-moniker="vs-2015 vs-2017 vs-2019" aria-expanded="false" aria-label="&amp;lt;type_traits&amp;gt; " tabindex="0" onclick="event.stopPropagation();msDocs.functions.toggleAriaExpanded(this)" class="noSubs"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/type-traits?view=vs-2019" data-text="&amp;lt;type_traits&amp;gt; ">&lt;type_traits&gt;</a><ul role="tree" onclick="msDocs.functions.stopSomePropagation(event, &quot;top&quot;)"><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a onclick="msDocs.functions.stopSomePropagation(event, &quot;left&quot;)" tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/add-const-class?view=vs-2019" data-text="add_const class ">add_const Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/add-cv-class?view=vs-2019" data-text="add_cv class ">add_cv Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/add-lvalue-reference-class?view=vs-2019" data-text="add_lvalue_reference class ">add_lvalue_reference Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/add-rvalue-reference-class?view=vs-2019" data-text="add_rvalue_reference class ">add_rvalue_reference Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/add-pointer-class?view=vs-2019" data-text="add_pointer class ">add_pointer Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/add-volatile-class?view=vs-2019" data-text="add_volatile class ">add_volatile Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/aligned-storage-class?view=vs-2019" data-text="aligned_storage class ">aligned_storage Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/aligned-union-class?view=vs-2019" data-text="aligned_union class ">aligned_union Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/alignment-of-class?view=vs-2019" data-text="alignment_of class ">alignment_of Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/common-type-class?view=vs-2019" data-text="common_type class ">common_type Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/conditional-class?view=vs-2019" data-text="conditional class ">conditional Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/decay-class?view=vs-2019" data-text="decay class ">decay Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/enable-if-class?view=vs-2019" data-text="enable_if class ">enable_if Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/extent-class?view=vs-2019" data-text="extent class ">extent Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/integer-sequence-class?view=vs-2019" data-text="integer_sequence class ">integer_sequence Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/integral-constant-class-bool-constant-class?view=vs-2019" data-text="integral_constant class, bool_constant class ">integral_constant Class, bool_constant Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/invoke-result-class?view=vs-2019" data-text="invoke_result class ">invoke_result Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/is-abstract-class?view=vs-2019" data-text="is_abstract class ">is_abstract Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/is-arithmetic-class?view=vs-2019" data-text="is_arithmetic class ">is_arithmetic Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/is-array-class?view=vs-2019" data-text="is_array class ">is_array Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/is-assignable-class?view=vs-2019" data-text="is_assignable class ">is_assignable Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/is-base-of-class?view=vs-2019" data-text="is_base_of class ">is_base_of Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/is-class-class?view=vs-2019" data-text="is_class class ">is_class Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/is-compound-class?view=vs-2019" data-text="is_compound class ">is_compound Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/is-const-class?view=vs-2019" data-text="is_const class ">is_const Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/is-constructible-class?view=vs-2019" data-text="is_constructible class ">is_constructible Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/is-convertible-class?view=vs-2019" data-text="is_convertible class ">is_convertible Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/is-copy-assignable-class?view=vs-2019" data-text="is_copy_assignable class ">is_copy_assignable Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/is-copy-constructible-class?view=vs-2019" data-text="is_copy_constructible class ">is_copy_constructible Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/is-default-constructible-class?view=vs-2019" data-text="is_default_constructible class ">is_default_constructible Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/is-destructible-class?view=vs-2019" data-text="is_destructible class ">is_destructible Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/is-empty-class?view=vs-2019" data-text="is_empty class ">is_empty Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/is-enum-class?view=vs-2019" data-text="is_enum class ">is_enum Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/is-final-class?view=vs-2019" data-text="is_final class ">is_final Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/is-floating-point-class?view=vs-2019" data-text="is_floating_point class ">is_floating_point Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/is-function-class?view=vs-2019" data-text="is_function class ">is_function Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/is-fundamental-class?view=vs-2019" data-text="is_fundamental class ">is_fundamental Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/is-integral-class?view=vs-2019" data-text="is_integral class ">is_integral Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/is-invocable-classes?view=vs-2019" data-text="is_invocable classes ">is_invocable classes</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/is-literal-type-class?view=vs-2019" data-text="is_literal_type class ">is_literal_type Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/is-lvalue-reference-class?view=vs-2019" data-text="is_lvalue_reference class ">is_lvalue_reference Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/is-member-function-pointer-class?view=vs-2019" data-text="is_member_function_pointer class ">is_member_function_pointer Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/is-member-object-pointer-class?view=vs-2019" data-text="is_member_object_pointer class ">is_member_object_pointer Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/is-member-pointer-class?view=vs-2019" data-text="is_member_pointer class ">is_member_pointer Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/is-move-assignable-class?view=vs-2019" data-text="is_move_assignable class ">is_move_assignable Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/is-move-constructible-class?view=vs-2019" data-text="is_move_constructible class ">is_move_constructible Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/is-nothrow-assignable-class?view=vs-2019" data-text="is_nothrow_assignable class ">is_nothrow_assignable Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/is-nothrow-constructible-class?view=vs-2019" data-text="is_nothrow_constructible class ">is_nothrow_constructible Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/is-nothrow-copy-assignable-class?view=vs-2019" data-text="is_nothrow_copy_assignable class ">is_nothrow_copy_assignable Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/is-nothrow-copy-constructible-class?view=vs-2019" data-text="is_nothrow_copy_constructible class ">is_nothrow_copy_constructible Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/is-nothrow-default-constructible-class?view=vs-2019" data-text="is_nothrow_default_constructible class ">is_nothrow_default_constructible Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/is-nothrow-destructible-class?view=vs-2019" data-text="is_nothrow_destructible class ">is_nothrow_destructible Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/is-nothrow-move-assignable-class?view=vs-2019" data-text="is_nothrow_move_assignable class ">is_nothrow_move_assignable Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/is-nothrow-move-constructible-class?view=vs-2019" data-text="is_nothrow_move_constructible class ">is_nothrow_move_constructible Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/is-null-pointer-class?view=vs-2019" data-text="is_null_pointer class ">is_null_pointer Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/is-object-class?view=vs-2019" data-text="is_object class ">is_object Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/is-pod-class?view=vs-2019" data-text="is_pod class ">is_pod Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/is-pointer-class?view=vs-2019" data-text="is_pointer class ">is_pointer Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/is-polymorphic-class?view=vs-2019" data-text="is_polymorphic class ">is_polymorphic Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/is-reference-class?view=vs-2019" data-text="is_reference class ">is_reference Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/is-rvalue-reference-class?view=vs-2019" data-text="is_rvalue_reference class ">is_rvalue_reference Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/is-same-class?view=vs-2019" data-text="is_same class ">is_same Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/is-scalar-class?view=vs-2019" data-text="is_scalar class ">is_scalar Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/is-signed-class?view=vs-2019" data-text="is_signed class ">is_signed Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/is-standard-layout-class?view=vs-2019" data-text="is_standard_layout class ">is_standard_layout Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/is-trivial-class?view=vs-2019" data-text="is_trivial class ">is_trivial Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/is-trivially-assignable-class?view=vs-2019" data-text="is_trivially_assignable class ">is_trivially_assignable Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/is-trivially-constructible-class?view=vs-2019" data-text="is_trivially_constructible class ">is_trivially_constructible Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/is-trivially-copy-assignable-class?view=vs-2019" data-text="is_trivially_copy_assignable class ">is_trivially_copy_assignable Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/is-trivially-copy-constructible-class?view=vs-2019" data-text="is_trivially_copy_constructible class ">is_trivially_copy_constructible Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/is-trivially-copyable-class?view=vs-2019" data-text="is_trivially_copyable class ">is_trivially_copyable Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/is-trivially-default-constructible-class?view=vs-2019" data-text="is_trivially_default_constructible class ">is_trivially_default_constructible Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/is-trivially-destructible-class?view=vs-2019" data-text="is_trivially_destructible class ">is_trivially_destructible Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/is-trivially-move-assignable-class?view=vs-2019" data-text="is_trivially_move_assignable class ">is_trivially_move_assignable Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/is-trivially-move-constructible-class?view=vs-2019" data-text="is_trivially_move_constructible class ">is_trivially_move_constructible Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/is-union-class?view=vs-2019" data-text="is_union class ">is_union Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/is-unsigned-class?view=vs-2019" data-text="is_unsigned class ">is_unsigned Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/is-void-class?view=vs-2019" data-text="is_void class ">is_void Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/is-volatile-class?view=vs-2019" data-text="is_volatile class ">is_volatile Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/make-signed-class?view=vs-2019" data-text="make_signed class ">make_signed Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/make-unsigned-class?view=vs-2019" data-text="make_unsigned class ">make_unsigned Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/rank-class?view=vs-2019" data-text="rank class ">rank Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/remove-all-extents-class?view=vs-2019" data-text="remove_all_extents class ">remove_all_extents Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/remove-const-class?view=vs-2019" data-text="remove_const class ">remove_const Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/remove-cv-class?view=vs-2019" data-text="remove_cv class ">remove_cv Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/remove-extent-class?view=vs-2019" data-text="remove_extent class ">remove_extent Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/remove-pointer-class?view=vs-2019" data-text="remove_pointer class ">remove_pointer Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/remove-reference-class?view=vs-2019" data-text="remove_reference class ">remove_reference Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/remove-volatile-class?view=vs-2019" data-text="remove_volatile class ">remove_volatile Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/result-of-class?view=vs-2019" data-text="result_of class ">result_of Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/underlying-type-class?view=vs-2019" data-text="underlying_type class ">underlying_type Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/type-traits-functions?view=vs-2019" data-text="&amp;lt;type_traits&amp;gt; functions ">&lt;type_traits&gt; functions</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/type-traits-typedefs?view=vs-2019" data-text="&amp;lt;type_traits&amp;gt; typedefs ">&lt;type_traits&gt; typedefs</a></li></ul></li><li role="group" data-moniker="vs-2015 vs-2017 vs-2019" aria-expanded="false" aria-label="&amp;lt;typeindex&amp;gt; " tabindex="0" onclick="event.stopPropagation();msDocs.functions.toggleAriaExpanded(this)" class="noSubs"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/typeindex?view=vs-2019" data-text="&amp;lt;typeindex&amp;gt; ">&lt;typeindex&gt;</a><ul role="tree" onclick="msDocs.functions.stopSomePropagation(event, &quot;top&quot;)"><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a onclick="msDocs.functions.stopSomePropagation(event, &quot;left&quot;)" tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/hash-structure?view=vs-2019" data-text="hash structure ">hash Structure</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/type-index-class?view=vs-2019" data-text="type_index class ">type_index Class</a></li></ul></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/typeinfo?view=vs-2019" data-text="&amp;lt;typeinfo&amp;gt; ">&lt;typeinfo&gt;</a></li><li role="group" data-moniker="vs-2015 vs-2017 vs-2019" aria-expanded="false" aria-label="&amp;lt;unordered_map&amp;gt; " tabindex="0" onclick="event.stopPropagation();msDocs.functions.toggleAriaExpanded(this)" class="noSubs"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/unordered-map?view=vs-2019" data-text="&amp;lt;unordered_map&amp;gt; ">&lt;unordered_map&gt;</a><ul role="tree" onclick="msDocs.functions.stopSomePropagation(event, &quot;top&quot;)"><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a onclick="msDocs.functions.stopSomePropagation(event, &quot;left&quot;)" tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/unordered-map-functions?view=vs-2019" data-text="&amp;lt;unordered_map&amp;gt; functions ">&lt;unordered_map&gt; functions</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/unordered-map-operators?view=vs-2019" data-text="&amp;lt;unordered_map&amp;gt; operators ">&lt;unordered_map&gt; operators</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/unordered-map-class?view=vs-2019" data-text="unordered_map class ">unordered_map Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/unordered-multimap-class?view=vs-2019" data-text="unordered_multimap class ">unordered_multimap Class</a></li></ul></li><li role="group" data-moniker="vs-2015 vs-2017 vs-2019" aria-expanded="false" aria-label="&amp;lt;unordered_set&amp;gt; " tabindex="0" onclick="event.stopPropagation();msDocs.functions.toggleAriaExpanded(this)" class="noSubs"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/unordered-set?view=vs-2019" data-text="&amp;lt;unordered_set&amp;gt; ">&lt;unordered_set&gt;</a><ul role="tree" onclick="msDocs.functions.stopSomePropagation(event, &quot;top&quot;)"><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a onclick="msDocs.functions.stopSomePropagation(event, &quot;left&quot;)" tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/unordered-set-functions?view=vs-2019" data-text="&amp;lt;unordered_set&amp;gt; functions ">&lt;unordered_set&gt; functions</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/unordered-set-operators?view=vs-2019" data-text="&amp;lt;unordered_set&amp;gt; operators ">&lt;unordered_set&gt; operators</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/unordered-set-class?view=vs-2019" data-text="unordered_set class ">unordered_set Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/unordered-multiset-class?view=vs-2019" data-text="unordered_multiset class ">unordered_multiset Class</a></li></ul></li><li role="group" data-moniker="vs-2015 vs-2017 vs-2019" aria-expanded="false" aria-label="&amp;lt;utility&amp;gt; " tabindex="0" onclick="event.stopPropagation();msDocs.functions.toggleAriaExpanded(this)" class="noSubs"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/utility?view=vs-2019" data-text="&amp;lt;utility&amp;gt; ">&lt;utility&gt;</a><ul role="tree" onclick="msDocs.functions.stopSomePropagation(event, &quot;top&quot;)"><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a onclick="msDocs.functions.stopSomePropagation(event, &quot;left&quot;)" tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/utility-functions?view=vs-2019" data-text="&amp;lt;utility&amp;gt; functions ">&lt;utility&gt; functions</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/utility-operators?view=vs-2019" data-text="&amp;lt;utility&amp;gt; operators ">&lt;utility&gt; operators</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/identity-structure?view=vs-2019" data-text="identity structure ">identity Structure</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/pair-structure?view=vs-2019" data-text="pair structure ">pair Structure</a></li></ul></li><li role="group" data-moniker="vs-2015 vs-2017 vs-2019" aria-expanded="false" aria-label="&amp;lt;valarray&amp;gt; " tabindex="0" onclick="event.stopPropagation();msDocs.functions.toggleAriaExpanded(this)" class="noSubs"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/valarray?view=vs-2019" data-text="&amp;lt;valarray&amp;gt; ">&lt;valarray&gt;</a><ul role="tree" onclick="msDocs.functions.stopSomePropagation(event, &quot;top&quot;)"><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a onclick="msDocs.functions.stopSomePropagation(event, &quot;left&quot;)" tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/valarray-functions?view=vs-2019" data-text="&amp;lt;valarray&amp;gt; functions ">&lt;valarray&gt; functions</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/valarray-operators?view=vs-2019" data-text="&amp;lt;valarray&amp;gt; operators ">&lt;valarray&gt; operators</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/gslice-class?view=vs-2019" data-text="gslice class ">gslice Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/gslice-array-class?view=vs-2019" data-text="gslice_array class ">gslice_array Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/indirect-array-class?view=vs-2019" data-text="indirect_array class ">indirect_array Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/mask-array-class?view=vs-2019" data-text="mask_array class ">mask_array Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/slice-class?view=vs-2019" data-text="slice class ">slice Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/slice-array-class?view=vs-2019" data-text="slice_array class ">slice_array Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/valarray-class?view=vs-2019" data-text="valarray class ">valarray Class</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/valarray-bool-class?view=vs-2019" data-text="valarray&amp;lt;bool&amp;gt; class ">valarray&lt;bool&gt; Class</a></li></ul></li><li role="group" data-moniker="vs-2015 vs-2017 vs-2019" aria-expanded="false" aria-label="&amp;lt;vector&amp;gt; " tabindex="0" onclick="event.stopPropagation();msDocs.functions.toggleAriaExpanded(this)"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/vector?view=vs-2019" data-text="&amp;lt;vector&amp;gt; ">&lt;vector&gt;</a><ul role="tree" onclick="msDocs.functions.stopSomePropagation(event, &quot;top&quot;)"><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a onclick="msDocs.functions.stopSomePropagation(event, &quot;left&quot;)" tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/vector-class?view=vs-2019" data-text="vector class ">vector Class</a></li><li role="group" data-moniker="vs-2015 vs-2017 vs-2019" aria-expanded="false" aria-label="vector&amp;lt;bool&amp;gt; class " tabindex="0" onclick="event.stopPropagation();msDocs.functions.toggleAriaExpanded(this)"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/vector-bool-class?view=vs-2019" data-text="vector&amp;lt;bool&amp;gt; class ">vector&lt;bool&gt; Class</a><ul role="tree" onclick="msDocs.functions.stopSomePropagation(event, &quot;top&quot;)"><li role="group" data-moniker="vs-2015 vs-2017 vs-2019" aria-expanded="false" aria-label="vector&amp;lt;bool&amp;gt;::reference class " tabindex="0" onclick="event.stopPropagation();msDocs.functions.toggleAriaExpanded(this)" class="noSubs"><a onclick="msDocs.functions.stopSomePropagation(event, &quot;left&quot;)" tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/vector-bool-reference-class?view=vs-2019" data-text="vector&amp;lt;bool&amp;gt;::reference class ">vector&lt;bool&gt;::reference Class</a><ul role="tree" onclick="msDocs.functions.stopSomePropagation(event, &quot;top&quot;)"><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a onclick="msDocs.functions.stopSomePropagation(event, &quot;left&quot;)" tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/vector-bool-reference-flip?view=vs-2019" data-text="vector&amp;lt;bool&amp;gt;::reference::flip ">vector&lt;bool&gt;::reference::flip</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/vector-bool-reference-operator-bool?view=vs-2019" data-text="vector&amp;lt;bool&amp;gt;::reference::operator bool ">vector&lt;bool&gt;::reference::operator bool</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/vector-bool-reference-operator-assign?view=vs-2019" data-text="vector&amp;lt;bool&amp;gt;::reference::operator= ">vector&lt;bool&gt;::reference::operator=</a></li></ul></li></ul></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/vector-functions?view=vs-2019" data-text="&amp;lt;vector&amp;gt; functions ">&lt;vector&gt; functions</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/vector-operators?view=vs-2019" data-text="&amp;lt;vector&amp;gt; operators ">&lt;vector&gt; operators</a></li></ul></li></ul></li><li role="group" data-moniker="vs-2015 vs-2017 vs-2019" aria-expanded="false" aria-label="c++ standard library overview " tabindex="0" onclick="event.stopPropagation();msDocs.functions.toggleAriaExpanded(this)"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/cpp-standard-library-overview?view=vs-2019" data-text="c++ standard library overview ">C++ Standard Library Overview</a><ul role="tree" onclick="msDocs.functions.stopSomePropagation(event, &quot;top&quot;)"><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a onclick="msDocs.functions.stopSomePropagation(event, &quot;left&quot;)" tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/using-cpp-library-headers?view=vs-2019" data-text="using c++ library headers ">Using C++ Library Headers</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/cpp-library-conventions?view=vs-2019" data-text="c++ library conventions ">C++ Library Conventions</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/cpp-program-startup-and-termination?view=vs-2019" data-text="c++ program startup and termination ">C++ Program Startup and Termination</a></li><li role="group" data-moniker="vs-2015 vs-2017 vs-2019" aria-expanded="false" aria-label="safe libraries: c++ standard library " tabindex="0" onclick="event.stopPropagation();msDocs.functions.toggleAriaExpanded(this)"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/safe-libraries-cpp-standard-library?view=vs-2019" data-text="safe libraries: c++ standard library ">Safe Libraries: C++ Standard Library</a><ul role="tree" onclick="msDocs.functions.stopSomePropagation(event, &quot;top&quot;)"><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a onclick="msDocs.functions.stopSomePropagation(event, &quot;left&quot;)" tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/iterator-debug-level?view=vs-2019" data-text="_iterator_debug_level ">_ITERATOR_DEBUG_LEVEL</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/scl-secure-no-warnings?view=vs-2019" data-text="_scl_secure_no_warnings ">_SCL_SECURE_NO_WARNINGS</a></li><li role="group" data-moniker="vs-2015 vs-2017 vs-2019" aria-expanded="false" aria-label="checked iterators " tabindex="0" onclick="event.stopPropagation();msDocs.functions.toggleAriaExpanded(this)" class="noSubs"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/checked-iterators?view=vs-2019" data-text="checked iterators ">Checked Iterators</a><ul role="tree" onclick="msDocs.functions.stopSomePropagation(event, &quot;top&quot;)"><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a onclick="msDocs.functions.stopSomePropagation(event, &quot;left&quot;)" tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/secure-scl?view=vs-2019" data-text="_secure_scl ">_SECURE_SCL</a></li></ul></li><li role="group" data-moniker="vs-2015 vs-2017 vs-2019" aria-expanded="false" aria-label="debug iterator support " tabindex="0" onclick="event.stopPropagation();msDocs.functions.toggleAriaExpanded(this)" class="noSubs"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/debug-iterator-support?view=vs-2019" data-text="debug iterator support ">Debug Iterator Support</a><ul role="tree" onclick="msDocs.functions.stopSomePropagation(event, &quot;top&quot;)"><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a onclick="msDocs.functions.stopSomePropagation(event, &quot;left&quot;)" tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/has-iterator-debugging?view=vs-2019" data-text="_has_iterator_debugging ">_HAS_ITERATOR_DEBUGGING</a></li></ul></li></ul></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/thread-safety-in-the-cpp-standard-library?view=vs-2019" data-text="thread safety in the c++ standard library ">Thread Safety in the C++ Standard Library</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/stdext-namespace?view=vs-2019" data-text="stdext namespace ">stdext Namespace</a></li></ul></li><li role="group" data-moniker="vs-2015 vs-2017 vs-2019" aria-expanded="false" aria-label="c++ standard library containers " tabindex="0" onclick="event.stopPropagation();msDocs.functions.toggleAriaExpanded(this)"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/stl-containers?view=vs-2019" data-text="c++ standard library containers ">C++ Standard Library Containers</a><ul role="tree" onclick="msDocs.functions.stopSomePropagation(event, &quot;top&quot;)"><li role="group" data-moniker="vs-2015 vs-2017 vs-2019" aria-expanded="false" aria-label="&amp;lt;sample container&amp;gt; " tabindex="0" onclick="event.stopPropagation();msDocs.functions.toggleAriaExpanded(this)"><a onclick="msDocs.functions.stopSomePropagation(event, &quot;left&quot;)" tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/sample-container?view=vs-2019" data-text="&amp;lt;sample container&amp;gt; ">&lt;sample container&gt;</a><ul role="tree" onclick="msDocs.functions.stopSomePropagation(event, &quot;top&quot;)"><li role="group" data-moniker="vs-2015 vs-2017 vs-2019" aria-expanded="false" aria-label="&amp;lt;sample container&amp;gt; operators " tabindex="0" onclick="event.stopPropagation();msDocs.functions.toggleAriaExpanded(this)" class="noSubs"><a onclick="msDocs.functions.stopSomePropagation(event, &quot;left&quot;)" tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/sample-container-operators?view=vs-2019" data-text="&amp;lt;sample container&amp;gt; operators ">&lt;sample container&gt; Operators</a><ul role="tree" onclick="msDocs.functions.stopSomePropagation(event, &quot;top&quot;)"><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a onclick="msDocs.functions.stopSomePropagation(event, &quot;left&quot;)" tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/operator-inequality?view=vs-2019" data-text="operator!= ">operator!=</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/operator-equality-sample-container?view=vs-2019" data-text="operator== (&amp;lt;sample container&amp;gt;) ">operator== (&lt;sample container&gt;)</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/operator-less-than-sample-container?view=vs-2019" data-text="operator&amp;lt; (&amp;lt;sample container&amp;gt;) ">operator&lt; (&lt;sample container&gt;)</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/operator-less-or-equal-sample-container?view=vs-2019" data-text="operator&amp;lt;= (&amp;lt;sample container&amp;gt;) ">operator&lt;= (&lt;sample container&gt;)</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/operator-greater-than-sample-container?view=vs-2019" data-text="operator&amp;gt; (&amp;lt;sample container&amp;gt;) ">operator&gt; (&lt;sample container&gt;)</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/operator-greater-or-equal?view=vs-2019" data-text="operator&amp;gt;= ">operator&gt;=</a></li></ul></li><li role="group" data-moniker="vs-2015 vs-2017 vs-2019" aria-expanded="false" aria-label="&amp;lt;sample container&amp;gt; specialized template functions " tabindex="0" onclick="event.stopPropagation();msDocs.functions.toggleAriaExpanded(this)" class="noSubs"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/sample-container-specialized-template-functions?view=vs-2019" data-text="&amp;lt;sample container&amp;gt; specialized template functions ">&lt;sample container&gt; Specialized Template Functions</a><ul role="tree" onclick="msDocs.functions.stopSomePropagation(event, &quot;top&quot;)"><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a onclick="msDocs.functions.stopSomePropagation(event, &quot;left&quot;)" tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/swap-sample-container?view=vs-2019" data-text="swap (&amp;lt;sample container&amp;gt;) ">swap (&lt;sample container&gt;)</a></li></ul></li><li role="group" data-moniker="vs-2015 vs-2017 vs-2019" aria-expanded="false" aria-label="&amp;lt;sample container&amp;gt; classes " tabindex="0" onclick="event.stopPropagation();msDocs.functions.toggleAriaExpanded(this)"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/sample-container-classes?view=vs-2019" data-text="&amp;lt;sample container&amp;gt; classes ">&lt;sample container&gt; Classes</a><ul role="tree" onclick="msDocs.functions.stopSomePropagation(event, &quot;top&quot;)"><li role="group" data-moniker="vs-2015 vs-2017 vs-2019" aria-expanded="false" aria-label="sample container class " tabindex="0" onclick="event.stopPropagation();msDocs.functions.toggleAriaExpanded(this)"><a onclick="msDocs.functions.stopSomePropagation(event, &quot;left&quot;)" tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/sample-container-class?view=vs-2019" data-text="sample container class ">Sample Container Class</a><ul role="tree" onclick="msDocs.functions.stopSomePropagation(event, &quot;top&quot;)"><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a onclick="msDocs.functions.stopSomePropagation(event, &quot;left&quot;)" tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/sample-container-members?view=vs-2019" data-text="sample container members ">Sample Container Members</a></li><li role="group" data-moniker="vs-2015 vs-2017 vs-2019" aria-expanded="false" aria-label="sample container typedefs " tabindex="0" onclick="event.stopPropagation();msDocs.functions.toggleAriaExpanded(this)" class="noSubs"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/sample-container-typedefs?view=vs-2019" data-text="sample container typedefs ">Sample Container Typedefs</a><ul role="tree" onclick="msDocs.functions.stopSomePropagation(event, &quot;top&quot;)"><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a onclick="msDocs.functions.stopSomePropagation(event, &quot;left&quot;)" tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/container-class-const-iterator?view=vs-2019" data-text="container class::const_iterator ">Container Class::const_iterator</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/container-class-const-reference?view=vs-2019" data-text="container class::const_reference ">Container Class::const_reference</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/container-class-const-reverse-iterator?view=vs-2019" data-text="container class::const_reverse_iterator ">Container Class::const_reverse_iterator</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/container-class-difference-type?view=vs-2019" data-text="container class::difference_type ">Container Class::difference_type</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/container-class-iterator?view=vs-2019" data-text="container class::iterator ">Container Class::iterator</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/container-class-reference?view=vs-2019" data-text="container class::reference ">Container Class::reference</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/container-class-reverse-iterator?view=vs-2019" data-text="container class::reverse_iterator ">Container Class::reverse_iterator</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/container-class-size-type?view=vs-2019" data-text="container class::size_type ">Container Class::size_type</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/container-class-value-type?view=vs-2019" data-text="container class::value_type ">Container Class::value_type</a></li></ul></li><li role="group" data-moniker="vs-2015 vs-2017 vs-2019" aria-expanded="false" aria-label="sample container member functions " tabindex="0" onclick="event.stopPropagation();msDocs.functions.toggleAriaExpanded(this)" class="noSubs"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/sample-container-member-functions?view=vs-2019" data-text="sample container member functions ">Sample Container Member Functions</a><ul role="tree" onclick="msDocs.functions.stopSomePropagation(event, &quot;top&quot;)"><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a onclick="msDocs.functions.stopSomePropagation(event, &quot;left&quot;)" tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/container-class-begin?view=vs-2019" data-text="container class::begin ">Container Class::begin</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/container-class-clear?view=vs-2019" data-text="container class::clear ">Container Class::clear</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/container-class-empty?view=vs-2019" data-text="container class::empty ">Container Class::empty</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/container-class-end?view=vs-2019" data-text="container class::end ">Container Class::end</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/container-class-erase?view=vs-2019" data-text="container class::erase ">Container Class::erase</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/container-class-max-size?view=vs-2019" data-text="container class::max_size ">Container Class::max_size</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/container-class-rbegin?view=vs-2019" data-text="container class::rbegin ">Container Class::rbegin</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/container-class-rend?view=vs-2019" data-text="container class::rend ">Container Class::rend</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/container-class-size?view=vs-2019" data-text="container class::size ">Container Class::size</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/container-class-swap?view=vs-2019" data-text="container class::swap ">Container Class::swap</a></li></ul></li></ul></li></ul></li></ul></li></ul></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/iterators?view=vs-2019" data-text="iterators ">Iterators</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithms?view=vs-2019" data-text="algorithms ">Algorithms</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/allocators?view=vs-2019" data-text="allocators ">Allocators</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/function-objects-in-the-stl?view=vs-2019" data-text="function objects in the c++ standard library ">Function Objects in the C++ Standard Library</a></li><li role="group" data-moniker="vs-2015 vs-2017 vs-2019" aria-expanded="false" aria-label="iostream programming " tabindex="0" onclick="event.stopPropagation();msDocs.functions.toggleAriaExpanded(this)"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/iostream-programming?view=vs-2019" data-text="iostream programming ">iostream Programming</a><ul role="tree" onclick="msDocs.functions.stopSomePropagation(event, &quot;top&quot;)"><li role="group" data-moniker="vs-2015 vs-2017 vs-2019" aria-expanded="false" aria-label="what a stream is " tabindex="0" onclick="event.stopPropagation();msDocs.functions.toggleAriaExpanded(this)" class="noSubs"><a onclick="msDocs.functions.stopSomePropagation(event, &quot;left&quot;)" tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/what-a-stream-is?view=vs-2019" data-text="what a stream is ">What a Stream Is</a><ul role="tree" onclick="msDocs.functions.stopSomePropagation(event, &quot;top&quot;)"><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a onclick="msDocs.functions.stopSomePropagation(event, &quot;left&quot;)" tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/input-output-alternatives?view=vs-2019" data-text="input-output alternatives ">Input-Output Alternatives</a></li></ul></li><li role="group" data-moniker="vs-2015 vs-2017 vs-2019" aria-expanded="false" aria-label="output streams " tabindex="0" onclick="event.stopPropagation();msDocs.functions.toggleAriaExpanded(this)" class="noSubs"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/output-streams?view=vs-2019" data-text="output streams ">Output Streams</a><ul role="tree" onclick="msDocs.functions.stopSomePropagation(event, &quot;top&quot;)"><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a onclick="msDocs.functions.stopSomePropagation(event, &quot;left&quot;)" tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/constructing-output-stream-objects?view=vs-2019" data-text="constructing output stream objects ">Constructing Output Stream Objects</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/using-insertion-operators-and-controlling-format?view=vs-2019" data-text="using insertion operators and controlling format ">Using Insertion Operators and Controlling Format</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/output-file-stream-member-functions?view=vs-2019" data-text="output file stream member functions ">Output File Stream Member Functions</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/effects-of-buffering?view=vs-2019" data-text="effects of buffering ">Effects of Buffering</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/binary-output-files?view=vs-2019" data-text="binary output files ">Binary Output Files</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/overloading-the-output-operator-for-your-own-classes?view=vs-2019" data-text="overloading the &amp;lt;&amp;lt; operator for your own classes ">Overloading the &lt;&lt; Operator for Your Own Classes</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/writing-your-own-manipulators-without-arguments?view=vs-2019" data-text="writing your own manipulators without arguments ">Writing Your Own Manipulators Without Arguments</a></li></ul></li><li role="group" data-moniker="vs-2015 vs-2017 vs-2019" aria-expanded="false" aria-label="input streams " tabindex="0" onclick="event.stopPropagation();msDocs.functions.toggleAriaExpanded(this)" class="noSubs"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/input-streams?view=vs-2019" data-text="input streams ">Input Streams</a><ul role="tree" onclick="msDocs.functions.stopSomePropagation(event, &quot;top&quot;)"><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a onclick="msDocs.functions.stopSomePropagation(event, &quot;left&quot;)" tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/constructing-input-stream-objects?view=vs-2019" data-text="constructing input stream objects ">Constructing Input Stream Objects</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/using-extraction-operators?view=vs-2019" data-text="using extraction operators ">Using Extraction Operators</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/testing-for-extraction-errors?view=vs-2019" data-text="testing for extraction errors ">Testing for Extraction Errors</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/input-stream-manipulators?view=vs-2019" data-text="input stream manipulators ">Input Stream Manipulators</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/input-stream-member-functions?view=vs-2019" data-text="input stream member functions ">Input Stream Member Functions</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/overloading-the-input-operator-for-your-own-classes?view=vs-2019" data-text="overloading the &amp;gt;&amp;gt; operator for your own classes ">Overloading the &gt;&gt; Operator for Your Own Classes</a></li></ul></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/input-output-streams?view=vs-2019" data-text="input-output streams ">Input-Output Streams</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/iostreams-conventions?view=vs-2019" data-text="iostreams conventions ">iostreams Conventions</a></li><li role="group" data-moniker="vs-2015 vs-2017 vs-2019" aria-expanded="false" aria-label="custom manipulators with arguments " tabindex="0" onclick="event.stopPropagation();msDocs.functions.toggleAriaExpanded(this)" class="noSubs"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/custom-manipulators-with-arguments?view=vs-2019" data-text="custom manipulators with arguments ">Custom Manipulators with Arguments</a><ul role="tree" onclick="msDocs.functions.stopSomePropagation(event, &quot;top&quot;)"><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a onclick="msDocs.functions.stopSomePropagation(event, &quot;left&quot;)" tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/output-stream-manipulators-with-one-argument-int-or-long?view=vs-2019" data-text="output stream manipulators with one argument (int or long) ">Output Stream Manipulators with One Argument (int or long)</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/other-one-argument-output-stream-manipulators?view=vs-2019" data-text="other one-argument output stream manipulators ">Other One-Argument Output Stream Manipulators</a></li></ul></li></ul></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/regular-expressions-cpp?view=vs-2019" data-text="regular expressions (c++) ">Regular Expressions (C++)</a></li><li role="treeitem" data-moniker="vs-2015 vs-2017 vs-2019"><a tabindex="0" href="https://docs.microsoft.com/en-us/cpp/standard-library/file-system-navigation?view=vs-2019" data-text="file system navigation ">File System Navigation</a></li></ul></li></ul></nav>
							<div class="pdf-download-holder">
		<a href="https://docs.microsoft.com/en-us/cpp/opbuildpdf/vcppdocs-2015/standard-library/TOC.pdf?view=vs-2019&amp;branch=live" class="pdf-download-link has-inner-focus" data-bi-name="downloadPdf">
			<span class="icon">
				<span class="docon docon-arrow-down" aria-hidden="true"></span>
			</span>
			<span class="pdf-download-text">Download PDF</span>
		</a>
	</div>
						</div>
					</nav>
				</div>

			<aside id="interactive-container" class="interactive-container is-visible-interactive column has-body-background-dark ">
			</aside>
		</div>

		<!--end of .mainContainer -->
	</div>

	<div id="openFeedbackContainer" class="openfeedback-container">
		<form aria-live="assertive" aria-label="Your rating" class="rating has-default-focus rating-helpful-active" action="javascript:" data-bi-name="rating">
			<button class="rating-close has-default-focus has-inner-focus docon docon-navigate-close" type="button" aria-label="Close" data-bi-name="rating-close"></button>
			<button class="button is-primary rating-mobile-feedback" type="button" data-bi-name="rating-mobile-feedback">Feedback</button>
			<div class="rating-helpful">
				<label>Is this page helpful?</label>
				<div class="buttons">
					<button class="button is-primary" type="button" data-bi-name="rating-yes" data-bi-sat="1">Yes</button>
					<button class="button is-primary" type="button" data-bi-name="rating-no" data-bi-sat="0">No</button>
				</div>
			</div>
			<div class="rating-thanks1 has-default-focus">
				<p class="x-hidden-focus" tabindex="-1">Thanks for the feedback!</p>
				<p>Comments or suggestions? <a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#" data-bi-name="rating-verbatim-link">Tell us here</a>.</p>
			</div>
			<div class="rating-thanks2">
				<span class="x-hidden-focus" tabindex="-1">Thanks for the feedback!</span>
			</div>
			<div class="rating-verbatim has-default-focus">
				<label for="rating-0">How can we improve?</label>
				<textarea class="rating-textarea textarea" required="required" id="rating-0" placeholder="Please share your ideas. We welcome feedback in any language."></textarea>
				<button class="button is-primary" type="submit" data-bi-name="rating-verbatim" disabled="">Submit</button>
			</div>
		</form></div>

	<div class="footerContainer has-default-focus is-hidden-interactive ">
<footer id="footer" data-bi-name="footer" class="footer-layout uhf-container has-padding" role="contentinfo">

    <a data-mscc-ic="false" class="locale-selector-link" href="https://docs.microsoft.com/en-us/locale?target=https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#for_each" data-bi-name="select-locale"><span class="icon docon docon-world is-size-4 has-margin-right-small" aria-hidden="true"></span><span class="local-selector-link-text">English (United States)</span></a>

    <ul class="links" data-bi-name="footerlinks">
		<li><a data-mscc-ic="false" href="https://docs.microsoft.com/previous-versions/" data-bi-name="archivelink">Previous Version Docs</a></li>
		<li><a data-mscc-ic="false" href="https://docs.microsoft.com/teamblog" data-bi-name="bloglink">Blog</a></li>
		<li><a data-mscc-ic="false" href="https://docs.microsoft.com/contribute" data-bi-name="contributorGuide">Contribute</a></li>
			<li><a data-mscc-ic="false" href="https://go.microsoft.com/fwlink/?LinkId=521839" data-bi-name="privacy">Privacy &amp; Cookies</a></li>
		<li><a data-mscc-ic="false" href="https://docs.microsoft.com/en-us/legal/termsofuse" data-bi-name="termsofuse">Terms of Use</a></li>
		<li><a data-mscc-ic="false" href="https://aka.ms/sitefeedback" data-bi-name="feedback">Site Feedback</a></li>
		<li><a data-mscc-ic="false" href="https://www.microsoft.com/en-us/legal/intellectualproperty/Trademarks/EN-US.aspx" data-bi-name="trademarks">Trademarks</a></li>
    </ul>
</footer>
	</div>

	<div id="action-panel" role="region" aria-label="Action Panel" class="action-panel has-default-focus" tabindex="-1"></div>


</body></html>